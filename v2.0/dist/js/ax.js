/*!
 *Last modified: 2022-09-06 16:24:37
 *Filename: ax.js
 *Description: Global JS
 *Version: v2.0.1
 *Website:www.axui.cn or ax.hobly.cn
 *Contact:3217728223@qq.com
 *Author:Michael
 */
/*!
 * Fuse.js v6.5.3 from https://github.com/krisk/Fuse  or http://fusejs.io | AXUI增加了window变量
 */
!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?module.exports=factory():"function"==typeof define&&define.amd?define(factory):(global=window||global||self).Fuse=factory()}(this,(function(){"use strict";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){_defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function _typeof(obj){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj})(obj)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){return protoProps&&_defineProperties(Constructor.prototype,protoProps),staticProps&&_defineProperties(Constructor,staticProps),Object.defineProperty(Constructor,"prototype",{writable:!1}),Constructor}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function");Object.defineProperty(subClass,"prototype",{value:Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}}),writable:!1}),superClass&&_setPrototypeOf(subClass,superClass)}function _getPrototypeOf(o){return(_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o)})(o)}function _setPrototypeOf(o,p){return(_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){return o.__proto__=p,o})(o,p)}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return self}function _possibleConstructorReturn(self,call){if(call&&("object"==typeof call||"function"==typeof call))return call;if(void 0!==call)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(self)}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget)}else result=Super.apply(this,arguments);return _possibleConstructorReturn(this,result)}}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread()}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr)}function _iterableToArray(iter){if("undefined"!=typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _unsupportedIterableToArray(o,minLen){if(o){if("string"==typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(o,minLen):void 0}}function _arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function isArray(value){return Array.isArray?Array.isArray(value):"[object Array]"===getTag(value)}var INFINITY=1/0;function baseToString(value){if("string"==typeof value)return value;var result=value+"";return"0"==result&&1/value==-1/0?"-0":result}function toString(value){return null==value?"":baseToString(value)}function isString(value){return"string"==typeof value}function isNumber(value){return"number"==typeof value}function isBoolean(value){return!0===value||!1===value||isObjectLike(value)&&"[object Boolean]"==getTag(value)}function isObject(value){return"object"===_typeof(value)}function isObjectLike(value){return isObject(value)&&null!==value}function isDefined(value){return null!=value}function isBlank(value){return!value.trim().length}function getTag(value){return null==value?void 0===value?"[object Undefined]":"[object Null]":Object.prototype.toString.call(value)}var EXTENDED_SEARCH_UNAVAILABLE="Extended search is not available",INCORRECT_INDEX_TYPE="Incorrect 'index' type",LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY=function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key){return"Invalid value for key ".concat(key)},PATTERN_LENGTH_TOO_LARGE=function PATTERN_LENGTH_TOO_LARGE(max){return"Pattern length exceeds max of ".concat(max,".")},MISSING_KEY_PROPERTY=function MISSING_KEY_PROPERTY(name){return"Missing ".concat(name," property in key")},INVALID_KEY_WEIGHT_VALUE=function INVALID_KEY_WEIGHT_VALUE(key){return"Property 'weight' in key '".concat(key,"' must be a positive integer")},hasOwn=Object.prototype.hasOwnProperty,KeyStore=function(){function KeyStore(keys){var _this=this;_classCallCheck(this,KeyStore),this._keys=[],this._keyMap={};var totalWeight=0;keys.forEach((function(key){var obj=createKey(key);totalWeight+=obj.weight,_this._keys.push(obj),_this._keyMap[obj.id]=obj,totalWeight+=obj.weight})),this._keys.forEach((function(key){key.weight/=totalWeight}))}return _createClass(KeyStore,[{key:"get",value:function get(keyId){return this._keyMap[keyId]}},{key:"keys",value:function keys(){return this._keys}},{key:"toJSON",value:function toJSON(){return JSON.stringify(this._keys)}}]),KeyStore}();function createKey(key){var path=null,id=null,src=null,weight=1;if(isString(key)||isArray(key))src=key,path=createKeyPath(key),id=createKeyId(key);else{if(!hasOwn.call(key,"name"))throw new Error(MISSING_KEY_PROPERTY("name"));var name=key.name;if(src=name,hasOwn.call(key,"weight")&&(weight=key.weight)<=0)throw new Error(INVALID_KEY_WEIGHT_VALUE(name));path=createKeyPath(name),id=createKeyId(name)}return{path:path,id:id,weight:weight,src:src}}function createKeyPath(key){return isArray(key)?key:key.split(".")}function createKeyId(key){return isArray(key)?key.join("."):key}function get(obj,path){var list=[],arr=!1,deepGet;return function deepGet(obj,path,index){if(isDefined(obj))if(path[index]){var key,value=obj[path[index]];if(!isDefined(value))return;if(index===path.length-1&&(isString(value)||isNumber(value)||isBoolean(value)))list.push(toString(value));else if(isArray(value)){arr=!0;for(var i=0,len=value.length;i<len;i+=1)deepGet(value[i],path,index+1)}else path.length&&deepGet(value,path,index+1)}else list.push(obj)}(obj,isString(path)?path.split("."):path,0),arr?list:list[0]}var MatchOptions={includeMatches:!1,findAllMatches:!1,minMatchCharLength:1},BasicOptions,FuzzyOptions={location:0,threshold:.6,distance:100},AdvancedOptions={useExtendedSearch:!1,getFn:get,ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1},Config=_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({},{isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:function sortFn(a,b){return a.score===b.score?a.idx<b.idx?-1:1:a.score<b.score?-1:1}}),MatchOptions),FuzzyOptions),AdvancedOptions),SPACE=/[^ ]+/g;function norm(){var weight=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,mantissa=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,cache=new Map,m=Math.pow(10,mantissa);return{get:function get(value){var numTokens=value.match(SPACE).length;if(cache.has(numTokens))return cache.get(numTokens);var norm=1/Math.pow(numTokens,.5*weight),n=parseFloat(Math.round(norm*m)/m);return cache.set(numTokens,n),n},clear:function clear(){cache.clear()}}}var FuseIndex=function(){function FuseIndex(){var _ref=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},_ref$getFn=_ref.getFn,getFn=void 0===_ref$getFn?Config.getFn:_ref$getFn,_ref$fieldNormWeight=_ref.fieldNormWeight,fieldNormWeight=void 0===_ref$fieldNormWeight?Config.fieldNormWeight:_ref$fieldNormWeight;_classCallCheck(this,FuseIndex),this.norm=norm(fieldNormWeight,3),this.getFn=getFn,this.isCreated=!1,this.setIndexRecords()}return _createClass(FuseIndex,[{key:"setSources",value:function setSources(){var docs=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.docs=docs}},{key:"setIndexRecords",value:function setIndexRecords(){var records=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.records=records}},{key:"setKeys",value:function setKeys(){var _this=this,keys=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.keys=keys,this._keysMap={},keys.forEach((function(key,idx){_this._keysMap[key.id]=idx}))}},{key:"create",value:function create(){var _this2=this;!this.isCreated&&this.docs.length&&(this.isCreated=!0,isString(this.docs[0])?this.docs.forEach((function(doc,docIndex){_this2._addString(doc,docIndex)})):this.docs.forEach((function(doc,docIndex){_this2._addObject(doc,docIndex)})),this.norm.clear())}},{key:"add",value:function add(doc){var idx=this.size();isString(doc)?this._addString(doc,idx):this._addObject(doc,idx)}},{key:"removeAt",value:function removeAt(idx){this.records.splice(idx,1);for(var i=idx,len=this.size();i<len;i+=1)this.records[i].i-=1}},{key:"getValueForItemAtKeyId",value:function getValueForItemAtKeyId(item,keyId){return item[this._keysMap[keyId]]}},{key:"size",value:function size(){return this.records.length}},{key:"_addString",value:function _addString(doc,docIndex){if(isDefined(doc)&&!isBlank(doc)){var record={v:doc,i:docIndex,n:this.norm.get(doc)};this.records.push(record)}}},{key:"_addObject",value:function _addObject(doc,docIndex){var _this3=this,record={i:docIndex,$:{}};this.keys.forEach((function(key,keyIndex){var value=_this3.getFn(doc,key.path);if(isDefined(value))if(isArray(value))!function(){for(var subRecords=[],stack=[{nestedArrIndex:-1,value:value}];stack.length;){var _stack$pop=stack.pop(),nestedArrIndex=_stack$pop.nestedArrIndex,_value=_stack$pop.value;if(isDefined(_value))if(isString(_value)&&!isBlank(_value)){var subRecord={v:_value,i:nestedArrIndex,n:_this3.norm.get(_value)};subRecords.push(subRecord)}else isArray(_value)&&_value.forEach((function(item,k){stack.push({nestedArrIndex:k,value:item})}))}record.$[keyIndex]=subRecords}();else if(!isBlank(value)){var subRecord={v:value,n:_this3.norm.get(value)};record.$[keyIndex]=subRecord}})),this.records.push(record)}},{key:"toJSON",value:function toJSON(){return{keys:this.keys,records:this.records}}}]),FuseIndex}();function createIndex(keys,docs){var _ref2=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},_ref2$getFn=_ref2.getFn,getFn=void 0===_ref2$getFn?Config.getFn:_ref2$getFn,_ref2$fieldNormWeight=_ref2.fieldNormWeight,fieldNormWeight=void 0===_ref2$fieldNormWeight?Config.fieldNormWeight:_ref2$fieldNormWeight,myIndex=new FuseIndex({getFn:getFn,fieldNormWeight:fieldNormWeight});return myIndex.setKeys(keys.map(createKey)),myIndex.setSources(docs),myIndex.create(),myIndex}function parseIndex(data){var _ref3=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref3$getFn=_ref3.getFn,getFn=void 0===_ref3$getFn?Config.getFn:_ref3$getFn,_ref3$fieldNormWeight=_ref3.fieldNormWeight,fieldNormWeight=void 0===_ref3$fieldNormWeight?Config.fieldNormWeight:_ref3$fieldNormWeight,keys=data.keys,records=data.records,myIndex=new FuseIndex({getFn:getFn,fieldNormWeight:fieldNormWeight});return myIndex.setKeys(keys),myIndex.setIndexRecords(records),myIndex}function computeScore$1(pattern){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$errors=_ref.errors,errors=void 0===_ref$errors?0:_ref$errors,_ref$currentLocation=_ref.currentLocation,currentLocation=void 0===_ref$currentLocation?0:_ref$currentLocation,_ref$expectedLocation=_ref.expectedLocation,expectedLocation=void 0===_ref$expectedLocation?0:_ref$expectedLocation,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation,accuracy=errors/pattern.length;if(ignoreLocation)return accuracy;var proximity=Math.abs(expectedLocation-currentLocation);return distance?accuracy+proximity/distance:proximity?1:accuracy}function convertMaskToIndices(){for(var matchmask=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],minMatchCharLength=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Config.minMatchCharLength,indices=[],start=-1,end=-1,i=0,len=matchmask.length;i<len;i+=1){var match=matchmask[i];match&&-1===start?start=i:match||-1===start||((end=i-1)-start+1>=minMatchCharLength&&indices.push([start,end]),start=-1)}return matchmask[i-1]&&i-start>=minMatchCharLength&&indices.push([start,i-1]),indices}var MAX_BITS=32;function search(text,pattern,patternAlphabet){var _ref=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},_ref$location=_ref.location,location=void 0===_ref$location?Config.location:_ref$location,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance,_ref$threshold=_ref.threshold,threshold=void 0===_ref$threshold?Config.threshold:_ref$threshold,_ref$findAllMatches=_ref.findAllMatches,findAllMatches=void 0===_ref$findAllMatches?Config.findAllMatches:_ref$findAllMatches,_ref$minMatchCharLeng=_ref.minMatchCharLength,minMatchCharLength=void 0===_ref$minMatchCharLeng?Config.minMatchCharLength:_ref$minMatchCharLeng,_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation;if(pattern.length>32)throw new Error(PATTERN_LENGTH_TOO_LARGE(32));for(var patternLen=pattern.length,textLen=text.length,expectedLocation=Math.max(0,Math.min(location,textLen)),currentThreshold=threshold,bestLocation=expectedLocation,computeMatches=minMatchCharLength>1||includeMatches,matchMask=computeMatches?Array(textLen):[],index;(index=text.indexOf(pattern,bestLocation))>-1;){var score=computeScore$1(pattern,{currentLocation:index,expectedLocation:expectedLocation,distance:distance,ignoreLocation:ignoreLocation});if(currentThreshold=Math.min(score,currentThreshold),bestLocation=index+patternLen,computeMatches)for(var i=0;i<patternLen;)matchMask[index+i]=1,i+=1}bestLocation=-1;for(var lastBitArr=[],finalScore=1,binMax=patternLen+textLen,mask=1<<patternLen-1,_i=0;_i<patternLen;_i+=1){for(var binMin=0,binMid=binMax;binMin<binMid;){var _score2=computeScore$1(pattern,{errors:_i,currentLocation:expectedLocation+binMid,expectedLocation:expectedLocation,distance:distance,ignoreLocation:ignoreLocation});_score2<=currentThreshold?binMin=binMid:binMax=binMid,binMid=Math.floor((binMax-binMin)/2+binMin)}binMax=binMid;var start=Math.max(1,expectedLocation-binMid+1),finish=findAllMatches?textLen:Math.min(expectedLocation+binMid,textLen)+patternLen,bitArr=Array(finish+2);bitArr[finish+1]=(1<<_i)-1;for(var j=finish;j>=start;j-=1){var currentLocation=j-1,charMatch=patternAlphabet[text.charAt(currentLocation)];if(computeMatches&&(matchMask[currentLocation]=+!!charMatch),bitArr[j]=(bitArr[j+1]<<1|1)&charMatch,_i&&(bitArr[j]|=(lastBitArr[j+1]|lastBitArr[j])<<1|1|lastBitArr[j+1]),bitArr[j]&mask&&(finalScore=computeScore$1(pattern,{errors:_i,currentLocation:currentLocation,expectedLocation:expectedLocation,distance:distance,ignoreLocation:ignoreLocation}))<=currentThreshold){if(currentThreshold=finalScore,(bestLocation=currentLocation)<=expectedLocation)break;start=Math.max(1,2*expectedLocation-bestLocation)}}var _score=computeScore$1(pattern,{errors:_i+1,currentLocation:expectedLocation,expectedLocation:expectedLocation,distance:distance,ignoreLocation:ignoreLocation});if(_score>currentThreshold)break;lastBitArr=bitArr}var result={isMatch:bestLocation>=0,score:Math.max(.001,finalScore)};if(computeMatches){var indices=convertMaskToIndices(matchMask,minMatchCharLength);indices.length?includeMatches&&(result.indices=indices):result.isMatch=!1}return result}function createPatternAlphabet(pattern){for(var mask={},i=0,len=pattern.length;i<len;i+=1){var _char=pattern.charAt(i);mask[_char]=(mask[_char]||0)|1<<len-i-1}return mask}var BitapSearch=function(){function BitapSearch(pattern){var _this=this,_ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$location=_ref.location,location=void 0===_ref$location?Config.location:_ref$location,_ref$threshold=_ref.threshold,threshold=void 0===_ref$threshold?Config.threshold:_ref$threshold,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance,_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$findAllMatches=_ref.findAllMatches,findAllMatches=void 0===_ref$findAllMatches?Config.findAllMatches:_ref$findAllMatches,_ref$minMatchCharLeng=_ref.minMatchCharLength,minMatchCharLength=void 0===_ref$minMatchCharLeng?Config.minMatchCharLength:_ref$minMatchCharLeng,_ref$isCaseSensitive=_ref.isCaseSensitive,isCaseSensitive=void 0===_ref$isCaseSensitive?Config.isCaseSensitive:_ref$isCaseSensitive,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation;if(_classCallCheck(this,BitapSearch),this.options={location:location,threshold:threshold,distance:distance,includeMatches:includeMatches,findAllMatches:findAllMatches,minMatchCharLength:minMatchCharLength,isCaseSensitive:isCaseSensitive,ignoreLocation:ignoreLocation},this.pattern=isCaseSensitive?pattern:pattern.toLowerCase(),this.chunks=[],this.pattern.length){var addChunk=function addChunk(pattern,startIndex){_this.chunks.push({pattern:pattern,alphabet:createPatternAlphabet(pattern),startIndex:startIndex})},len=this.pattern.length;if(len>32){for(var i=0,remainder=len%32,end=len-remainder;i<end;)addChunk(this.pattern.substr(i,32),i),i+=32;if(remainder){var startIndex=len-32;addChunk(this.pattern.substr(startIndex),startIndex)}}else addChunk(this.pattern,0)}}return _createClass(BitapSearch,[{key:"searchIn",value:function searchIn(text){var _this$options=this.options,isCaseSensitive=_this$options.isCaseSensitive,includeMatches=_this$options.includeMatches;if(isCaseSensitive||(text=text.toLowerCase()),this.pattern===text){var _result={isMatch:!0,score:0};return includeMatches&&(_result.indices=[[0,text.length-1]]),_result}var _this$options2=this.options,location=_this$options2.location,distance=_this$options2.distance,threshold=_this$options2.threshold,findAllMatches=_this$options2.findAllMatches,minMatchCharLength=_this$options2.minMatchCharLength,ignoreLocation=_this$options2.ignoreLocation,allIndices=[],totalScore=0,hasMatches=!1;this.chunks.forEach((function(_ref2){var pattern=_ref2.pattern,alphabet=_ref2.alphabet,startIndex=_ref2.startIndex,_search=search(text,pattern,alphabet,{location:location+startIndex,distance:distance,threshold:threshold,findAllMatches:findAllMatches,minMatchCharLength:minMatchCharLength,includeMatches:includeMatches,ignoreLocation:ignoreLocation}),isMatch=_search.isMatch,score=_search.score,indices=_search.indices;isMatch&&(hasMatches=!0),totalScore+=score,isMatch&&indices&&(allIndices=[].concat(_toConsumableArray(allIndices),_toConsumableArray(indices)))}));var result={isMatch:hasMatches,score:hasMatches?totalScore/this.chunks.length:1};return hasMatches&&includeMatches&&(result.indices=allIndices),result}}]),BitapSearch}(),BaseMatch=function(){function BaseMatch(pattern){_classCallCheck(this,BaseMatch),this.pattern=pattern}return _createClass(BaseMatch,[{key:"search",value:function search(){}}],[{key:"isMultiMatch",value:function isMultiMatch(pattern){return getMatch(pattern,this.multiRegex)}},{key:"isSingleMatch",value:function isSingleMatch(pattern){return getMatch(pattern,this.singleRegex)}}]),BaseMatch}();function getMatch(pattern,exp){var matches=pattern.match(exp);return matches?matches[1]:null}var ExactMatch=function(_BaseMatch){_inherits(ExactMatch,_BaseMatch);var _super=_createSuper(ExactMatch);function ExactMatch(pattern){return _classCallCheck(this,ExactMatch),_super.call(this,pattern)}return _createClass(ExactMatch,[{key:"search",value:function search(text){var isMatch=text===this.pattern;return{isMatch:isMatch,score:isMatch?0:1,indices:[0,this.pattern.length-1]}}}],[{key:"type",get:function get(){return"exact"}},{key:"multiRegex",get:function get(){return/^="(.*)"$/}},{key:"singleRegex",get:function get(){return/^=(.*)$/}}]),ExactMatch}(BaseMatch),InverseExactMatch=function(_BaseMatch){_inherits(InverseExactMatch,_BaseMatch);var _super=_createSuper(InverseExactMatch);function InverseExactMatch(pattern){return _classCallCheck(this,InverseExactMatch),_super.call(this,pattern)}return _createClass(InverseExactMatch,[{key:"search",value:function search(text){var index,isMatch=-1===text.indexOf(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[0,text.length-1]}}}],[{key:"type",get:function get(){return"inverse-exact"}},{key:"multiRegex",get:function get(){return/^!"(.*)"$/}},{key:"singleRegex",get:function get(){return/^!(.*)$/}}]),InverseExactMatch}(BaseMatch),PrefixExactMatch=function(_BaseMatch){_inherits(PrefixExactMatch,_BaseMatch);var _super=_createSuper(PrefixExactMatch);function PrefixExactMatch(pattern){return _classCallCheck(this,PrefixExactMatch),_super.call(this,pattern)}return _createClass(PrefixExactMatch,[{key:"search",value:function search(text){var isMatch=text.startsWith(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[0,this.pattern.length-1]}}}],[{key:"type",get:function get(){return"prefix-exact"}},{key:"multiRegex",get:function get(){return/^\^"(.*)"$/}},{key:"singleRegex",get:function get(){return/^\^(.*)$/}}]),PrefixExactMatch}(BaseMatch),InversePrefixExactMatch=function(_BaseMatch){_inherits(InversePrefixExactMatch,_BaseMatch);var _super=_createSuper(InversePrefixExactMatch);function InversePrefixExactMatch(pattern){return _classCallCheck(this,InversePrefixExactMatch),_super.call(this,pattern)}return _createClass(InversePrefixExactMatch,[{key:"search",value:function search(text){var isMatch=!text.startsWith(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[0,text.length-1]}}}],[{key:"type",get:function get(){return"inverse-prefix-exact"}},{key:"multiRegex",get:function get(){return/^!\^"(.*)"$/}},{key:"singleRegex",get:function get(){return/^!\^(.*)$/}}]),InversePrefixExactMatch}(BaseMatch),SuffixExactMatch=function(_BaseMatch){_inherits(SuffixExactMatch,_BaseMatch);var _super=_createSuper(SuffixExactMatch);function SuffixExactMatch(pattern){return _classCallCheck(this,SuffixExactMatch),_super.call(this,pattern)}return _createClass(SuffixExactMatch,[{key:"search",value:function search(text){var isMatch=text.endsWith(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[text.length-this.pattern.length,text.length-1]}}}],[{key:"type",get:function get(){return"suffix-exact"}},{key:"multiRegex",get:function get(){return/^"(.*)"\$$/}},{key:"singleRegex",get:function get(){return/^(.*)\$$/}}]),SuffixExactMatch}(BaseMatch),InverseSuffixExactMatch=function(_BaseMatch){_inherits(InverseSuffixExactMatch,_BaseMatch);var _super=_createSuper(InverseSuffixExactMatch);function InverseSuffixExactMatch(pattern){return _classCallCheck(this,InverseSuffixExactMatch),_super.call(this,pattern)}return _createClass(InverseSuffixExactMatch,[{key:"search",value:function search(text){var isMatch=!text.endsWith(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[0,text.length-1]}}}],[{key:"type",get:function get(){return"inverse-suffix-exact"}},{key:"multiRegex",get:function get(){return/^!"(.*)"\$$/}},{key:"singleRegex",get:function get(){return/^!(.*)\$$/}}]),InverseSuffixExactMatch}(BaseMatch),FuzzyMatch=function(_BaseMatch){_inherits(FuzzyMatch,_BaseMatch);var _super=_createSuper(FuzzyMatch);function FuzzyMatch(pattern){var _this,_ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$location=_ref.location,location=void 0===_ref$location?Config.location:_ref$location,_ref$threshold=_ref.threshold,threshold=void 0===_ref$threshold?Config.threshold:_ref$threshold,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance,_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$findAllMatches=_ref.findAllMatches,findAllMatches=void 0===_ref$findAllMatches?Config.findAllMatches:_ref$findAllMatches,_ref$minMatchCharLeng=_ref.minMatchCharLength,minMatchCharLength=void 0===_ref$minMatchCharLeng?Config.minMatchCharLength:_ref$minMatchCharLeng,_ref$isCaseSensitive=_ref.isCaseSensitive,isCaseSensitive=void 0===_ref$isCaseSensitive?Config.isCaseSensitive:_ref$isCaseSensitive,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation;return _classCallCheck(this,FuzzyMatch),(_this=_super.call(this,pattern))._bitapSearch=new BitapSearch(pattern,{location:location,threshold:threshold,distance:distance,includeMatches:includeMatches,findAllMatches:findAllMatches,minMatchCharLength:minMatchCharLength,isCaseSensitive:isCaseSensitive,ignoreLocation:ignoreLocation}),_this}return _createClass(FuzzyMatch,[{key:"search",value:function search(text){return this._bitapSearch.searchIn(text)}}],[{key:"type",get:function get(){return"fuzzy"}},{key:"multiRegex",get:function get(){return/^"(.*)"$/}},{key:"singleRegex",get:function get(){return/^(.*)$/}}]),FuzzyMatch}(BaseMatch),IncludeMatch=function(_BaseMatch){_inherits(IncludeMatch,_BaseMatch);var _super=_createSuper(IncludeMatch);function IncludeMatch(pattern){return _classCallCheck(this,IncludeMatch),_super.call(this,pattern)}return _createClass(IncludeMatch,[{key:"search",value:function search(text){for(var location=0,index,indices=[],patternLen=this.pattern.length;(index=text.indexOf(this.pattern,location))>-1;)location=index+patternLen,indices.push([index,location-1]);var isMatch=!!indices.length;return{isMatch:isMatch,score:isMatch?0:1,indices:indices}}}],[{key:"type",get:function get(){return"include"}},{key:"multiRegex",get:function get(){return/^'"(.*)"$/}},{key:"singleRegex",get:function get(){return/^'(.*)$/}}]),IncludeMatch}(BaseMatch),searchers=[ExactMatch,IncludeMatch,PrefixExactMatch,InversePrefixExactMatch,InverseSuffixExactMatch,SuffixExactMatch,InverseExactMatch,FuzzyMatch],searchersLen=searchers.length,SPACE_RE=/ +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/,OR_TOKEN="|";function parseQuery(pattern){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return pattern.split("|").map((function(item){for(var query=item.trim().split(SPACE_RE).filter((function(item){return item&&!!item.trim()})),results=[],i=0,len=query.length;i<len;i+=1){for(var queryItem=query[i],found=!1,idx=-1;!found&&++idx<searchersLen;){var searcher=searchers[idx],token=searcher.isMultiMatch(queryItem);token&&(results.push(new searcher(token,options)),found=!0)}if(!found)for(idx=-1;++idx<searchersLen;){var _searcher=searchers[idx],_token=_searcher.isSingleMatch(queryItem);if(_token){results.push(new _searcher(_token,options));break}}}return results}))}var MultiMatchSet=new Set([FuzzyMatch.type,IncludeMatch.type]),ExtendedSearch=function(){function ExtendedSearch(pattern){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$isCaseSensitive=_ref.isCaseSensitive,isCaseSensitive=void 0===_ref$isCaseSensitive?Config.isCaseSensitive:_ref$isCaseSensitive,_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$minMatchCharLeng=_ref.minMatchCharLength,minMatchCharLength=void 0===_ref$minMatchCharLeng?Config.minMatchCharLength:_ref$minMatchCharLeng,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation,_ref$findAllMatches=_ref.findAllMatches,findAllMatches=void 0===_ref$findAllMatches?Config.findAllMatches:_ref$findAllMatches,_ref$location=_ref.location,location=void 0===_ref$location?Config.location:_ref$location,_ref$threshold=_ref.threshold,threshold=void 0===_ref$threshold?Config.threshold:_ref$threshold,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance;_classCallCheck(this,ExtendedSearch),this.query=null,this.options={isCaseSensitive:isCaseSensitive,includeMatches:includeMatches,minMatchCharLength:minMatchCharLength,findAllMatches:findAllMatches,ignoreLocation:ignoreLocation,location:location,threshold:threshold,distance:distance},this.pattern=isCaseSensitive?pattern:pattern.toLowerCase(),this.query=parseQuery(this.pattern,this.options)}return _createClass(ExtendedSearch,[{key:"searchIn",value:function searchIn(text){var query=this.query;if(!query)return{isMatch:!1,score:1};var _this$options=this.options,includeMatches=_this$options.includeMatches,isCaseSensitive;text=_this$options.isCaseSensitive?text:text.toLowerCase();for(var numMatches=0,allIndices=[],totalScore=0,i=0,qLen=query.length;i<qLen;i+=1){var searchers=query[i];allIndices.length=0,numMatches=0;for(var j=0,pLen=searchers.length;j<pLen;j+=1){var searcher=searchers[j],_searcher$search=searcher.search(text),isMatch=_searcher$search.isMatch,indices=_searcher$search.indices,score=_searcher$search.score;if(!isMatch){totalScore=0,numMatches=0,allIndices.length=0;break}if(numMatches+=1,totalScore+=score,includeMatches){var type=searcher.constructor.type;MultiMatchSet.has(type)?allIndices=[].concat(_toConsumableArray(allIndices),_toConsumableArray(indices)):allIndices.push(indices)}}if(numMatches){var result={isMatch:!0,score:totalScore/numMatches};return includeMatches&&(result.indices=allIndices),result}}return{isMatch:!1,score:1}}}],[{key:"condition",value:function condition(_,options){return options.useExtendedSearch}}]),ExtendedSearch}(),registeredSearchers=[];function register(){registeredSearchers.push.apply(registeredSearchers,arguments)}function createSearcher(pattern,options){for(var i=0,len=registeredSearchers.length;i<len;i+=1){var searcherClass=registeredSearchers[i];if(searcherClass.condition(pattern,options))return new searcherClass(pattern,options)}return new BitapSearch(pattern,options)}var LogicalOperator_AND="$and",LogicalOperator_OR="$or",KeyType_PATH="$path",KeyType_PATTERN="$val",isExpression=function isExpression(query){return!(!query[LogicalOperator_AND]&&!query[LogicalOperator_OR])},isPath=function isPath(query){return!!query[KeyType_PATH]},isLeaf=function isLeaf(query){return!isArray(query)&&isObject(query)&&!isExpression(query)},convertToExplicit=function convertToExplicit(query){return _defineProperty({},LogicalOperator_AND,Object.keys(query).map((function(key){return _defineProperty({},key,query[key])})))};function parse(query,options){var _ref3=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},_ref3$auto=_ref3.auto,auto=void 0===_ref3$auto||_ref3$auto,next=function next(query){var keys=Object.keys(query),isQueryPath=isPath(query);if(!isQueryPath&&keys.length>1&&!isExpression(query))return next(convertToExplicit(query));if(isLeaf(query)){var key=isQueryPath?query[KeyType_PATH]:keys[0],pattern=isQueryPath?query[KeyType_PATTERN]:query[key];if(!isString(pattern))throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));var obj={keyId:createKeyId(key),pattern:pattern};return auto&&(obj.searcher=createSearcher(pattern,options)),obj}var node={children:[],operator:keys[0]};return keys.forEach((function(key){var value=query[key];isArray(value)&&value.forEach((function(item){node.children.push(next(item))}))})),node};return isExpression(query)||(query=convertToExplicit(query)),next(query)}function computeScore(results,_ref){var _ref$ignoreFieldNorm=_ref.ignoreFieldNorm,ignoreFieldNorm=void 0===_ref$ignoreFieldNorm?Config.ignoreFieldNorm:_ref$ignoreFieldNorm;results.forEach((function(result){var totalScore=1;result.matches.forEach((function(_ref2){var key=_ref2.key,norm=_ref2.norm,score=_ref2.score,weight=key?key.weight:null;totalScore*=Math.pow(0===score&&weight?Number.EPSILON:score,(weight||1)*(ignoreFieldNorm?1:norm))})),result.score=totalScore}))}function transformMatches(result,data){var matches=result.matches;data.matches=[],isDefined(matches)&&matches.forEach((function(match){if(isDefined(match.indices)&&match.indices.length){var indices,value,obj={indices:match.indices,value:match.value};match.key&&(obj.key=match.key.src),match.idx>-1&&(obj.refIndex=match.idx),data.matches.push(obj)}}))}function transformScore(result,data){data.score=result.score}function format(results,docs){var _ref=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$includeScore=_ref.includeScore,includeScore=void 0===_ref$includeScore?Config.includeScore:_ref$includeScore,transformers=[];return includeMatches&&transformers.push(transformMatches),includeScore&&transformers.push(transformScore),results.map((function(result){var idx=result.idx,data={item:docs[idx],refIndex:idx};return transformers.length&&transformers.forEach((function(transformer){transformer(result,data)})),data}))}var Fuse$1=function(){function Fuse(docs){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},index=arguments.length>2?arguments[2]:void 0;_classCallCheck(this,Fuse),this.options=_objectSpread2(_objectSpread2({},Config),options),this.options.useExtendedSearch,this._keyStore=new KeyStore(this.options.keys),this.setCollection(docs,index)}return _createClass(Fuse,[{key:"setCollection",value:function setCollection(docs,index){if(this._docs=docs,index&&!(index instanceof FuseIndex))throw new Error(INCORRECT_INDEX_TYPE);this._myIndex=index||createIndex(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}},{key:"add",value:function add(doc){isDefined(doc)&&(this._docs.push(doc),this._myIndex.add(doc))}},{key:"remove",value:function remove(){for(var predicate=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){return!1},results=[],i=0,len=this._docs.length;i<len;i+=1){var doc=this._docs[i];predicate(doc,i)&&(this.removeAt(i),i-=1,len-=1,results.push(doc))}return results}},{key:"removeAt",value:function removeAt(idx){this._docs.splice(idx,1),this._myIndex.removeAt(idx)}},{key:"getIndex",value:function getIndex(){return this._myIndex}},{key:"search",value:function search(query){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$limit=_ref.limit,limit=void 0===_ref$limit?-1:_ref$limit,_this$options=this.options,includeMatches=_this$options.includeMatches,includeScore=_this$options.includeScore,shouldSort=_this$options.shouldSort,sortFn=_this$options.sortFn,ignoreFieldNorm=_this$options.ignoreFieldNorm,results=isString(query)?isString(this._docs[0])?this._searchStringList(query):this._searchObjectList(query):this._searchLogical(query);return computeScore(results,{ignoreFieldNorm:ignoreFieldNorm}),shouldSort&&results.sort(sortFn),isNumber(limit)&&limit>-1&&(results=results.slice(0,limit)),format(results,this._docs,{includeMatches:includeMatches,includeScore:includeScore})}},{key:"_searchStringList",value:function _searchStringList(query){var searcher=createSearcher(query,this.options),records=this._myIndex.records,results=[];return records.forEach((function(_ref2){var text=_ref2.v,idx=_ref2.i,norm=_ref2.n;if(isDefined(text)){var _searcher$searchIn=searcher.searchIn(text),isMatch=_searcher$searchIn.isMatch,score=_searcher$searchIn.score,indices=_searcher$searchIn.indices;isMatch&&results.push({item:text,idx:idx,matches:[{score:score,value:text,norm:norm,indices:indices}]})}})),results}},{key:"_searchLogical",value:function _searchLogical(query){var _this=this,expression=parse(query,this.options),evaluate=function evaluate(node,item,idx){if(!node.children){var keyId=node.keyId,searcher=node.searcher,matches=_this._findMatches({key:_this._keyStore.get(keyId),value:_this._myIndex.getValueForItemAtKeyId(item,keyId),searcher:searcher});return matches&&matches.length?[{idx:idx,item:item,matches:matches}]:[]}for(var res=[],i=0,len=node.children.length;i<len;i+=1){var child,result=evaluate(node.children[i],item,idx);if(result.length)res.push.apply(res,_toConsumableArray(result));else if(node.operator===LogicalOperator_AND)return[]}return res},records=this._myIndex.records,resultMap={},results=[];return records.forEach((function(_ref3){var item=_ref3.$,idx=_ref3.i;if(isDefined(item)){var expResults=evaluate(expression,item,idx);expResults.length&&(resultMap[idx]||(resultMap[idx]={idx:idx,item:item,matches:[]},results.push(resultMap[idx])),expResults.forEach((function(_ref4){var _resultMap$idx$matche,matches=_ref4.matches;(_resultMap$idx$matche=resultMap[idx].matches).push.apply(_resultMap$idx$matche,_toConsumableArray(matches))})))}})),results}},{key:"_searchObjectList",value:function _searchObjectList(query){var _this2=this,searcher=createSearcher(query,this.options),_this$_myIndex=this._myIndex,keys=_this$_myIndex.keys,records=_this$_myIndex.records,results=[];return records.forEach((function(_ref5){var item=_ref5.$,idx=_ref5.i;if(isDefined(item)){var matches=[];keys.forEach((function(key,keyIndex){matches.push.apply(matches,_toConsumableArray(_this2._findMatches({key:key,value:item[keyIndex],searcher:searcher})))})),matches.length&&results.push({idx:idx,item:item,matches:matches})}})),results}},{key:"_findMatches",value:function _findMatches(_ref6){var key=_ref6.key,value=_ref6.value,searcher=_ref6.searcher;if(!isDefined(value))return[];var matches=[];if(isArray(value))value.forEach((function(_ref7){var text=_ref7.v,idx=_ref7.i,norm=_ref7.n;if(isDefined(text)){var _searcher$searchIn2=searcher.searchIn(text),isMatch=_searcher$searchIn2.isMatch,score=_searcher$searchIn2.score,indices=_searcher$searchIn2.indices;isMatch&&matches.push({score:score,key:key,value:text,idx:idx,norm:norm,indices:indices})}}));else{var text=value.v,norm=value.n,_searcher$searchIn3=searcher.searchIn(text),isMatch=_searcher$searchIn3.isMatch,score=_searcher$searchIn3.score,indices=_searcher$searchIn3.indices;isMatch&&matches.push({score:score,key:key,value:text,norm:norm,indices:indices})}return matches}}]),Fuse}(),Fuse;return Fuse$1.version="6.5.3",Fuse$1.createIndex=createIndex,Fuse$1.parseIndex=parseIndex,Fuse$1.config=Config,Fuse$1.parseQuery=parse,register(ExtendedSearch),Fuse$1}));
/*!
 * Popper.js v2.10.2 from https://github.com/popperjs/popper-core | AXUI部分修改
 * 1、data-popper-placement、data-popper-arrow、data-popper-reference-hidden、data-popper-escaped去掉了“popper-”，进行了简化处理
 * 2、修复了popper比按钮宽度或高度小的时候，箭头始终是在按钮中间的问题
 * 3、新增options.fixDistance参数，默认值为24，与第二个问题一致
 * 4、update方法增加参数elem
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Popper={})}(this,(function(e){"use strict";function t(e,t){var n=e.getBoundingClientRect();return{width:n.width/1,height:n.height/1,top:n.top/1,right:n.right/1,bottom:n.bottom/1,left:n.left/1,x:n.left/1,y:n.top/1}}function n(e){if(null==e)return window;if("[object Window]"!==e.toString()){var t=e.ownerDocument;return t&&t.defaultView||window}return e}function r(e){var t=n(e);return{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function o(e){return e instanceof n(e).Element||e instanceof Element}function i(e){return e instanceof n(e).HTMLElement||e instanceof HTMLElement}function a(e){return"undefined"!=typeof ShadowRoot&&(e instanceof n(e).ShadowRoot||e instanceof ShadowRoot)}function s(e){return e?(e.nodeName||"").toLowerCase():null}function f(e){return((o(e)?e.ownerDocument:e.document)||window.document).documentElement}function c(e){return t(f(e)).left+r(e).scrollLeft}function p(e){return n(e).getComputedStyle(e)}function l(e){var t=p(e),n=t.overflow,r=t.overflowX,o=t.overflowY;return/auto|scroll|overlay|hidden/.test(n+o+r)}function u(e,o,a){void 0===a&&(a=!1);var p=i(o);i(o)&&function(e){var t=e.getBoundingClientRect(),n=t.width/e.offsetWidth||1,r=t.height/e.offsetHeight||1}(o);var u,d,m=f(o),h=t(e),v={scrollLeft:0,scrollTop:0},g={x:0,y:0};return(p||!p&&!a)&&(("body"!==s(o)||l(m))&&(v=(u=o)!==n(u)&&i(u)?{scrollLeft:(d=u).scrollLeft,scrollTop:d.scrollTop}:r(u)),i(o)?((g=t(o)).x+=o.clientLeft,g.y+=o.clientTop):m&&(g.x=c(m))),{x:h.left+v.scrollLeft-g.x,y:h.top+v.scrollTop-g.y,width:h.width,height:h.height}}function d(e){var n=t(e),r=e.offsetWidth,o=e.offsetHeight;return Math.abs(n.width-r)<=1&&(r=n.width),Math.abs(n.height-o)<=1&&(o=n.height),{x:e.offsetLeft,y:e.offsetTop,width:r,height:o}}function m(e){return"html"===s(e)?e:e.assignedSlot||e.parentNode||(a(e)?e.host:null)||f(e)}function h(e,t){var r;void 0===t&&(t=[]);var o=function e(t){return["html","body","#document"].indexOf(s(t))>=0?t.ownerDocument.body:i(t)&&l(t)?t:e(m(t))}(e),a=o===(null==(r=e.ownerDocument)?void 0:r.body),f=n(o),c=a?[f].concat(f.visualViewport||[],l(o)?o:[]):o,p=t.concat(c);return a?p:p.concat(h(m(c)))}function v(e){return["table","td","th"].indexOf(s(e))>=0}function g(e){return i(e)&&"fixed"!==p(e).position?e.offsetParent:null}function b(e){for(var t=n(e),r=g(e);r&&v(r)&&"static"===p(r).position;)r=g(r);return r&&("html"===s(r)||"body"===s(r)&&"static"===p(r).position)?t:r||function(e){var t=-1!==navigator.userAgent.toLowerCase().indexOf("firefox");if(-1!==navigator.userAgent.indexOf("Trident")&&i(e)&&"fixed"===p(e).position)return null;for(var n=m(e);i(n)&&["html","body"].indexOf(s(n))<0;){var r=p(n);if("none"!==r.transform||"none"!==r.perspective||"paint"===r.contain||-1!==["transform","perspective"].indexOf(r.willChange)||t&&"filter"===r.willChange||t&&r.filter&&"none"!==r.filter)return n;n=n.parentNode}return null}(e)||t}var y="top",w="bottom",x="right",O="left",j=[y,w,x,O],E=j.reduce((function(e,t){return e.concat([t+"-start",t+"-end"])}),[]),S=[].concat(j,["auto"]).reduce((function(e,t){return e.concat([t,t+"-start",t+"-end"])}),[]),D=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function P(e){var t=new Map,n=new Set,r=[];return e.forEach((function(e){t.set(e.name,e)})),e.forEach((function(e){n.has(e.name)||function e(o){n.add(o.name),[].concat(o.requires||[],o.requiresIfExists||[]).forEach((function(r){if(!n.has(r)){var o=t.get(r);o&&e(o)}})),r.push(o)}(e)})),r}function k(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return[].concat(n).reduce((function(e,t){return e.replace(/%s/,t)}),e)}var L='Popper: modifier "%s" provided an invalid %s property, expected %s but got %s',M=["name","enabled","phase","fn","effect","requires","options"];function T(e){return e.split("-")[0]}var q=Math.max,A=Math.min,W=Math.round;function B(e,t){var n=t.getRootNode&&t.getRootNode();if(e.contains(t))return!0;if(n&&a(n)){var r=t;do{if(r&&e.isSameNode(r))return!0;r=r.parentNode||r.host}while(r)}return!1}function H(e){return Object.assign({},e,{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function C(e,o){return"viewport"===o?H(function(e){var t=n(e),r=f(e),o=t.visualViewport,i=r.clientWidth,a=r.clientHeight,s=0,p=0;return o&&(i=o.width,a=o.height,/^((?!chrome|android).)*safari/i.test(navigator.userAgent)||(s=o.offsetLeft,p=o.offsetTop)),{width:i,height:a,x:s+c(e),y:p}}(e)):i(o)?function(e){var n=t(e);return n.top=n.top+e.clientTop,n.left=n.left+e.clientLeft,n.bottom=n.top+e.clientHeight,n.right=n.left+e.clientWidth,n.width=e.clientWidth,n.height=e.clientHeight,n.x=n.left,n.y=n.top,n}(o):H(function(e){var t,n=f(e),o=r(e),i=null==(t=e.ownerDocument)?void 0:t.body,a=q(n.scrollWidth,n.clientWidth,i?i.scrollWidth:0,i?i.clientWidth:0),s=q(n.scrollHeight,n.clientHeight,i?i.scrollHeight:0,i?i.clientHeight:0),l=-o.scrollLeft+c(e),u=-o.scrollTop;return"rtl"===p(i||n).direction&&(l+=q(n.clientWidth,i?i.clientWidth:0)-a),{width:a,height:s,x:l,y:u}}(f(e)))}function R(e,t,n){var r="clippingParents"===t?function(e){var t=h(m(e)),n=["absolute","fixed"].indexOf(p(e).position)>=0&&i(e)?b(e):e;return o(n)?t.filter((function(e){return o(e)&&B(e,n)&&"body"!==s(e)})):[]}(e):[].concat(t),a=[].concat(r,[n]),f=a[0],c=a.reduce((function(t,n){var r=C(e,n);return t.top=q(r.top,t.top),t.right=A(r.right,t.right),t.bottom=A(r.bottom,t.bottom),t.left=q(r.left,t.left),t}),C(e,f));return c.width=c.right-c.left,c.height=c.bottom-c.top,c.x=c.left,c.y=c.top,c}function I(e){return e.split("-")[1]}function V(e){return["top","bottom"].indexOf(e)>=0?"x":"y"}function N(e){var t,n=e.reference,r=e.element,o=e.placement,i=o?T(o):null,a=o?I(o):null,s=n.x+n.width/2-r.width/2,f=n.y+n.height/2-r.height/2;switch(i){case y:t={x:s,y:n.y-r.height};break;case w:t={x:s,y:n.y+n.height};break;case x:t={x:n.x+n.width,y:f};break;case O:t={x:n.x-r.width,y:f};break;default:t={x:n.x,y:n.y}}var c=i?V(i):null;if(null!=c){var p="y"===c?"height":"width";switch(a){case"start":t[c]=t[c]-(n[p]/2-r[p]/2);break;case"end":t[c]=t[c]+(n[p]/2-r[p]/2)}}return t}function U(e){return Object.assign({},{top:0,right:0,bottom:0,left:0},e)}function _(e,t){return t.reduce((function(t,n){return t[n]=e,t}),{})}function F(e,n){void 0===n&&(n={});var r=n,i=r.placement,a=void 0===i?e.placement:i,s=r.boundary,c=void 0===s?"clippingParents":s,p=r.rootBoundary,l=void 0===p?"viewport":p,u=r.elementContext,d=void 0===u?"popper":u,m=r.altBoundary,h=void 0!==m&&m,v=r.padding,g=void 0===v?0:v,b=U("number"!=typeof g?g:_(g,j)),O="popper"===d?"reference":"popper",E=e.rects.popper,S=e.elements[h?O:d],D=R(o(S)?S:S.contextElement||f(e.elements.popper),c,l),P=t(e.elements.reference),k=N({reference:P,element:E,strategy:"absolute",placement:a}),L=H(Object.assign({},E,k)),M="popper"===d?L:P,T={top:D.top-M.top+b.top,bottom:M.bottom-D.bottom+b.bottom,left:D.left-M.left+b.left,right:M.right-D.right+b.right},q=e.modifiersData.offset;if("popper"===d&&q){var A=q[a];Object.keys(T).forEach((function(e){var t=[x,w].indexOf(e)>=0?1:-1,n=[y,w].indexOf(e)>=0?"y":"x";T[e]+=A[n]*t}))}return T}var z="Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.",G={placement:"bottom",modifiers:[],strategy:"absolute",fixDistance:24};function X(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return!t.some((function(e){return!(e&&"function"==typeof e.getBoundingClientRect)}))}function Y(e){void 0===e&&(e={});var t=e,n=t.defaultModifiers,r=void 0===n?[]:n,i=t.defaultOptions,a=void 0===i?G:i;return function(e,t,n){void 0===n&&(n=a);var i,s,f={placement:"bottom",orderedModifiers:[],options:Object.assign({},G,a),modifiersData:{},elements:{reference:e,popper:t},attributes:{},styles:{}},c=[],l=!1,m={state:f,setOptions:function(n){var i="function"==typeof n?n(f.options):n;v(),f.options=Object.assign({},a,f.options,i),f.scrollParents={reference:o(e)?h(e):e.contextElement?h(e.contextElement):[],popper:h(t)};var s=function(e){var t=P(e);return D.reduce((function(e,n){return e.concat(t.filter((function(e){return e.phase===n})))}),[])}(function(e){var t=e.reduce((function(e,t){var n=e[t.name];return e[t.name]=n?Object.assign({},n,t,{options:Object.assign({},n.options,t.options),data:Object.assign({},n.data,t.data)}):t,e}),{});return Object.keys(t).map((function(e){return t[e]}))}([].concat(r,f.options.modifiers)));(f.orderedModifiers=s.filter((function(e){return e.enabled})),function(e){e.forEach((function(t){[].concat(Object.keys(t),M).filter((function(e,t,n){return n.indexOf(e)===t})).forEach((function(n){switch(n){case"name":"string"!=typeof t.name&&console.error(k(L,String(t.name),'"name"','"string"','"'+String(t.name)+'"'));break;case"enabled":"boolean"!=typeof t.enabled&&console.error(k(L,t.name,'"enabled"','"boolean"','"'+String(t.enabled)+'"'));break;case"phase":D.indexOf(t.phase)<0&&console.error(k(L,t.name,'"phase"',"either "+D.join(", "),'"'+String(t.phase)+'"'));break;case"fn":"function"!=typeof t.fn&&console.error(k(L,t.name,'"fn"','"function"','"'+String(t.fn)+'"'));break;case"effect":null!=t.effect&&"function"!=typeof t.effect&&console.error(k(L,t.name,'"effect"','"function"','"'+String(t.fn)+'"'));break;case"requires":null==t.requires||Array.isArray(t.requires)||console.error(k(L,t.name,'"requires"','"array"','"'+String(t.requires)+'"'));break;case"requiresIfExists":Array.isArray(t.requiresIfExists)||console.error(k(L,t.name,'"requiresIfExists"','"array"','"'+String(t.requiresIfExists)+'"'));break;case"options":case"data":break;default:console.error('PopperJS: an invalid property has been provided to the "'+t.name+'" modifier, valid properties are '+M.map((function(e){return'"'+e+'"'})).join(", ")+'; but "'+n+'" was provided.')}t.requires&&t.requires.forEach((function(n){null==e.find((function(e){return e.name===n}))&&console.error(k('Popper: modifier "%s" requires "%s", but "%s" modifier is not available',String(t.name),n,n))}))}))}))}((l=[].concat(s,f.options.modifiers),u=function(e){return e.name},d=new Set,l.filter((function(e){var t=u(e);if(!d.has(t))return d.add(t),!0})))),"auto"===T(f.options.placement))&&(f.orderedModifiers.find((function(e){return"flip"===e.name}))||console.error(['Popper: "auto" placements require the "flip" modifier be',"present and enabled to work."].join(" ")));var l,u,d,g=p(t);return[g.marginTop,g.marginRight,g.marginBottom,g.marginLeft].some((function(e){return parseFloat(e)}))&&console.warn(['Popper: CSS "margin" styles cannot be used to apply padding',"between the popper and its reference element or boundary.","To replicate margin, use the `offset` modifier, as well as","the `padding` option in the `preventOverflow` and `flip`","modifiers."].join(" ")),f.orderedModifiers.forEach((function(e){var t=e.name,n=e.options,r=void 0===n?{}:n,o=e.effect;if("function"==typeof o){var i=o({state:f,name:t,instance:m,options:r});c.push(i||function(){})}})),m.update()},forceUpdate:function(e){if(!l){e&&(f.elements.reference=e);var t=f.elements,n=t.reference,r=t.popper;if(X(n,r)){f.rects={reference:u(n,b(r),"fixed"===f.options.strategy),popper:d(r)},f.reset=!1,f.placement=f.options.placement,f.orderedModifiers.forEach((function(e){return f.modifiersData[e.name]=Object.assign({},e.data)}));for(var o=0,i=0;i<f.orderedModifiers.length;i++){if((o+=1)>100){console.error("Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.");break}if(!0!==f.reset){var a=f.orderedModifiers[i],s=a.fn,c=a.options,p=void 0===c?{}:c,h=a.name;"function"==typeof s&&(f=s({state:f,options:p,name:h,instance:m})||f)}else f.reset=!1,i=-1}}else console.error(z)}},update:(i=function(e){return new Promise((function(t){"object"==typeof e&&1===e.nodeType?m.forceUpdate(e):m.forceUpdate(),t(f)}))},function(e){return s||(s=new Promise((function(t){Promise.resolve().then((function(){s=void 0,t(i(e))}))}))),s}),destroy:function(){v(),l=!0}};if(!X(e,t))return console.error(z),m;function v(){c.forEach((function(e){return e()})),c=[]}return m.setOptions(n).then((function(e){!l&&n.onFirstUpdate&&n.onFirstUpdate(e)})),m}}var J={passive:!0};var K={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var t=e.state,r=e.instance,o=e.options,i=o.scroll,a=void 0===i||i,s=o.resize,f=void 0===s||s,c=n(t.elements.popper),p=[].concat(t.scrollParents.reference,t.scrollParents.popper);return a&&p.forEach((function(e){e.addEventListener("scroll",r.update,J)})),f&&c.addEventListener("resize",r.update,J),function(){a&&p.forEach((function(e){e.removeEventListener("scroll",r.update,J)})),f&&c.removeEventListener("resize",r.update,J)}},data:{}};var Q={name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var t=e.state,n=e.name;t.modifiersData[n]=N({reference:t.rects.reference,element:t.rects.popper,strategy:"absolute",placement:t.placement})},data:{}},Z={top:"auto",right:"auto",bottom:"auto",left:"auto"};function $(e){var t,r=e.popper,o=e.popperRect,i=e.placement,a=e.variation,s=e.offsets,c=e.position,l=e.gpuAcceleration,u=e.adaptive,d=e.roundOffsets,m=!0===d?function(e){var t=e.x,n=e.y,r=window.devicePixelRatio||1;return{x:W(W(t*r)/r)||0,y:W(W(n*r)/r)||0}}(s):"function"==typeof d?d(s):s,h=m.x,v=void 0===h?0:h,g=m.y,j=void 0===g?0:g,E=s.hasOwnProperty("x"),S=s.hasOwnProperty("y"),D=O,P=y,k=window;if(u){var L=b(r),M="clientHeight",T="clientWidth";L===n(r)&&"static"!==p(L=f(r)).position&&"absolute"===c&&(M="scrollHeight",T="scrollWidth"),L=L,i!==y&&(i!==O&&i!==x||"end"!==a)||(P=w,j-=L[M]-o.height,j*=l?1:-1),i!==O&&(i!==y&&i!==w||"end"!==a)||(D=x,v-=L[T]-o.width,v*=l?1:-1)}var q,A=Object.assign({position:c},u&&Z);return l?Object.assign({},A,((q={})[P]=S?"0":"",q[D]=E?"0":"",q.transform=(k.devicePixelRatio||1)<=1?"translate("+v+"px, "+j+"px)":"translate3d("+v+"px, "+j+"px, 0)",q)):Object.assign({},A,((t={})[P]=S?j+"px":"",t[D]=E?v+"px":"",t.transform="",t))}var ee={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var t=e.state,n=e.options,r=n.gpuAcceleration,o=void 0===r||r,i=n.adaptive,a=void 0===i||i,s=n.roundOffsets,f=void 0===s||s,c=p(t.elements.popper).transitionProperty||"";a&&["transform","top","right","bottom","left"].some((function(e){return c.indexOf(e)>=0}))&&console.warn(["Popper: Detected CSS transitions on at least one of the following",'CSS properties: "transform", "top", "right", "bottom", "left".',"\n\n",'Disable the "computeStyles" modifier\'s `adaptive` option to allow',"for smooth transitions, or remove these properties from the CSS","transition declaration on the popper element if only transitioning","opacity or background-color for example.","\n\n","We recommend using the popper element as a wrapper around an inner","element that can have any CSS property transitioned for animations."].join(" "));var l={placement:T(t.placement),variation:I(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:o};null!=t.modifiersData.popperOffsets&&(t.styles.popper=Object.assign({},t.styles.popper,$(Object.assign({},l,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:a,roundOffsets:f})))),null!=t.modifiersData.arrow&&(t.styles.arrow=Object.assign({},t.styles.arrow,$(Object.assign({},l,{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:f})))),t.attributes.popper=Object.assign({},t.attributes.popper,{"data-placement":t.placement})},data:{}};var te={name:"applyStyles",enabled:!0,phase:"write",fn:function(e){var t=e.state;Object.keys(t.elements).forEach((function(e){var n=t.styles[e]||{},r=t.attributes[e]||{},o=t.elements[e];i(o)&&s(o)&&(Object.assign(o.style,n),Object.keys(r).forEach((function(e){var t=r[e];!1===t?o.removeAttribute(e):o.setAttribute(e,!0===t?"":t)})))}))},effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,n.popper),t.styles=n,t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow),function(){Object.keys(t.elements).forEach((function(e){var r=t.elements[e],o=t.attributes[e]||{},a=Object.keys(t.styles.hasOwnProperty(e)?t.styles[e]:n[e]).reduce((function(e,t){return e[t]="",e}),{});i(r)&&s(r)&&(Object.assign(r.style,a),Object.keys(o).forEach((function(e){r.removeAttribute(e)})))}))}},requires:["computeStyles"]};var ne={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var t=e.state,n=e.options,r=e.name,o=n.offset,i=void 0===o?[0,0]:o,a=S.reduce((function(e,n){return e[n]=function(e,t,n){var r=T(e),o=[O,y].indexOf(r)>=0?-1:1,i="function"==typeof n?n(Object.assign({},t,{placement:e})):n,a=i[0],s=i[1];return a=a||0,s=(s||0)*o,[O,x].indexOf(r)>=0?{x:s,y:a}:{x:a,y:s}}(n,t.rects,i),e}),{}),s=a[t.placement],f=s.x,c=s.y;null!=t.modifiersData.popperOffsets&&(t.modifiersData.popperOffsets.x+=f,t.modifiersData.popperOffsets.y+=c),t.modifiersData[r]=a}},re={left:"right",right:"left",bottom:"top",top:"bottom"};function oe(e){return e.replace(/left|right|bottom|top/g,(function(e){return re[e]}))}var ie={start:"end",end:"start"};function ae(e){return e.replace(/start|end/g,(function(e){return ie[e]}))}function se(e,t){void 0===t&&(t={});var n=t,r=n.placement,o=n.boundary,i=n.rootBoundary,a=n.padding,s=n.flipVariations,f=n.allowedAutoPlacements,c=void 0===f?S:f,p=I(r),l=p?s?E:E.filter((function(e){return I(e)===p})):j,u=l.filter((function(e){return c.indexOf(e)>=0}));0===u.length&&(u=l,console.error(["Popper: The `allowedAutoPlacements` option did not allow any","placements. Ensure the `placement` option matches the variation","of the allowed placements.",'For example, "auto" cannot be used to allow "bottom-start".','Use "auto-start" instead.'].join(" ")));var d=u.reduce((function(t,n){return t[n]=F(e,{placement:n,boundary:o,rootBoundary:i,padding:a})[T(n)],t}),{});return Object.keys(d).sort((function(e,t){return d[e]-d[t]}))}var fe={name:"flip",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name;if(!t.modifiersData[r]._skip){for(var o=n.mainAxis,i=void 0===o||o,a=n.altAxis,s=void 0===a||a,f=n.fallbackPlacements,c=n.padding,p=n.boundary,l=n.rootBoundary,u=n.altBoundary,d=n.flipVariations,m=void 0===d||d,h=n.allowedAutoPlacements,v=t.options.placement,g=T(v),b=f||(g===v||!m?[oe(v)]:function(e){if("auto"===T(e))return[];var t=oe(e);return[ae(e),t,ae(t)]}(v)),j=[v].concat(b).reduce((function(e,n){return e.concat("auto"===T(n)?se(t,{placement:n,boundary:p,rootBoundary:l,padding:c,flipVariations:m,allowedAutoPlacements:h}):n)}),[]),E=t.rects.reference,S=t.rects.popper,D=new Map,P=!0,k=j[0],L=0;L<j.length;L++){var M=j[L],q=T(M),A="start"===I(M),W=[y,w].indexOf(q)>=0,B=W?"width":"height",H=F(t,{placement:M,boundary:p,rootBoundary:l,altBoundary:u,padding:c}),C=W?A?x:O:A?w:y;E[B]>S[B]&&(C=oe(C));var R=oe(C),V=[];if(i&&V.push(H[q]<=0),s&&V.push(H[C]<=0,H[R]<=0),V.every((function(e){return e}))){k=M,P=!1;break}D.set(M,V)}if(P)for(var N=function(e){var t=j.find((function(t){var n=D.get(t);if(n)return n.slice(0,e).every((function(e){return e}))}));if(t)return k=t,"break"},U=m?3:1;U>0;U--){if("break"===N(U))break}t.placement!==k&&(t.modifiersData[r]._skip=!0,t.placement=k,t.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function ce(e,t,n){return q(e,A(t,n))}var pe={name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name,o=n.mainAxis,i=void 0===o||o,a=n.altAxis,s=void 0!==a&&a,f=n.boundary,c=n.rootBoundary,p=n.altBoundary,l=n.padding,u=n.tether,m=void 0===u||u,h=n.tetherOffset,v=void 0===h?0:h,g=F(t,{boundary:f,rootBoundary:c,padding:l,altBoundary:p}),j=T(t.placement),E=I(t.placement),S=!E,D=V(j),P="x"===D?"y":"x",k=t.modifiersData.popperOffsets,L=t.rects.reference,M=t.rects.popper,W="function"==typeof v?v(Object.assign({},t.rects,{placement:t.placement})):v,B={x:0,y:0};if(k){if(i||s){var H="y"===D?y:O,C="y"===D?w:x,R="y"===D?"height":"width",N=k[D],U=k[D]+g[H],_=k[D]-g[C],z=m?-M[R]/2:0,G="start"===E?L[R]:M[R],X="start"===E?-M[R]:-L[R],Y=t.elements.arrow,J=m&&Y?d(Y):{width:0,height:0},K=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},Q=K[H],Z=K[C],$=ce(0,L[R],J[R]),ee=S?L[R]/2-z-$-Q-W:G-$-Q-W,te=S?-L[R]/2+z+$+Z+W:X+$+Z+W,ne=t.elements.arrow&&b(t.elements.arrow),re=ne?"y"===D?ne.clientTop||0:ne.clientLeft||0:0,oe=t.modifiersData.offset?t.modifiersData.offset[t.placement][D]:0,ie=k[D]+ee-oe-re,ae=k[D]+te-oe;if(i){var se=ce(m?A(U,ie):U,N,m?q(_,ae):_);k[D]=se,B[D]=se-N}if(s){var fe="x"===D?y:O,pe="x"===D?w:x,le=k[P],ue=le+g[fe],de=le-g[pe],me=ce(m?A(ue,ie):ue,le,m?q(de,ae):de);k[P]=me,B[P]=me-le}}t.modifiersData[r]=B}},requiresIfExists:["offset"]};var le={name:"arrow",enabled:!0,phase:"main",fn:function(e){var t,n=e.state,r=e.name,o=e.options,i=n.elements.arrow,a=n.modifiersData.popperOffsets,s=T(n.placement),f=V(s),c=[O,x].indexOf(s)>=0?"height":"width";if(i&&a){var p=function(e,t){return U("number"!=typeof(e="function"==typeof e?e(Object.assign({},t.rects,{placement:t.placement})):e)?e:_(e,j))}(o.padding,n),l=d(i),u="y"===f?y:O,m="y"===f?w:x,h=n.rects.reference[c]+n.rects.reference[f]-a[f]-n.rects.popper[c],v=a[f]-n.rects.reference[f],g=b(i),E=g?"y"===f?g.clientHeight||0:g.clientWidth||0:0,S=h/2-v/2,D=p[u],P=E-l[c]-p[m],k=null,L=n.rects.popper.width<n.rects.reference.width,M=n.rects.popper.height<n.rects.reference.height,q="top-start"==n.options.placement||"bottom-start"==n.options.placement,A="top-end"==n.options.placement||"bottom-end"==n.options.placement,W="left-start"==n.options.placement||"right-start"==n.options.placement,B="left-end"==n.options.placement||"right-end"==n.options.placement,H=ce(D,k=L&&q?n.options.fixDistance:L&&A?P-n.options.fixDistance:M&&W?n.options.fixDistance:M&&B?P-n.options.fixDistance:E/2-l[c]/2+S,P),C=f;n.modifiersData[r]=((t={})[C]=H,t.centerOffset=H-k,t)}},effect:function(e){var t=e.state,n=e.options.element,r=void 0===n?"[arrow]":n;null!=r&&("string"!=typeof r||(r=t.elements.popper.querySelector(r)))&&(i(r)||console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).',"To use an SVG arrow, wrap it in an HTMLElement that will be used as","the arrow."].join(" ")),B(t.elements.popper,r)?t.elements.arrow=r:console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper',"element."].join(" ")))},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function ue(e,t,n){return void 0===n&&(n={x:0,y:0}),{top:e.top-t.height-n.y,right:e.right-t.width+n.x,bottom:e.bottom-t.height+n.y,left:e.left-t.width-n.x}}function de(e){return[y,x,w,O].some((function(t){return e[t]>=0}))}var me={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var t=e.state,n=e.name,r=t.rects.reference,o=t.rects.popper,i=t.modifiersData.preventOverflow,a=F(t,{elementContext:"reference"}),s=F(t,{altBoundary:!0}),f=ue(a,r),c=ue(s,o,i),p=de(f),l=de(c);t.modifiersData[n]={referenceClippingOffsets:f,popperEscapeOffsets:c,isReferenceHidden:p,hasPopperEscaped:l},t.attributes.popper=Object.assign({},t.attributes.popper,{"data-reference-hidden":p,"data-escaped":l})}},he=Y({defaultModifiers:[K,Q,ee,te]}),ve=[K,Q,ee,te,ne,fe,pe,le,me],ge=Y({defaultModifiers:ve});e.applyStyles=te,e.arrow=le,e.computeStyles=ee,e.createPopper=ge,e.createPopperLite=he,e.defaultModifiers=ve,e.detectOverflow=F,e.eventListeners=K,e.flip=fe,e.hide=me,e.offset=ne,e.popperGenerator=Y,e.popperOffsets=Q,e.preventOverflow=pe,Object.defineProperty(e,"__esModule",{value:!0})}));
/*!
 * redux v4.1.2 from https://redux.js.org  |  AXUI增加了window变量，取消了isCrushed函数
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=window||e||self).Redux={})}(this,(function(e){"use strict";var t="function"==typeof Symbol&&Symbol.observable||"@@observable",r=function(){return Math.random().toString(36).substring(7).split("").join(".")},n={INIT:"@@redux/INIT"+r(),REPLACE:"@@redux/REPLACE"+r(),PROBE_UNKNOWN_ACTION:function(){return"@@redux/PROBE_UNKNOWN_ACTION"+r()}};function o(e){if("object"!=typeof e||null===e)return!1;for(var t=e;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function i(e){if(void 0===e)return"undefined";if(null===e)return"null";var t=typeof e;switch(t){case"boolean":case"string":case"number":case"symbol":case"function":return t}if(Array.isArray(e))return"array";if(function(e){return e instanceof Date||"function"==typeof e.toDateString&&"function"==typeof e.getDate&&"function"==typeof e.setDate}(e))return"date";if(function(e){return e instanceof Error||"string"==typeof e.message&&e.constructor&&"number"==typeof e.constructor.stackTraceLimit}(e))return"error";var r=function(e){return"function"==typeof e.constructor?e.constructor.name:null}(e);switch(r){case"Symbol":case"Promise":case"WeakMap":case"WeakSet":case"Map":case"Set":return r}return t.slice(8,-1).toLowerCase().replace(/\s/g,"")}function u(e){return i(e)}function a(e){"undefined"!=typeof console&&"function"==typeof console.error&&console.error(e);try{throw new Error(e)}catch(e){}}function c(e,t){return function(){return t(e.apply(this,arguments))}}function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function f(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function d(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?f(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):f(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return 0===t.length?function(e){return e}:1===t.length?t[0]:t.reduce((function(e,t){return function(){return e(t.apply(void 0,arguments))}}))}function p(){}"string"==typeof p.name&&p.name,e.__DO_NOT_USE__ActionTypes=n,e.applyMiddleware=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){return function(){var r=e.apply(void 0,arguments),n=function(){throw new Error("Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.")},o={getState:r.getState,dispatch:function(){return n.apply(void 0,arguments)}},i=t.map((function(e){return e(o)}));return n=l.apply(void 0,i)(r.dispatch),d(d({},r),{},{dispatch:n})}}},e.bindActionCreators=function(e,t){if("function"==typeof e)return c(e,t);if("object"!=typeof e||null===e)throw new Error("bindActionCreators expected an object or a function, but instead received: '"+u(e)+'\'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');var r={};for(var n in e){var o=e[n];"function"==typeof o&&(r[n]=c(o,t))}return r},e.combineReducers=function(e){for(var t=Object.keys(e),r={},i=0;i<t.length;i++){var c=t[i];void 0===e[c]&&a('No reducer provided for key "'+c+'"'),"function"==typeof e[c]&&(r[c]=e[c])}var s,f,d=Object.keys(r);s={};try{!function(e){Object.keys(e).forEach((function(t){var r=e[t];if(void 0===r(void 0,{type:n.INIT}))throw new Error('The slice reducer for key "'+t+"\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.");if(void 0===r(void 0,{type:n.PROBE_UNKNOWN_ACTION()}))throw new Error('The slice reducer for key "'+t+"\" returned undefined when probed with a random type. Don't try to handle '"+n.INIT+'\' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.')}))}(r)}catch(e){f=e}return function(e,t){if(void 0===e&&(e={}),f)throw f;var i=function(e,t,r,i){var a=Object.keys(t),c=r&&r.type===n.INIT?"preloadedState argument passed to createStore":"previous state received by the reducer";if(0===a.length)return"Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";if(!o(e))return"The "+c+' has unexpected type of "'+u(e)+'". Expected argument to be an object with the following keys: "'+a.join('", "')+'"';var s=Object.keys(e).filter((function(e){return!t.hasOwnProperty(e)&&!i[e]}));return s.forEach((function(e){i[e]=!0})),r&&r.type===n.REPLACE?void 0:s.length>0?"Unexpected "+(s.length>1?"keys":"key")+' "'+s.join('", "')+'" found in '+c+'. Expected to find one of the known reducer keys instead: "'+a.join('", "')+'". Unexpected keys will be ignored.':void 0}(e,r,t,s);i&&a(i);for(var c=!1,l={},p=0;p<d.length;p++){var h=d[p],y=r[h],b=e[h],w=y(b,t);if(void 0===w){var v=t&&t.type;throw new Error("When called with an action of type "+(v?'"'+String(v)+'"':"(unknown type)")+', the slice reducer for key "'+h+'" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.')}l[h]=w,c=c||w!==b}return(c=c||d.length!==Object.keys(e).length)?l:e}},e.compose=l,e.createStore=function e(r,i,a){var c;if("function"==typeof i&&"function"==typeof a||"function"==typeof a&&"function"==typeof arguments[3])throw new Error("It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");if("function"==typeof i&&void 0===a&&(a=i,i=void 0),void 0!==a){if("function"!=typeof a)throw new Error("Expected the enhancer to be a function. Instead, received: '"+u(a)+"'");return a(e)(r,i)}if("function"!=typeof r)throw new Error("Expected the root reducer to be a function. Instead, received: '"+u(r)+"'");var s=r,f=i,d=[],l=d,p=!1;function h(){l===d&&(l=d.slice())}function y(){if(p)throw new Error("You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");return f}function b(e){if("function"!=typeof e)throw new Error("Expected the listener to be a function. Instead, received: '"+u(e)+"'");if(p)throw new Error("You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");var t=!0;return h(),l.push(e),function(){if(t){if(p)throw new Error("You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");t=!1,h();var r=l.indexOf(e);l.splice(r,1),d=null}}}function w(e){if(!o(e))throw new Error("Actions must be plain objects. Instead, the actual type was: '"+u(e)+"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");if(void 0===e.type)throw new Error('Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');if(p)throw new Error("Reducers may not dispatch actions.");try{p=!0,f=s(f,e)}finally{p=!1}for(var t=d=l,r=0;r<t.length;r++){(0,t[r])()}return e}function v(e){if("function"!=typeof e)throw new Error("Expected the nextReducer to be a function. Instead, received: '"+u(e));s=e,w({type:n.REPLACE})}function g(){var e,r=b;return(e={subscribe:function(e){if("object"!=typeof e||null===e)throw new Error("Expected the observer to be an object. Instead, received: '"+u(e)+"'");function t(){e.next&&e.next(y())}return t(),{unsubscribe:r(t)}}})[t]=function(){return this},e}return w({type:n.INIT}),(c={dispatch:w,subscribe:b,getState:y,replaceReducer:v})[t]=g,c},Object.defineProperty(e,"__esModule",{value:!0})}));
/*!
 * 全局变量，至于ax.js头部，可全站使用
 */
'use strict';
/**
 * 定义常用错误提示 
 */
const axError = {
    formatError: 'This is not a valid data format!',
    paraError: 'The parameters do not meet the requirements!',
    arrayRequired: 'The value must be an array type!',
    noNode: 'This page can not find the node!',
    required: 'Required field is missing!',
    notExist: 'The program cannot be executed because the object does not exist!',
}
/**
 * 定义判断是否是移动端函数，返回true或false 
 */
const axIsMobi = () => {
    let userAgentInfo = navigator.userAgent;
    let mobileAgents = ["Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"];
    for (let v = 0; v < mobileAgents.length; v++) {
        if (userAgentInfo.indexOf(mobileAgents[v]) > 0) {
            return true;
        } else {
            return false;
        }
    }
}
/**
 * 定义客户端函数，通过屏幕宽度判断是什么终端
 */
const axClient = () => {
    let screenWidth = window.screen.width;
    if (screenWidth < 500) {
        return 'phone';
    } else if (screenWidth > 500 && screenWidth < 900) {
        return 'pad';
    } else if (screenWidth > 900 && screenWidth < 1200) {
        return 'padflip';
    } else if (screenWidth > 1200 && screenWidth < 1500) {
        return 'padpro';
    } else {
        return 'pc';
    }
}
/**
 * 定义判断为空函数，可判断function(){}，0，''，[]，{}，undefined，null
 */
const axIsEmpty = (data) => {
    if (typeof data == 'function') {
        return (data.toString().replace(/\s+/g, '').match(/{.*}/g)[0] == '{}');
    } else if (!data) {
        return true;
    } else if (data instanceof Array) {
        return data.join('') == '';
    } else if (typeof data == 'object') {
        return (Object.keys(data).length === 0)
    } else {
        return false;
    }
}
/**
 * 阻止默认事件
*/
const axPreventDefault = (event) => {
    if (event.preventDefault) {
        event.preventDefault();
    } else {
        event.returnValue = false;
    }
}
/**
 * 将字符串转成DOM对象，诸如<div>...</div>的字符串
 */
const axStrToDom = (str) => {
    let div = document.createElement('div');
    if (typeof str == 'string') {
        div.innerHTML = str.trim();
    }
    return div.firstElementChild;
}
/**
 * 将#id转成DOM，插件中常用
 */
const axIdToDom = (elem) => {
    if (!elem) {
        console.error('No selector or No HTML DOM!');
        return;
    } else if ((typeof elem) === 'string') {
        return document.querySelector(elem);
    } else {
        return elem;
    }
}
/**
 * 将字符串转成数组继而转成Dom，诸如"#xxx,,yyy,DIV"这类参数型的字符串
 */
const axArrToDom = (str, parent) => {
    let arr = str.split(","),
        doms = [],
        reg = /^[0-9]*$/,
        _parent = '';
    if ((typeof parent) === 'string') {
        _parent = document.querySelector(parent);
    } else {
        _parent = parent;
    }
    arr.forEach(item => {
        if (reg.test(item.substr(0, 1))) {
            return;
        } else if (item.indexOf('.') != -1) {
            if (_parent) {
                doms = doms.concat([..._parent.querySelectorAll(item)]);
            } else {
                doms = doms.concat([...document.querySelectorAll(item)]);
            }
        } else if (item.indexOf('#') != -1) {
            doms.push(document.querySelector(item));
        } else if (item) {
            let nodes = document.querySelectorAll(item);
            if (nodes) {
                if (_parent) {
                    doms = doms.concat([..._parent.querySelectorAll(item)]);
                } else {
                    doms = doms.concat([...document.querySelectorAll(item)]);
                }
            }
        } else {
            return doms;
        }
    })
    return doms;
}
/**
 * 防抖函数
 * 使用表现：持续输入后延迟执行
*/
const axDebounce = (fn, delay = 200) => {
    let timer = null,
        handle = function () {
            if (timer) clearTimeout(timer);
            let _this = this,
                _arguments = arguments;
            timer = setTimeout(function () {
                fn.apply(_this, _arguments);
            }, delay);
        }
    handle.cancel = function () {
        if (timer) clearTimeout(timer);
    }
    return handle;
}
/**
 * 节流函数
 * 使用表现：持续点击多次也只会按固定间隔时间执行
*/
const axThrottle = (fn, interval = 200) => {
    let last = 0,
        timer = null,
        handle = function () {
            let _this = this,
                _arguments = arguments,
                now = new Date().getTime();
            if (now - last > interval) {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                fn.apply(_this, _arguments);
                last = now;
            } else if (timer === null) {
                timer = setTimeout(function () {
                    timer = null;
                    fn.apply(_this, _arguments);
                }, interval);
            }
        }
    handle.cancel = function () {
        clearTimeout(timer);
        timer = null;
    }
    return handle;
}
/**
 * 数组元素移动位置
 */
const axMoveArr = (arr, from, to) => {
    if (from > arr.length || to > arr.length || from < 0 || to < 0) {
        console.error('Exceeded array length!');
        return false;
    }
    let obj = arr[from];
    arr.splice(from, 1);
    arr.splice(to, 0, obj);
    return arr;
}
/**
 * 判断元素以及其父元素是否可见
 */
const axIsVisible = (element) => {
    let elem = axIdToDom(element),
        loopable = true,
        visible = getComputedStyle(elem).display != 'none' && getComputedStyle(elem).visibility != 'hidden';
    while (loopable && visible) {
        elem = elem.parentNode;
        if (elem && elem != document.body) {
            visible = getComputedStyle(elem).display != 'none' && getComputedStyle(elem).visibility != 'hidden';
        } else {
            loopable = false;
        }
    }
    return visible;
}
/**
 * 在某div中使用滚轮，整个页面不滚动
 */
const axPreventScroll = (preventDom, scrollDom) => {
    let prevent = preventDom ? axIdToDom(preventDom) : null,
        scroll = scrollDom ? axIdToDom(scrollDom) : null;
    if (navigator.userAgent.indexOf("Firefox") > 0) {
        prevent.addEventListener('DOMMouseScroll', (e) => {
            e.preventDefault();
        }, false);
        if (!scroll) {
            if (preventDom && preventDom.scrollHeight > preventDom.clientHeight) {
                preventDom.addEventListener('DOMMouseScroll', (e) => {
                    preventDom.scrollTop += e.detail > 0 ? 60 : -60;
                }, false);
            }
        } else {
            if (scroll && scroll.scrollHeight > scroll.clientHeight) {
                scroll.addEventListener('DOMMouseScroll', (e) => {
                    scroll.scrollTop += e.detail > 0 ? 60 : -60;
                }, false);
            }
        }
    } else {
        prevent.addEventListener('mousewheel', (e) => {
            e = e || window.event;
            e.returnValue = false;
        }, false);
        if (!scroll) {
            if (preventDom && preventDom.scrollHeight > preventDom.clientHeight) {
                preventDom.addEventListener('mousewheel', (e) => {
                    preventDom.scrollTop += e.wheelDelta > 0 ? -60 : 60;
                }, false);
            }
        } else {
            if (scroll && scroll.scrollHeight > scroll.clientHeight) {
                scroll.addEventListener('mousewheel', (e) => {
                    scroll.scrollTop += e.wheelDelta > 0 ? -60 : 60;
                }, false);
            }
        }
    }
    return this;
}
/**
 * 创建带前缀的随机Id
 */
const axCreateId = (prefix, type, elem) => {
    let dom = elem ? axIdToDom(elem) : null;
    let generateChars = (length) => {
        length = length || 32;
        let chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678',
            maxLen = chars.length,
            string = '';
        for (let i = 0; i < length; i++) {
            string += chars.charAt(Math.floor(Math.random() * maxLen));
        }
        return string;
    };
    let time = new Date().getTime();
    let id = elem ? dom.id.replace(/(:|\.|\[|\]|,)/g, '') : null;
    if (type) {
        if (!isNaN(type)) {
            return prefix + "-" + generateChars(type);
        } else if (id && type == 'id') {
            return prefix + "-" + id;
        } else {
            return prefix + "-" + time;
        }
    } else {
        return prefix + "-" + time;
    }
};
/**
 * 判断对象类型
 */
const axTypeIs = (type, obj) => {
    return obj !== undefined &&
        obj !== null &&
        Object.prototype.toString.call(obj).slice(8, -1) === type;
};
/**
 * 获得对象真正的类型
 */
const axType = (obj) => Object.prototype.toString.call(obj).slice(8, -1);
const axUlToArr = (element, start = 1, hold) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element),
        newId = start;
    let getChild = () => {
        let data = [];
        axChildren(elem, 'li').forEach(item => {
            data.push(getJson(item, newId++));
        });
        return data;
    }
    let getJson = (elem, index) => {
        let value = '',
            obj = {},
            name = elem.firstElementChild.textContent.trim();
        if (elem.firstElementChild.getAttribute('value')) {
            value = elem.firstElementChild.getAttribute('value').trim();
            obj = { "id": index, "name": name, "value": value };
        } else {
            if (hold) {
                obj = { "id": index, "name": name };
            } else {
                obj = { "id": index, "value": name };
            }
        }
        if (elem.querySelector('ul')) {
            [...elem.querySelector('ul').children].forEach(item => {
                if (!obj.children) {
                    obj.children = [];
                }
                obj.children.push(getJson(item, newId++));
            });
        }
        return obj;
    }
    return getChild();
}
/**
 * 将下拉菜单Dom树转成对象数组格式：[{"value":""},{"value":""},"value":""]
 */
const axSelectToArr = (element, start = 1) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element),
        newId = start;
    let getChild = () => {
        let data = [];
        [...elem.children].forEach(item => {
            data.push(getJson(item, newId++));
        });
        return data;
    }
    let getJson = (elem, index) => {
        let value = '',
            name = '',
            obj = {};
        if (elem.nodeName == 'OPTGROUP') {
            name = elem.getAttribute('label').trim();
            value = name;
        } else {
            name = elem.textContent.trim();
            elem.getAttribute('value') ? value = elem.getAttribute('value').trim() : null;
        }
        obj = { "id": index, "name": name, "value": value };
        if (elem.querySelector('option')) {
            [...elem.children].forEach(item => {
                if (!obj.children) {
                    obj.children = [];
                }
                obj.children.push(getJson(item, newId++));
            });
        }
        return obj;
    }
    return getChild();
}
/**
 * 从datalist中获取对象数组格式：[{"value":""},{"value":""}]
 */
const axListToArr = (element, start = 1) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element),
        newId = start;
    let getChild = () => {
        let data = [];
        [...elem.children].forEach(item => {
            data.push(getJson(item, newId++));
        });
        return data;
    }
    let getJson = (elem, index) => {
        let value = '',
            name = '',
            obj = {};
        name = elem.textContent.trim();
        value = elem.getAttribute('value') ?  elem.getAttribute('value').trim() : name;
        obj = { "id": index, "name": name, "value": value };
        if (!axIsEmpty(elem.dataset)) {
            Object.assign(obj, elem.dataset)
        }
        return obj;
    }
    return getChild();
}
/**
 * 一维数组转tree数组，root为顶级id，通常是0
 */
const axArrToTree = (arr, start) => {
    let root = start ? start : 0;
    arr.forEach(item => {
        let children = arr.filter(v => item.id === v.pId);
        if(children.length){
            item.children = children;
        }
    });
    arr = arr.filter(i => i.pId == root);
    return arr;
}
/**
 * 判断是否在元素矩形区域之外
 */
const axIsOutside = (ev, id, ox, oy) => {
    if (!id) { return true }
    let elem = axIdToDom(id);
    if (!elem) { return true }
    let x = ev.clientX,
        y = ev.clientY,
        x1, y1, x2, y2;
    ox ? x1 = ox : x1 = elem.getBoundingClientRect().left;
    oy ? y1 = oy : y1 = elem.getBoundingClientRect().top;
    x2 = x1 + elem.offsetWidth;
    y2 = y1 + elem.offsetHeight;
    return (x < x1 || x > x2 || y < y1 || y > y2) ? true : false;
}
/**
 * 封装getComputedStyle方法
 */
const axStyle = (elem, pseudo) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    return document.defaultView.getComputedStyle(element, pseudo);
}
/**
 * 筛选某实例数组中id=value的实例
 */
const axInstance = (json, value) => {
    if (axIsEmpty(json)) {
        console.error('Instance is destroyed!');
    }
    return json.filter((obj) => {
        return obj.name == value;
    })[0].instance;
}
/**
 * 定义模板引擎
 */
const axTplEngine = (html, data) => {
    if (!html) { console.error('No html!'); return false; }
    let re = /<#([^#>]+)?#>/g,
        reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g,
        code = 'let r=[];\n',
        cursor = 0;
    let match;
    let add = (line, js) => {
        js ? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') :
            (code += line != '' ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : '');
        return add;
    }
    while (match = re.exec(html)) {
        add(html.slice(cursor, match.index))(match[1], true);
        cursor = match.index + match[0].length;
    }
    add(html.substr(cursor, html.length - cursor));
    code += 'return r.join("");';
    return new Function(code.replace(/[\r\t\n]/g, '')).apply(data);
}
/**
 * 定义深度拷贝函数
 */
const axClone = (obj) => {
    if (obj === null) {
        return null
    } else if (typeof obj !== 'object') {
        return obj;
    } else if (obj.constructor === Date) {
        return new Date(obj);
    } else {
        let newObj = {}
        for (let k in obj) {
            if (obj[k] == null) {
                newObj[k] = null;
            } else if ((typeof obj[k]) == 'object' && !obj[k].nodeType) {
                newObj[k] = axClone(obj[k])
                if (obj[k] instanceof Array) {
                    let newArray = []
                    for (let i of obj[k]) {
                        newArray.push(axClone(i))
                    }
                    newObj[k] = newArray
                }
            } else {
                newObj[k] = obj[k]
            }
        }
        return newObj
    }
};
/**
 * 定义合并属性递归函数
 */
const axMerge = (target, source, option = { arrAppend: false, clone: false, attrAppend: false }) => {
    if (typeof target != 'object' || typeof source != 'object') {
        return source;
    }
    if (!source) {
        return target;
    }
    let obj = option.copy ? axClone(target) : target;
    for (let k in source) {
        if (source.hasOwnProperty(k) && obj.hasOwnProperty(k)) {
            if (axType(source[k]) != 'Array') {
                obj[k] = axMerge(obj[k], source[k], option);
            } else {
                if (option.arrAppend) {
                    obj[k].push(...source[k]);
                } else {
                    obj[k] = source[k];
                }
            }
        } else if (source.hasOwnProperty(k) && !obj.hasOwnProperty(k) && option.attrAppend) {
            obj[k] = source[k];
        }
    }
    return obj;
}
/**
 * 字符串转成数组，'[]'，'{"":""},{"":""}'，'a,b,c'均转成数组
 */
const axStrToArr = (string, dftAttr, dftValue) => {
    let array = [],
        dft = {};
    if (!axIsEmpty(dftAttr)) {
        dftAttr.forEach((item, index) => {
            dft[item] = !axIsEmpty(dftValue) ? dftValue[index] : '';
        })
    }
    if (string.substr(0, 1) == '[' && string.substr(-1) == ']') {
        array = JSON.parse(string);
    } else if (string.replace(/\s*/g, "").indexOf('},{') != -1) {
        array = JSON.parse('[' + string + ']');
    } else if (string.replace(/\s*/g, "").substr(0, 1) == '{' && string.replace(/\s*/g, "").substr(-1) == '}') {
        array = JSON.parse('[' + string + ']');
    } else {
        array = string.split(',');
        array.forEach((item, index) => {
            if (typeof item == 'string' && !axIsEmpty(dftAttr)) {
                let obj = {};
                dftAttr.forEach((str, i) => {
                    if (i == 0) {
                        obj[str] = item;
                    } else {
                        obj[str] = '';
                    }
                });
                array.splice(index, 1, obj)
            }
        })
    }
    array.forEach(item => {
        if (!axIsEmpty(dft)) {
            for (let k in dft) {
                if (!item.hasOwnProperty(k)) {
                    item[k] = dft[k] ? dft[k] : '';
                } else if (item.hasOwnProperty(k) && !item[k]) {
                    item[k] = dft[k];
                }
            }
        }
    })
    return array;
}
/**
 * HTML模板转成数组，支持列表循环
 */
const axTplToArr = (template, roles, keys, itemNode, dft) => {
    let tplDom = axIdToDom(template),
        data = [];
    if (itemNode) {
        let items = tplDom.querySelectorAll(itemNode);
        items.forEach(item => {
            let obj = {};
            roles.forEach((i, index) => {
                let child = item.querySelector('[' + i + ']');
                if (child) {
                    obj[keys[index]] = child.getAttribute(i) ? child.getAttribute(i).trim() : child.innerHTML.trim();
                } else {
                    obj[keys[index]] = dft[index] || '';
                }
            })
            data.push(obj);
        })
    } else {
        let obj = {};
        roles.forEach((i, index) => {
            let child = tplDom.querySelector('[' + i + ']');
            if (child) {
                obj[keys[index]] = child.getAttribute(i) ? child.getAttribute(i).trim() : child.innerHTML.trim();
            } else {
                obj[keys[index]] = dft[index] || '';
            }
        })
        data.push(obj);
    }
    return data;
}
/**
 * 将元素data-*属性与对象合并为新对象；
 * 1、先将对象obj复制保存为copy；
 * 2、将复制的对象name全转成小写；
 * 3、将data-*属性存为三层结构的对象，name均为小写并与copy合并；
 * 4、将合并后的copy与原obj对照还原大写name，并最终输出合并后的obj
 */
const axDataset = (element, obj) => {
    let elem = element ? axIdToDom(element) : null;
    let integer = /^\d+(\.\d+)?$/; 
    let float = /^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; 
    if (elem) {
        let attrs = [...elem.attributes].filter((child) => {
            return child.name.indexOf('data-') == 0;
        });
        if (!axIsEmpty(attrs)) {
            let lowerDft = axClone(obj);
            let loopLow = (arg) => {
                for (let k in arg) {
                    let lower = k.toLowerCase();
                    arg[lower] = arg[k];
                    if (axTypeIs('Object', arg[k])) {
                        loopLow(arg[k]);
                    }
                    if (lower != k) {
                        delete arg[k];
                    }
                }
            }
            loopLow(lowerDft);
            for (let k = 0; k < attrs.length; k++) {
                let value = attrs[k].value.trim(),
                    name = attrs[k].name;
                if (value == 'true') {
                    value = JSON.parse('true');
                } else if (value == 'false') {
                    value = JSON.parse('false');
                } else if (value == 'null') {
                    value = null;
                } else if (value.substr(0, 1) == '[' && value.substr(-1) == ']') {
                    value = JSON.parse(value);
                } else if (value.replace(/\s*/g, "").indexOf('},{') != -1) {
                    value = JSON.parse('[' + value + ']');
                } 
                if (typeof value == 'string' && ( integer.test(value) || float.test(value))) {
                    value = Number(value);
                }
                let split = name.split('-');
                if (split.length - 1 == 1) {
                    lowerDft[split[1]] = value
                } else if (split.length - 1 == 2) {
                    lowerDft[split[1]][split[2]] = value
                } else if (split.length - 1 == 3) {
                    lowerDft[split[1]][split[2]][split[3]] = value
                } else {
                    console.error('Three levels are supported!');
                }
            }
            let loopBack = (arg, opt) => {
                for (let k in arg) {
                    let lower = k.toLowerCase();
                    if (axTypeIs('Object', arg[k])) {
                        loopBack(arg[k], opt[lower]);
                    } else {
                        arg[k] = opt[lower];
                    }
                }
            }
            loopBack(obj, lowerDft);
        }
    }
    return obj;
}
/* let obj = {
    name: 'Mick',
    sex: 'male',
    school: {
        no: 'NO.5665',
        city: 'shenzhen',
        tel: '13800138000',
        zip: '518000'
    },
    teachers: {
        mathematics: {
            name: 'Lily',
            age: 29,
            sex: 'female',
        },
        physics: {
            name: 'Bob',
            age: 33,
            sex: 'male',
        },
    },
    callback: () => { },
} */
/**
 * 定义对象扩展
 * user属性可覆盖dft属性，并自动合并为新的dft 
 * DOM的data-*属性级别最高，使用短横“-”区分属性层级，最多允许使用三个短横
 * 举例说明： <button data-name="" data-school="" data-teachers-mathematics-name=""></button>
 */
const axExtend = (dft, user, element) => {
    if (!dft) { console.error(axError.notExist); return false; }
    let elem = element ? axIdToDom(element) : null;
    axMerge(dft, user);
    axDataset(elem, dft);
    return dft;
}
/**
 * 定义监听事件函数(观察者模式)
 */
const axAddPlan = (type, handler, instance) => {
    if (!(type in instance.handlers)) {
        instance.handlers[type] = [];
    }
    let strHandle = handler.toString().replace(/\s/g, '').replace(/\;/g, '').match(/{(\S*)}/)[1],
        strHandles = instance.handlers[type].toString().replace(/\s/g, '').replace(/\;/g, '');
    strHandles.indexOf(strHandle) > -1 ? null : instance.handlers[type].push(handler);
}
const axExePlan = (type, instance, ...params) => {
    if (!(type in instance.handlers)) {
        return console.error('The event is not registered!');
    }
    instance.handlers[type].forEach(handler => {
        handler.call(instance, ...params);
    });
}
const axDelPlan = (type, handler, instance) => {
    if (!(type in instance.handlers)) {
        return console.error('Invalid event!');
    }
    if (!handler) {
        delete instance.handlers[type];
    } else {
        let index = instance.handlers[type].findIndex(elem => elem === handler)
        if (index === undefined) {
            return console.error('This event is not bound!');
        }
        instance.handlers[type].splice(index, 1);
        if (instance.handlers[type].length === 0) {
            delete instance.handlers[type];
        }
    }
}
/**
 * 新增一个节点元素
 */
const axAddElem = (node, options, content) => {
    node.toLowerCase();
    let _node = document.createElement(node);
    if (options) {
        for (k in options) {
            _node.setAttribute(k, options[k])
        }
    }
    if (content) {
        _node.innerHTML = content;
    }
    return _node;
}
/**
 * 给子元素新增父层元素，将其包裹住
 */
const axAddWrap = (elem, wrap, node, options, content) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem),
        wrapper = '';
    if (wrap) {
        wrapper = axIdToDom(wrap);
    } else if (!wrapper && node) {
        wrapper = axAddElem(node, options, content);
    }
    if (element.nextSibling) {
        if (element.parentNode !== wrapper) {
            element.parentNode.insertBefore(wrapper, element.nextSibling);
        }
    } else {
        if (element.parentNode !== wrapper) {
            element.parentNode.appendChild(wrapper);
        }
    }
    return wrapper.appendChild(element);
};
/**
 * 替换字符串某位置的字符
 */
const axRangeReplace = (originText, replaceText, indexStart, indexStop, n) => {
    if (typeof originText !== 'string') {
        originText = JSON.stringify(originText);
    }
    if (typeof replaceText !== 'string') {
        originText = JSON.stringify(replaceText);
    }
    let result = '';
    if (!indexStart && !indexStop) {
        result = replaceText;
    } else if (!indexStop) {
        if (n) {
            result = originText.substring(0, indexStart) + replaceText + originText.substring(indexStart + n);
        } else {
            result = originText.substring(0, indexStart) + replaceText;
        }
    } else if (!indexStart) {
        if (n) {
            result = originText.substring(indexStop - n) + replaceText + originText.substring(0, indexStart);
        } else {
            result = replaceText + originText.substring(indexStop);
        }
    } else {
        result = originText.substring(0, indexStart) + replaceText + originText.substring(indexStop);
    }
    return result;
}
const axArrange = (origin, n, index = 0, splice = [], result = []) => {
    let arrayLen = origin.length
    if (index + n > arrayLen) {
        return;
    }
    for (let i = index; i < arrayLen; i++) {
        if (n === 1) {
            result.push([...splice, origin[i]])
            i + 1 < arrayLen && axArrange(origin, n, i + 1, splice, result)
            break;
        }
        axArrange(origin, n - 1, i + 1, [...splice, origin[i]], result)
    }
    return result;
}
const axCleanString = value => {
    if (typeof value !== 'string') {
        return value;
    }
    return value.replace(/&/g, '&amp;').replace(/>/g, '&rt;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
};
/**
 * 获取隐藏元素的高度、宽度、左边距和上边距
 */
const axHideSize = (parent, attrName, child) => {
    let _parent = axIdToDom(parent),
        _child = child ? axIdToDom(child) : null,
        attr = {};
    if (!_child) {
        let display = window.getComputedStyle(_parent).display,
            style = _parent.style.cssText;
        if (display == 'none') {
            _parent.style.cssText = `display:block;visibility:hidden;position:fixed`;
        }
        attr = {
            height: _parent.offsetHeight,
            width: _parent.offsetWidth,
            offsetLeft: _parent.offsetLeft,
            offsetTop: _parent.offsetTop
        }
        if (style) {
            _parent.style.cssText = style
        } else {
            _parent.removeAttribute('style');
        };
    } else {
        let arrStyle = [];
        axParents2(child, parent, true, true).forEach(item => {
            let display = window.getComputedStyle(item).display,
                style = item.style.cssText;
            if (display == 'none') {
                item.style.cssText = `display:block;visibility:hidden;position:fixed`;
            }
            arrStyle.push(style)
        });
        attr = {
            height: _child.offsetHeight,
            width: _child.offsetWidth,
            offsetLeft: _child.offsetLeft,
            offsetTop: _child.offsetTop
        }
        axParents2(child, parent, true, true).forEach((item, index) => {
            if (arrStyle[index]) {
                item.style.cssText = arrStyle[index]
            } else {
                item.removeAttribute('style');
            };
        });
    }
    return attr[attrName]
}
/**
 * 定义AJAX函数
 */
const axAjax = (option, elem) => {
    if (!option) { console.error('No options!'); return false; }
    let label = axAddElem('SPAN', { 'aria-label': 'loading' }),
        dom = elem ? axIdToDom(elem) : null;
    dom ? dom.appendChild(label) : null;
    let dft = {
        url: '',
        selector: '',
        type: 'post',
        async: true,
        before: (loading) => { dom ? (label.innerHTML = loading, dom.setAttribute('aria-ajax', 'before')) : null },
        success: (data, state) => { dom ? dom.innerHTML = data && dom.setAttribute('aria-ajax', 'success') : null },
        error: (data, state) => { dom ? (label.innerHTML = `<i class="ax-alert ax-danger">发生了一个错误！：${state}</i>`, dom.setAttribute('aria-ajax', 'error')) : console.error(`发生了一个错误！：${state}`) },
        data: {},
        delay: 60000,
        timeout: () => { dom ? (label.innerHTML = '<i class="ax-alert ax-danger">请求超时了！</i>', dom.setAttribute('aria-ajax', 'timeout')) : console.error('请求超时了！') },
        loading: '<span class="ax-loading"><i></i></span>'
    };
    for (k in option) {
        dft[k] = option[k];
    }
    let params = '';
    for (k in dft.data) {
        params += '&' + k + '=' + dft.data[k];
    }
    let xhr = '';
    if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
    }
    else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
    }
    let timeout = setTimeout(function () {
        xhr.abort();
        dft.timeout.call(this);
    }, dft.delay);
    xhr.onreadystatechange = function () {
        if (xhr.readyState < 4) {
            dft.before.call(this, dft.loading, xhr.readyState, dom);
            timeout;
        } else {
            clearTimeout(timeout);
            if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                let div = document.createElement('div'),
                    content = '',
                    reg = /(<head\b[^<]*(?:(?!<\/head>)<[^<]*)*<\/head>)|(<\/?html.*?>)|(<\/?body.*?>)/gi;
                div.innerHTML = xhr.responseText;
                if (dft.selector && div.querySelector(dft.selector)) {
                    content = div.querySelector(dft.selector).innerHTML;
                } else if (dft.selector && !div.querySelector(dft.selector)) {
                    console.error(`The node of "${dft.selector}" is not exist!`);
                    content = xhr.responseText.replace(reg,'').trim();
                } else {
                    if (xhr.responseText.trim().substr(0, 1) == "{" || xhr.responseText.trim().substr(0, 1) == "[") {
                        content = JSON.parse(xhr.responseText.trim());
                    } else {
                        content = xhr.responseText.replace(reg,'').trim();
                    }
                }
                dft.success.call(this, content, xhr.readyState, dom);
            }
            else {
                dft.error.call(this, xhr.responseText, xhr.readyState, dom);
            }
        };
    };
    let url = dft.url + '?now=' + new Date().getTime();
    if (dft.type.toLowerCase() == 'get') {
        url += params;
        xhr.open('get', url + '?' + params, true);
        xhr.send();
    }
    else if (dft.type.toLowerCase() == 'post') {
        xhr.open('post', url, true);
        xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        xhr.send(params);
    }
}
/**
 * ajax提交表单封装
 * url是异步提交地址，必填项
 * outer是form表单节点，必填项
 * target是点击的按钮，选填项
 * loadingMode是缓冲加载显示位置，button是指在按钮上转圈（要求填写target），parent是指在form表单上转圈，选填项
 * type是指异步表单提交方式，默认post，可选择get，选填项
 * delay是指显示提交成功结果延迟多久，为了直观看到校验过程可以将该值设置长一点，单位毫秒
 * beforeFun是成功返回前的回调函数，选填项
 * successFun是成功返回后的回调函数，选填项
 */
const axAjaxSubmit = (url, outer, target, successFun, loadingMode, type = 'post', delay, beforeFun, errorFun, options = {}) => {
    if (!url) { console.error('Url is required!'); return false; }
    if (!outer) { console.error('Form node is required!'); return false; }
    let parentDom = axIdToDom(outer),
        targetDom = target ? axIdToDom(target) : null,
        targetText = targetDom ? targetDom.innerHTML : '',
        mode = loadingMode || 'button',
        opt = Object.assign(options, {
            formClass: 'ax-form-submitting',
            buttonClass: 'ax-button-submitting',
            buttonText: '正在提交',
            overlayClass: 'ax-form-overlay',
            overlayShowClass: 'ax-show',
            successText: '恭喜！提交成功！',
            errorText: '对不起，提交失败！',
        }),
        overlayDom = parentDom.querySelector('.ax-form-overlay') ? parentDom.querySelector('.ax-form-overlay') : axAddElem('div', { class: 'ax-form-overlay' });
    if (parentDom.classList.contains(opt.formClass)) {
        return false;
    }
    if (targetDom && targetDom.classList.contains(opt.buttonClass)) {
        return false;
    }
    let formData = {};
    parentDom.querySelectorAll('[name]').forEach(function (item) {
        formData[item.getAttribute('name')] = item.value.trim();
    });
    axAjax({
        url: url,
        data: formData,
        type: type || 'post',
        before: function (loading) {
            parentDom.classList.add(opt.formClass);
            targetDom ? targetDom.classList.add(opt.buttonClass) : null;
            if (mode == 'button' && targetDom) {
                targetDom.innerHTML = opt.buttonText;
                targetDom.insertAdjacentHTML('afterbegin', '<i class="ax-btn-loading"></i>');
            } else {
                overlayDom.innerHTML = loading;
                overlayDom.classList.add(opt.overlayClass);
                if (!parentDom.querySelector('.ax-form-overlay')) {
                    parentDom.appendChild(overlayDom);
                }
            }
            beforeFun && beforeFun(loading);
        },
        success: function (content) {
            setTimeout(() => {
                parentDom.classList.remove(opt.formClass);
                targetDom ? targetDom.classList.remove(opt.buttonClass) : null;
                if (mode == 'button' && targetDom) {
                    targetDom.innerHTML = targetText;
                } else {
                    overlayDom.classList.remove(opt.overlayClass);
                }
                new axMessage({
                    content: opt.successText,
                    result: 'success',
                    iconShow: true,
                });
                successFun && successFun(content);
            }, delay === 0 ? 0 : delay || 1000);
        },
        error: function () {
            if (mode == 'button' && targetDom) {
                targetDom.innerHTML = targetText;
            } else {
                overlayDom.classList.remove(opt.overlayClass);
            }
            new axMessage({
                content: opt.errorText,
                result: 'error',
                iconShow: true,
            });
            errorFun && errorFun(data);
        }
    })
}
/**
 * 获取距离body的上偏移和左偏移
 */
const axOffset = (elem) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let totalLeft,
        totalTop,
        targetDom = axIdToDom(elem);
    totalLeft = targetDom.getBoundingClientRect().left + document.documentElement.scrollLeft;
    totalTop = targetDom.getBoundingClientRect().top + document.documentElement.scrollTop;
    return {
        left: totalLeft,
        top: totalTop
    }
}
/**
 * 获得元素真实宽度，宽度构成包括：margin、padding、borderWidth、width
 */
const axWidth = (elem, type) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let { width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeftWidth, borderRightWidth } = getComputedStyle(_elem);
    width = parseInt(width, 10);
    paddingLeft = parseInt(paddingLeft, 10);
    paddingRight = parseInt(paddingRight, 10);
    marginLeft = parseInt(marginLeft, 10);
    marginRight = parseInt(marginRight, 10);
    borderLeft = parseInt(borderLeftWidth, 10);
    borderRight = parseInt(borderRightWidth, 10);
    if (type == 'inner') {
        return width + paddingLeft + paddingRight;
    } else if (type == 'outer') {
        return width + paddingLeft + paddingRight + marginLeft + marginRight + borderLeft + borderRight;
    } else {
        return width;
    }
}
/**
 * 获得元素真实高度，宽度构成包括：margin、padding、borderWidth、height
 */
const axHeight = (elem, type) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let { height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth } = getComputedStyle(_elem);
    height = parseInt(height, 10);
    paddingTop = parseInt(paddingTop, 10);
    paddingBottom = parseInt(paddingBottom, 10);
    marginTop = parseInt(marginTop, 10);
    marginBottom = parseInt(marginBottom, 10);
    borderTop = parseInt(borderTopWidth, 10);
    borderBottom = parseInt(borderBottomWidth, 10);
    if (type == 'inner') {
        return height + paddingTop + paddingBottom;
    } else if (type == 'outer') {
        return height + paddingTop + paddingBottom + marginTop + marginBottom + borderTop + borderBottom;
    } else {
        return height;
    }
}
/**
 * 获得元素高度构成部分，包括：height, paddingTop, paddingBottom, marginTop, marginBottom, borderTop, borderBottom
 */
const axArrHeight = (elem) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let { height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth } = getComputedStyle(_elem);
    height = parseInt(height, 10);
    paddingTop = parseInt(paddingTop, 10);
    paddingBottom = parseInt(paddingBottom, 10);
    marginTop = parseInt(marginTop, 10);
    marginBottom = parseInt(marginBottom, 10);
    borderTop = parseInt(borderTopWidth, 10);
    borderBottom = parseInt(borderBottomWidth, 10);
    return { height, paddingTop, paddingBottom, marginTop, marginBottom, borderTop, borderBottom };
};
/**
 * 获得元素宽度构成部分，包括：width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeft, borderRight
 */
/* const axArrWidth = (elem) => {
    let { width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeftWidth, borderRightWidth } = getComputedStyle(elem);
    width = parseInt(width, 10);
    paddingLeft = parseInt(paddingLeft, 10);
    paddingRight = parseInt(paddingRight, 10);
    marginLeft = parseInt(marginLeft, 10);
    marginRight = parseInt(marginRight, 10);
    borderLeft = parseInt(borderLeftWidth, 10);
    borderRight = parseInt(borderRightWidth, 10);
    return { width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeft, borderRight };
}; */
/**
 *  判断是否选择了已知元素 ,返回 ture 或 false
 */
const axSelector = (elem, selector) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let result = true;
    if (selector) {
        selector = String(selector).replace(/\s+/g, '');
        selector = String(selector).split(',');
        for (let i = 0; i < selector.length; i++) {
            if (!selector[i]) {
                result = true;
                break;
            } else if (selector[i].indexOf('.') != -1) {
                let string = selector[i].replace('.', '');
                if (_elem.classList.contains(string)) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else if (selector[i].indexOf('#') != -1) {
                let string = selector[i].replace('#', '');
                if (_elem.getAttribute('id') == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else {
                let string = selector[i].toUpperCase();
                if (_elem.nodeName == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            }
        }
    } else {
        result = true;
    }
    return result;
}
/**
 * 判断是否排除了已知元素 ,返回 ture 或 false
 */
const axNot = (elem, selector) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let result = true;
    if (selector) {
        selector = String(selector).replace(/\s+/g, '');
        selector = String(selector).split(',');
        for (let i = 0; i < selector.length; i++) {
            if (selector[i].indexOf('.') != -1) {
                let string = selector[i].replace('.', '');
                if (_elem.classList.contains(string)) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            }
            else if (selector[i].indexOf('#') != -1) {
                let string = selector[i].replace('#', '');
                if (_elem.getAttribute('id') == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else if (selector) {
                let string = selector[i].toUpperCase();
                if (_elem.nodeName == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else {
                result = false;
            }
        }
    } else {
        result = false;
    }
    return result;
}
/**
 * 选择兄弟元素
 * element：选择的Dom
 * self：是否包含自己，默认false
 * selector：从指定的选择器中选择兄弟元素
 * ignore：不选择的兄弟元素
 * 举例：axSiblings(elem,'#my','.disabled')
 */
const axSiblings = (element, self, selector, ignore) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    return [...elem.parentNode.children].filter((child) => {
        if (!self) {
            return child !== elem && axSelector(child, selector) && !axNot(child, ignore);
        } else {
            return axSelector(child, selector) && !axNot(child, ignore);
        }
    });
}
/**
 * 选择子元素
 * element：选择的Dom
 * selector：从指定的选择器中选择兄弟元素
 * ignore：不选择的兄弟元素
 * 举例：axChildren(elem,'.item','.disabled')
 */
const axChildren = (element, selector, ignore) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    return [...elem.children].filter((child) => {
        return axSelector(child, selector) && !axNot(child, ignore);
    });
}
/**
 * 定义取得嫡系父层函数。
 * start：根节点
 * end：终节点
 * containStart：是否包含根节点
 * containEnd：是否包含终节点
 * parents：父节点数组
 */
const axParents = (start, end, containStart, containEnd, parents = []) => {
    if (!start) { console.error('No node to start!'); return false; }
    let _start = axIdToDom(start),
        _end = end ? axIdToDom(end) : null;
    if (_start.parentElement.nodeName !== 'BODY') {
        (containStart && parents.indexOf(_start) < 0) ? parents.push(_start) : null;
        if (_end) {
            (containEnd && parents.indexOf(_end) < 0) ? parents.push(_end) : null;
            if (_start.parentElement !== _end) {
                parents.push(_start.parentElement);
                return axParents(_start.parentElement, _end, containStart, containEnd, parents)
            } else {
                return parents;
            }
        } else {
            parents.push(_start.parentElement);
            return axParents(_start.parentElement, _end, containStart, containEnd, parents)
        }
    } else {
        return parents;
    }
}
/**
 * 定义动画曲线
 * 举例：axCurves.easeOutIn(0.3)
 */
const axCurves = {
    linear(t) { return t; },
    easeIn(t) { return t * t * t; },
    easeOut(t) { return (t - 1) * (t - 1) * (t - 1) + 1; },
    easeInOut(t) { return t < 0.5 ? 2 * t * t : -2(t - 1) * (t - 1) + 1; },
    easeOutIn(t) { return t < 0.5 ? Math.sqrt(0.5 * t) : -Math.sqrt(0.5 * (-t + 1)) + 1; }
};
/**
 * 定义axSlideDown动画
 * 举例：axSlideDown(elem,200,'easeOut')
 */
const axSlideDown = (elem, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    let dftTime = height => height / 3 + 250;
    if (window.getComputedStyle(element).display === "none") {
        element.setAttribute('style', 'display: block;');
        const { height, paddingTop, paddingBottom, marginTop, marginBottom } = axArrHeight(element);
        let time;
        if (duration !== undefined && typeof duration === 'number') {
            time = duration;
        } else {
            time = dftTime(height);
        }
        element.setAttribute('style', 'display: block; padding-top: 0; padding-bottom: 0;margin-top: 0; margin-bottom: 0;');
        const initTime = new Date().getTime();
        const repeat = () => {
            const newTime = new Date().getTime() - initTime;
            const timestep = newTime / time;
            const timefactor = axCurves[curve](timestep);
            const step = 0 + height * timefactor;
            const stepPaddingT = 0 + (paddingTop * timefactor);
            const stepPaddingB = 0 + (paddingBottom * timefactor);
            const stepMarginT = 0 + (marginTop * timefactor);
            const stepMarginB = 0 + (marginBottom * timefactor);
            if (newTime <= time && Math.ceil(step) < height) {
                element.setAttribute('style', `overflow:hidden;display: block; padding-top: ${stepPaddingT}px; padding-bottom: ${stepPaddingB}px;margin-top: ${stepMarginT}px; margin-bottom: ${stepMarginB}px; height: ${step}px`);
            } else {
                element.setAttribute('style', 'display: block');
            }
            const repeatLoop = requestAnimationFrame(repeat);
            if (Math.ceil(step) >= height || !height) {
                cancelAnimationFrame(repeatLoop);
                callback && callback();
            }
        };
        repeat();
    }
    return element;
};
/**
 * 不判断元素是否隐藏的下拉展开动画
 */
const axHeightDown = (elem, arrHeight, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    let dftTime = height => height / 3 + 250;
    const height = (arrHeight && arrHeight.height) ? arrHeight.height : axArrHeight(element).height,
        paddingTop = (arrHeight && arrHeight.paddingTop) ? arrHeight.paddingTop : axArrHeight(element).paddingTop,
        paddingBottom = (arrHeight && arrHeight.paddingBottom) ? arrHeight.paddingBottom : axArrHeight(element).paddingBottom,
        marginTop = (arrHeight && arrHeight.marginTop) ? arrHeight.marginTop : axArrHeight(element).marginTop,
        marginBottom = (arrHeight && arrHeight.marginBottom) ? arrHeight.marginBottom : axArrHeight(element).marginBottom;
    let time;
    if (duration !== undefined && typeof duration === 'number') {
        time = duration;
    } else {
        time = dftTime(height);
    }
    element.style.overflow = 'hidden';
    element.style.height = 0;
    paddingTop ? element.style.paddingTop = 0 : null;
    paddingBottom ? element.style.paddingBottom = 0 : null;
    marginTop ? element.style.marginTop = 0 : null;
    marginBottom ? element.style.marginBottom = 0 : null;
    const initTime = new Date().getTime();
    const repeat = () => {
        const newTime = new Date().getTime() - initTime;
        const timestep = newTime / time;
        const timefactor = axCurves[curve](timestep);
        const step = 0 + height * timefactor;
        const stepPaddingT = 0 + (paddingTop * timefactor);
        const stepPaddingB = 0 + (paddingBottom * timefactor);
        const stepMarginT = 0 + (marginTop * timefactor);
        const stepMarginB = 0 + (marginBottom * timefactor);
        if (newTime <= time && Math.ceil(step) < height) {
            element.style.height = step + 'px';
            paddingTop ? element.style.paddingTop = stepPaddingT + 'px' : null;
            paddingBottom ? element.style.paddingBottom = stepPaddingB + 'px' : null;
            marginTop ? element.style.marginTop = stepMarginT + 'px' : null;
            marginBottom ? element.style.marginBottom = stepMarginB + 'px' : null;
        } else {
            element.style.height = height + 'px';
            paddingTop ? element.style.paddingTop = paddingTop + 'px' : null;
            paddingBottom ? element.style.paddingBottom = paddingBottom + 'px' : null;
            marginTop ? element.style.marginTop = marginTop + 'px' : null;
            marginBottom ? element.style.marginBottom = marginBottom + 'px' : null;
        }
        const repeatLoop = requestAnimationFrame(repeat);
        if (Math.ceil(step) >= height || !height) {
            cancelAnimationFrame(repeatLoop);
            callback && callback();
        }
    };
    repeat();
    return element;
};
/**
 * 定义axSlideUp动画
 * 举例：axSlideUp(elem,200,'easeOut')
 */
const axSlideUp = (elem, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    let dftTime = height => height / 3 + 250;
    if (window.getComputedStyle(element).display !== "none") {
        const { height, paddingTop, paddingBottom, marginTop, marginBottom } = axArrHeight(element);
        let time;
        if (duration !== undefined && typeof duration === 'number') {
            time = duration;
        } else {
            time = dftTime(height);
        }
        element.setAttribute('style', 'display: block; padding-top: 0; padding-bottom: 0;margin-top: 0; margin-bottom: 0;');
        const initTime = new Date().getTime();
        const repeat = () => {
            const newTime = new Date().getTime() - initTime;
            const timestep = newTime / time;
            const timefactor = axCurves[curve](timestep);
            const step = height + -height * timefactor;
            const stepPaddingT = paddingTop + (-paddingTop * timefactor);
            const stepPaddingB = paddingBottom + (-paddingBottom * timefactor);
            const stepMarginT = marginTop + (-marginTop * timefactor);
            const stepMarginB = marginBottom + (-marginBottom * timefactor);
            if (newTime <= time && Math.floor(step) > 0) {
                element.setAttribute('style', `overflow:hidden;display: block; padding-top: ${stepPaddingT}px; padding-bottom: ${stepPaddingB}px;margin-top: ${stepMarginT}px; margin-bottom: ${stepMarginB}px; height: ${step}px`);
            } else {
                element.setAttribute('style', 'display: none');
            }
            const repeatLoop = requestAnimationFrame(repeat);
            if (Math.floor(step) <= 0 || !height) {
                cancelAnimationFrame(repeatLoop);
                callback && callback();
            }
        };
        repeat();
    }
    return element;
};
/**
 * 不判断元素是否隐藏的上拉隐藏动画
 */
const axHeightUp = (elem, arrHeight, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    let dftTime = height => height / 3 + 250;
    const height = (arrHeight && arrHeight.height) ? arrHeight.height : axArrHeight(element).height,
        paddingTop = (arrHeight && arrHeight.paddingTop) ? arrHeight.paddingTop : axArrHeight(element).paddingTop,
        paddingBottom = (arrHeight && arrHeight.paddingBottom) ? arrHeight.paddingBottom : axArrHeight(element).paddingBottom,
        marginTop = (arrHeight && arrHeight.marginTop) ? arrHeight.marginTop : axArrHeight(element).marginTop,
        marginBottom = (arrHeight && arrHeight.marginBottom) ? arrHeight.marginBottom : axArrHeight(element).marginBottom;
    let time;
    if (duration !== undefined && typeof duration === 'number') {
        time = duration;
    } else {
        time = dftTime(height);
    }
    element.style.overflow = 'hidden';
    const initTime = new Date().getTime();
    const repeat = () => {
        const newTime = new Date().getTime() - initTime;
        const timestep = newTime / time;
        const timefactor = axCurves[curve](timestep);
        const step = height + -height * timefactor;
        const stepPaddingT = paddingTop + (-paddingTop * timefactor);
        const stepPaddingB = paddingBottom + (-paddingBottom * timefactor);
        const stepMarginT = marginTop + (-marginTop * timefactor);
        const stepMarginB = marginBottom + (-marginBottom * timefactor);
        if (newTime <= time && Math.floor(step) > 0) {
            element.style.height = step + 'px';
            paddingTop ? element.style.paddingTop = stepPaddingT + 'px' : null;
            paddingBottom ? element.style.paddingBottom = stepPaddingB + 'px' : null;
            marginTop ? element.style.marginTop = stepMarginT + 'px' : null;
            marginBottom ? element.style.marginBottom = stepMarginB + 'px' : null;
        } else {
            element.style.height = 0;
            paddingTop ? element.style.paddingTop = 0 : null;
            paddingBottom ? element.style.paddingBottom = 0 : null;
            marginTop ? element.style.marginTop = 0 : null;
            marginBottom ? element.style.marginBottom = 0 : null;
        }
        const repeatLoop = requestAnimationFrame(repeat);
        if (Math.floor(step) <= 0 || !height) {
            cancelAnimationFrame(repeatLoop);
            callback && callback();
        }
    };
    repeat();
    return element;
};
/**
 * 定义axSlideToggle动画
 * 举例：axSlideToggle(elem,200,'easeOut')
 */
const axSlideToggle = (elem, downCallback, upCallback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (window.getComputedStyle(element).display === 'none') {
        axSlideDown(element, downCallback, duration, curve);
    } else {
        axSlideUp(element, upCallback, duration, curve);
    }
    return element;
}
/**
 * 定义axFadeIn动画
 * 举例：axFadeIn(elem,200,'linear')
 */
const axFadeIn = (elem, dis, callback, duration = 200, curve = 'linear') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (element) {
        let display = window.getComputedStyle(element).display,
            opacity = window.getComputedStyle(element).opacity;
        if (display === 'none') {
            element.style.display = !dis ? 'block' : dis;
            element.style.opacity = 0;
            let initTime = new Date().getTime();
            let repeat = () => {
                let newTime = new Date().getTime() - initTime,
                    timestep = newTime / duration,
                    step = axCurves[curve](timestep);
                if (newTime <= duration && step <= 1) {
                    element.style.display = !dis ? 'block' : dis;
                    element.style.opacity = step;
                } else {
                    element.style.display = !dis ? 'block' : dis;
                    element.style.opacity = 1;
                }
                let repeatLoop = requestAnimationFrame(repeat);
                if (step >= 1) {
                    cancelAnimationFrame(repeatLoop);
                }
            };
            repeat();
        } else if (display !== 'none' && Number(opacity) !== 1) {
            let initTime = new Date().getTime();
            let repeat = () => {
                let newTime = new Date().getTime() - initTime,
                    timestep = newTime / duration,
                    step = axCurves[curve](timestep) + Number(opacity);
                if (newTime <= duration && step <= 1) {
                    element.style.display = display;
                    element.style.opacity = step;
                } else {
                    element.style.display = display;
                    element.style.opacity = 1;
                }
                let repeatLoop = requestAnimationFrame(repeat);
                if (step >= 1) {
                    cancelAnimationFrame(repeatLoop);
                }
            };
            repeat();
        }
    }
    callback && callback();
    return element;
};
/**
 * 定义axFadeOut动画
 * 举例：axFadeOut(elem,200,'linear')
 */
const axFadeOut = (elem, callback, duration = 200, curve = 'linear') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (element) {
        let display = window.getComputedStyle(element).display,
            opacity = window.getComputedStyle(element).opacity;
        if (display !== 'none' || Number(opacity) !== 0) {
            element.style.opacity = opacity;
            let initTime = new Date().getTime();
            let repeat = () => {
                let newTime = new Date().getTime() - initTime,
                    timestep = newTime / duration,
                    step = Number(opacity) - axCurves[curve](timestep);
                if (newTime <= duration && step > 0) {
                    element.style.opacity = step;
                } else {
                    element.style.opacity = 0;
                    element.style.display = 'none';
                }
                let repeatLoop = requestAnimationFrame(repeat);
                if (step <= 0) {
                    cancelAnimationFrame(repeatLoop);
                }
            };
            repeat();
        }
    }
    callback && callback();
    return element;
};
/**
 * 定义axFadeToggle动画
 * 举例：axFadeToggle(elem,200,'linear')
 */
const axFadeToggle = (elem, dis, inCallback, outCallback, duration = 200, curve = 'linear') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (element) {
        let display = window.getComputedStyle(element).display;
        let opacity = window.getComputedStyle(element).opacity;
        if (display === 'none') {
            axFadeIn(element, dis, inCallback, duration, curve);
        } else if (Number(opacity) <= 0.5) {
            axFadeIn(element, dis, inCallback, duration, curve);
        } else if (Number(opacity) > 0.5) {
            axFadeOut(element, outCallback, duration, curve);
        } else {
            axFadeOut(element, outCallback, duration, curve);
        }
    }
    return element;
}
/**
 * 定义axShow动画（元素显示），因为有些元素显示方式可以是inline-block、block、visible或box，所以需要使用show来设定，如果不填则优先使用block
 * 举例：axShow(elem,show,callback)
 */
const axShow = (element, show, callback) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    if (show == 'visible') {
        elem.style.visibility = 'visible';
    } else if (show) {
        elem.style.display = show;
    } else {
        elem.style.display = 'block';
    }
    callback && callback();
}
/**
 * 定义axHide动画(元素隐藏)，根据实际情况选择隐藏方式来设置hide参数，可选none和hidden，如果不填则优先使用none
 * 举例：axHide(elem,hide,callback)
 */
const axHide = (element, hide, callback) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    if (hide == 'hidden') {
        elem.style.visibility = 'hidden';
    } else {
        elem.style.display = 'none';
    }
    callback && callback();
}
/**
 * 元素显示隐藏切换，show和hide参数如上面两个函数所述
 * 举例: axToggle(elem,show,hide)
 */
const axToggle = (element, show, hide, showCallback, hideCallback) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    axIsVisible(elem) ? axHide(elem, hide, hideCallback) : axShow(elem, show, showCallback);
}
/**
 * 页面锚记滚动
 * 举例：axScrollTo(elem,target,2000,'easeOut')
 */
const axScrollTo = (element, duration, curve = 'easeOut') => {
    let offsetScrolled = document.documentElement.scrollTop,
        initTime = new Date().getTime(),
        offsetClient = element ? axIdToDom(element).getBoundingClientRect().top : -offsetScrolled;
    if (!duration || typeof duration !== 'number') {
        duration = Math.abs(offsetClient) / 4 + 1000;
    }
    let repeat = () => {
        let newTime = new Date().getTime() - initTime,
            timestep = newTime / duration,
            step = offsetScrolled + offsetClient * axCurves[curve](timestep);
        window.scrollTo(0, step);
        repeat.timer = requestAnimationFrame(repeat);
        if (newTime >= duration) {
            window.scrollTo(0, step);
            cancelAnimationFrame(repeat.timer);
        }
    };
    repeat();
    return element;
};
/**
 * 定义常用图标
 */
const axIcon = {
    font: {
        success: '<i class="ax-iconfont ax-icon-check-o"></i>',
        error: '<i class="ax-iconfont ax-icon-close-o"></i>',
        warning: '<i class="ax-iconfont ax-icon-warning-o"></i>',
        info: '<i class="ax-iconfont ax-icon-info-o"></i>',
        question: '<i class="ax-iconfont ax-icon-question-o"></i>',
        successFill: '<i class="ax-iconfont ax-icon-check-o-f"></i>',
        errorFill: '<i class="ax-iconfont ax-icon-close-o-f"></i>',
        warningFill: '<i class="ax-iconfont ax-icon-warning-o-f"></i>',
        infoFill: '<i class="ax-iconfont ax-icon-info-o-f"></i>',
        questionFill: '<i class="ax-iconfont ax-icon-question-o-f"></i>',
    },
    svg: {
        success: '<svg class="svg-success" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M26.316,42.859L37.9984,54.5414L60.3826,32.1572"></path></svg>',
        error: '<svg class="svg-error" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M28.774,57.9246L57.9247,28.7739"></path><path class="svg-line svg-in-2" d="M57.9246,57.9246L28.7739,28.7739"></path></svg>',
        warning: '<svg class="svg-warning" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M43.4611 7.24c2.8081,0.0924 4.39,1.7 5.3045,3.1159l17.4543 29.9414 17.3445 29.7538c0.5448,1.0193 1.596,4.0544 0.1109,6.4168 -1.4849,2.3626 -3.6815,2.9155 -5.3768,2.992l-34.9082 0.0002 -34.6892 -0.0002c-1.1636,-0.0421 -4.3433,-0.6583 -5.6666,-3.1131 -1.3232,-2.4549 -0.7085,-4.6157 0.0723,-6.1078l17.454 -29.9417 17.3449 -29.7537c0.6185,-0.977 2.7471,-3.396 5.5554,-3.3036z"></path><path class="svg-line svg-out" d="M43.4611 7.24c2.8081,0.0924 4.39,1.7 5.3045,3.1159l17.4543 29.9414 17.3445 29.7538c0.5448,1.0193 1.596,4.0544 0.1109,6.4168 -1.4849,2.3626 -3.6815,2.9155 -5.3768,2.992l-34.9082 0.0002 -34.6892 -0.0002c-1.1636,-0.0421 -4.3433,-0.6583 -5.6666,-3.1131 -1.3232,-2.4549 -0.7085,-4.6157 0.0723,-6.1078l17.454 -29.9417 17.3449 -29.7537c0.6185,-0.977 2.7471,-3.396 5.5554,-3.3036z"></path><path class="svg-line svg-in-1" d="M43.3493,27.8713L43.3493,57.2858"></path><circle class="svg-circle svg-in-2" cx="43.3492" cy="64.3337" r="2.1166"></circle></svg>',
        info: '<svg class="svg-info" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M43.3493,65.0602L43.3493,30.9723"></path><circle class="svg-circle svg-in-2" cx="43.3492" cy="23.5856" r="2.1166"></circle></svg>',
        question: '<svg class="svg-question" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M32.3757 35.7255c-0.2203,-11.823 12.5789,-14.1087 18.4056,-9.4189 5.4663,4.3995 4.7426,12.804 -3.1088,17.9938 -3.0015,1.9839 -3.0003,3.8403 -3.0003,10.1707"></path><circle class="svg-circle svg-in-2" cx="44.6612" cy="60.5502" r="2.1166"></circle></svg>',
    },
};
/**
 * 定义常用图片
 */
const axImage = {
    loadSvg: getComputedStyle(document.documentElement).getPropertyValue('--load-svg').trim().split('"')[1],
    loadSvgW: getComputedStyle(document.documentElement).getPropertyValue('--load-svg-w').trim().split('"')[1],
    loadGif: getComputedStyle(document.documentElement).getPropertyValue('--load-gif').trim().split('"')[1],
    imgAvatar: 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iMTYwcHgiIGhlaWdodD0iMTYwcHgiIHZpZXdCb3g9IjAgMCAxNjAgMTYwIj4NCjxyZWN0IHk9IjAiIGZpbGw9IiNGRkZGRkYiIHdpZHRoPSI4MCIgaGVpZ2h0PSIxNjAiLz4NCjxyZWN0IHg9IjgwIiBmaWxsPSIjRjRGNEY0IiB3aWR0aD0iODAiIGhlaWdodD0iMTYwIi8+DQo8cGF0aCBmaWxsPSIjQjJCMkIyIiBkPSJNOTguOTE2LDk3LjI1MmMxMC4zOTMtNi4zODIsMTcuMzQtMTcuODUxLDE3LjM0LTMwLjkxNmMwLTE5Ljk5Mi0xNi4yNjYtMzYuMjU1LTM2LjI1Ny0zNi4yNTUNCgljLTE5Ljk5MiwwLTM2LjI1NSwxNi4yNjMtMzYuMjU1LDM2LjI1NWMwLDEzLjA2NCw2Ljk0NiwyNC41MzQsMTcuMzM4LDMwLjkxNkMzNC4xMTQsMTA1LjM3MSwxNC40NjcsMTMwLjM4NywxNC40NjcsMTYwaDEzMS4wNjYNCglDMTQ1LjUzMywxMzAuMzg3LDEyNS44ODUsMTA1LjM3MSw5OC45MTYsOTcuMjUyeiIvPg0KPC9zdmc+DQo=',
    imgNone: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciICB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2MHB4IiBoZWlnaHQ9IjE2MHB4IiB2aWV3Qm94PSIwIDAgMTYwIDE2MCI+DQo8cmVjdCBmaWxsPSIjRkZGRkZGIiB3aWR0aD0iMTYwIiBoZWlnaHQ9IjE2MCIvPg0KPGc+DQoJPGc+DQoJCTxnPg0KCQkJPHBhdGggZmlsbD0iI0M5Q0FDQSIgZD0iTTc5LjA4Nyw4Ny44Nkg2MS45ODNjLTEuNzE3LDAtMy4xMDgtMS4yMjMtMy4xMDktMi43M3YtMi4xMTFsOS4xNjMtNi45NThsMy4yODQsMi44NDENCgkJCQljMS43MDgsMS40ODYsNC40MjIsMS41ODUsNi4yNjIsMC4yMjhMOTMuMDcsNjcuNjI1bDYuMjI2LDUuNDc5YzAuNjI4LDAuNTkxLDAuODkyLDAuODU4LDEuNTgsMC44NTgNCgkJCQljMC40OTMsMCwwLjkwNC0wLjI0NCwxLjIxOS0wLjU4N2MwLjMzMy0wLjM2MywwLjMxMS0xLjIzOCwwLjMxMS0xLjY3MlY1Ny44MWMwLTMuMDE4LTIuNzgzLTUuNDY1LTYuMjE4LTUuNDY1SDYxLjk4Mw0KCQkJCWMtMy40MzUsMC02LjIxOCwyLjQ0Ny02LjIxOCw1LjQ2NXYyNy4zMmMwLDEuNDQ4LDAuNjU1LDIuODM5LDEuODIxLDMuODYzYzEuMTY3LDEuMDIzLDIuNzQ5LDEuNjAxLDQuMzk3LDEuNjAxaDE3LjA3MQ0KCQkJCWMwLjc5NSwwLDEuNTI1LTAuNTY3LDEuNTgyLTEuMjY1YzAuMDY1LTAuOC0wLjY1My0xLjQ2Ny0xLjU0Ny0xLjQ2N0w3OS4wODcsODcuODZ6IE01OC44NzUsNTcuODENCgkJCQljMC0xLjUwOSwxLjM5Mi0yLjczMiwzLjEwOS0yLjczMmgzNC4yMDNjMS43MTgsMCwzLjEwOSwxLjIyMywzLjEwOSwyLjczMnYxMS40MzRsLTQuMTIzLTMuNjI5DQoJCQkJYy0xLjE1Mi0wLjg1Ny0yLjg0LTAuODYtMy45OTYtMC4wMDhMNzUuNTg3LDc3LjAyOWMtMC42MTMsMC40NDktMS41MTMsMC40MTctMi4wODItMC4wNzVsLTMuMjg3LTIuODQNCgkJCQljLTEuMTU5LTAuOTkzLTIuOTg5LTEuMDQ0LTQuMjE2LTAuMTIxbC03LjEyNyw1LjQyTDU4Ljg3NSw1Ny44MUw1OC44NzUsNTcuODF6IE02Ny4wMDQsNjQuMjE1YzAsMS42NTgsMC45OTksMy4xNTMsMi41MywzLjc4Nw0KCQkJCWMxLjUzMiwwLjYzNSwzLjI5NSwwLjI4NSw0LjQ2Ny0wLjg4OGMxLjE3My0xLjE3MiwxLjUyMi0yLjkzNSwwLjg4OS00LjQ2NmMtMC42MzUtMS41MzEtMi4xMjktMi41MzEtMy43ODctMi41MzENCgkJCQljLTEuMDg3LDAtMi4xMywwLjQzMi0yLjg5OCwxLjJDNjcuNDM2LDYyLjA4Niw2Ny4wMDQsNjMuMTI3LDY3LjAwNCw2NC4yMTVMNjcuMDA0LDY0LjIxNXogTTEwMi4zMzgsNzkuNzM3DQoJCQkJYzMuNzM3LDMuNzMzLDMuNzM3LDkuNzg2LDAsMTMuNTJjLTMuNzM1LDMuNzM1LTkuNzg5LDMuNzM2LTEzLjUyMywwYy0zLjY4Mi0zLjc0NC0zLjY1NS05Ljc1NCwwLjA1Ny0xMy40NjMNCgkJCQlDOTIuNTgzLDc2LjA4Miw5OC41OTUsNzYuMDU2LDEwMi4zMzgsNzkuNzM3TDEwMi4zMzgsNzkuNzM3eiBNOTAuNzQ1LDkxLjMyNWMyLjI5NSwyLjI5NCw1Ljg4NiwyLjY1Nyw4LjU5MywwLjg2OWwtOS40NjItOS40NjQNCgkJCQljLTEuNzg3LDIuNzA2LTEuNDI0LDYuMjk4LDAuODY5LDguNTkyVjkxLjMyNXogTTEwMS4yNzIsOTAuMjU5YzEuNzgyLTIuNzA4LDEuNDE2LTYuMjk1LTAuODc1LTguNTg1DQoJCQkJYy0yLjI5My0yLjI5LTUuODc5LTIuNjU3LTguNTg3LTAuODc1TDEwMS4yNzIsOTAuMjU5eiBNMTAxLjI3Miw5MC4yNTkiLz4NCgkJPC9nPg0KCTwvZz4NCgk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDU0LjgyMzcgMTEwLjU1MDgpIiBmaWxsPSIjQzlDQUNBIiBmb250LWZhbWlseT0iJ01pY3Jvc29mdFlhSGVpJyIgZm9udC1zaXplPSIxMi41ODc3Ij7mmoLml6Dlm77niYc8L3RleHQ+DQo8L2c+DQo8L3N2Zz4NCg==',
    empty: 'data:image/svg+xml;base64,PHN2ZyB0PSIxNTg5ODk5NTI1MTA0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBwLWlkPSIyNTI5IiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTExOC44MjY5NzEgMTM4LjQwOTE0M2E3Ljk2ODA0MSA3Ljk2ODA0MSAwIDAgMCA3LjkyMDYxMi03LjkyMDYxMlYxMTEuMzUxMDAzYTcuOTIwNjEyIDcuOTIwNjEyIDAgMSAwLTE1Ljg0MTIyNSAwdjE5LjE3MzA5OWE3Ljk2ODA0MSA3Ljk2ODA0MSAwIDAgMCA3LjkyMDYxMyA3LjkyMDYxM3ogbTE0LjU5NjIxOCAxNC41OTYyMThoMTkuMTg0OTU2YTcuOTIwNjEyIDcuOTIwNjEyIDAgMSAwIDAtMTUuODQxMjI0SDEzMy40MzUwNDZhNy45MjA2MTIgNy45MjA2MTIgMCAxIDAgMCAxNS44NDEyMjR6IG0tMjkuMTkyNDM3LTE1Ljc4MTkzOEg4NS4wNTc2NTNhNy45MjA2MTIgNy45MjA2MTIgMCAwIDAgMCAxNS44NDEyMjRoMTkuMTczMDk5YTcuOTIwNjEyIDcuOTIwNjEyIDAgMCAwIDAtMTUuODQxMjI0eiBtMTQuNTk2MjE5IDE0LjU4NDM2MWE3Ljk2ODA0MSA3Ljk2ODA0MSAwIDAgMC03LjkyMDYxMyA3LjkyMDYxMnYxOS4xNzMwOTlhNy45MjA2MTIgNy45MjA2MTIgMCAwIDAgMTUuODQxMjI1IDB2LTE5LjE0OTM4NWE3Ljk2ODA0MSA3Ljk2ODA0MSAwIDAgMC03LjkyMDYxMi03LjkyMDYxMnogbTc4OC41MDQwNyAxMTguMjc1NjFhMzguNzI1NjI4IDM4LjcyNTYyOCAwIDEgMCAzOC43MjU2MjggMzguNzI1NjI5IDM4LjY3ODIgMzguNjc4MiAwIDAgMC0zOC43NjEyLTM4Ljc4NDkxNXogbTAgNjEuNDkxNDZhMjIuODg0NDA0IDIyLjg4NDQwNCAwIDEgMSAyMi44ODQ0MDMtMjIuODg0NDAzIDIyLjkxOTk3NSAyMi45MTk5NzUgMCAwIDEtMjIuODg0NDAzIDIyLjg4NDQwM3pNNjkyLjUyNTkzMiA0Ny44NzkzOWEyMy41MDA5NzggMjMuNTAwOTc4IDAgMSAwLTIzLjUwMDk3OS0yMy41MDA5NzggMjMuNTAwOTc4IDIzLjUwMDk3OCAwIDAgMCAyMy41MDA5NzkgMjMuNTAwOTc4eiBtMC0zMS4zMDMwMTlhNy42NzE2MTEgNy42NzE2MTEgMCAxIDEtNy42NzE2MTEgNy42NzE2MTEgNy43MDcxODMgNy43MDcxODMgMCAwIDEgNy42NzE2MTEtNy42NzE2MTF6IG0wIDAiIGZpbGw9IiNlNmU2ZTYiIHAtaWQ9IjI1MzAiPjwvcGF0aD48cGF0aCBkPSJNMjc1Ljc2ODkyMyA5OTIuODE1NTUzYzAgMTEuMTQ1NzcyIDM4LjE1NjQ4MyAyMS4zNDI5NjcgOTkuODQ5NTE2IDI2Ljk2MzI4MmExMTk3LjE4NjMyMyAxMTk3LjE4NjMyMyAwIDAgMCAxOTkuOTEyNDYgMGM2MS45MDY0NjItNS41NzI4ODYgOTkuODQ5NTE1LTE1LjgxNzUxIDk5Ljg0OTUxNi0yNi45NjMyODJzLTM4LjE1NjQ4My0yMS4zNDI5NjctOTkuODQ5NTE2LTI2Ljk2MzI4MmExMTk3LjAyMDMyMiAxMTk3LjAyMDMyMiAwIDAgMC0xOTkuOTEyNDYgMGMtNjEuNjU3NDYxIDUuNTcyODg2LTk5Ljg0OTUxNSAxNS44MTc1MS05OS44NDk1MTYgMjYuOTYzMjgyeiBtMCAwIiBmaWxsPSIjZjBmMGYwIiBwLWlkPSIyNTMxIj48L3BhdGg+PHBhdGggZD0iTTU3MS4wMjUxNjIgNDgyLjg5NjQ5M2E3Ljc2NjQ2OSA3Ljc2NjQ2OSAwIDAgMC0xMS4xMzM5MTUgMGwtMTEuOTk5NDkgMTEuOTk5NDktMTEuOTk5NDkxLTExLjk5OTQ5YTcuODczMTgzIDcuODczMTgzIDAgMSAwLTExLjEzMzkxNCAxMS4xMzM5MTRsMTEuOTk5NDkgMTEuOTk5NDkxLTExLjk5OTQ5IDExLjk5OTQ5YTcuOTU2MTg0IDcuOTU2MTg0IDAgMSAwIDExLjI1MjQ4NiAxMS4yNTI0ODdsMTEuOTk5NDkxLTExLjk5OTQ5MSAxMS45OTk0OSAxMS45OTk0OTFhNy43NzgzMjYgNy43NzgzMjYgMCAwIDAgNS41NzI4ODYgMi4zNzE0NDEgNy41NzY3NTMgNy41NzY3NTMgMCAwIDAgNS41NzI4ODYtMi4zNzE0NDEgNy43NjY0NjkgNy43NjY0NjkgMCAwIDAgMC0xMS4xMzM5MTVsLTExLjk5OTQ5LTExLjk5OTQ5IDExLjk5OTQ5LTExLjk5OTQ5MWE4LjExMDMyOCA4LjExMDMyOCAwIDAgMC0wLjExODU3Mi0xMS4yNTI0ODZ6IG0tMTU0LjkwMjUxNCA0Ni4zOTcyMzlhNy44NzMxODMgNy44NzMxODMgMCAwIDAgNS41NzI4ODYgMi4zNzE0NDEgNy44NzMxODMgNy44NzMxODMgMCAwIDAgNS41NzI4ODYtMTMuNDgxNjQxbC0xMS45OTk0OTEtMTEuOTk5NDkxIDExLjk5OTQ5MS0xMS45OTk0OWE3Ljc2NjQ2OSA3Ljc2NjQ2OSAwIDAgMCAwLTExLjEzMzkxNSA3Ljk5MTc1NiA3Ljk5MTc1NiAwIDAgMC0xMS4yNjQzNDQgMGwtMTEuOTk5NDkxIDExLjk5OTQ5MS0xMS45OTk0OS0xMS45OTk0OTFhNy45OTE3NTYgNy45OTE3NTYgMCAwIDAtMTEuMjY0MzQ0IDAgNy43NjY0NjkgNy43NjY0NjkgMCAwIDAgMCAxMS4xMzM5MTVsMTEuOTk5NDkxIDExLjk5OTQ5LTExLjk5OTQ5MSAxMS45OTk0OTFhNy43NjY0NjkgNy43NjY0NjkgMCAwIDAgMCAxMS4xMzM5MTUgNy43NzgzMjYgNy43NzgzMjYgMCAwIDAgNS41NzI4ODYgMi4zNzE0NCA3LjU3Njc1MyA3LjU3Njc1MyAwIDAgMCA1LjU3Mjg4Ni0yLjM3MTQ0bDExLjk5OTQ5LTExLjk5OTQ5MXogbTU5Ljg3ODg4IDgzLjM5MTcxNmExMDcuMzkwNjk3IDEwNy4zOTA2OTcgMCAwIDAtNzcuNDUxMjU2IDMyLjY1NDc0IDcuOTU2MTg0IDcuOTU2MTg0IDAgMCAwIDAuMTE4NTcyIDExLjEzMzkxNSA3LjgzNzYxMiA3LjgzNzYxMiAwIDAgMCAxMS4xMzM5MTQtMC4xMTg1NzIgOTIuNjE2NjIxIDkyLjYxNjYyMSAwIDAgMSAxMzIuMzg1Njg0IDAgOC4xNTc3NTYgOC4xNTc3NTYgMCAwIDAgNS42OTE0NTcgMi4zNzE0NDEgNy44MjU3NTUgNy44MjU3NTUgMCAwIDAgNy4zMDQwMzgtNC44MjU4ODIgOC4wMTU0NyA4LjAxNTQ3IDAgMCAwLTEuNjEyNTgtOC42NTU3NTkgMTA3Ljc1ODI3MSAxMDcuNzU4MjcxIDAgMCAwLTc3LjU2OTgyOS0zMi41MzYxNjh6IG0wIDAiIGZpbGw9IiNkYmRiZGIiIHAtaWQ9IjI1MzIiPjwvcGF0aD48cGF0aCBkPSJNNzY4LjYwMTc1MyAzMTMuODcyMDQ5bC04Mi4xNDY3MS05MS42Nzk5MDJhOTQuMjI5MjAxIDk0LjIyOTIwMSAwIDAgMC03MC4xNDcyMTktMzEuMzAzMDE5SDI0Ni41MDUzNDRhODUuOTA1NDQzIDg1LjkwNTQ0MyAwIDAgMC04NS44NTgwMTUgODUuODU4MDE1djU2NC42NTE5MTRhODUuOTA1NDQzIDg1LjkwNTQ0MyAwIDAgMCA4NS44NTgwMTUgODUuODU4MDE1aDQ1OS40OTAzNzJhODUuOTA1NDQzIDg1LjkwNTQ0MyAwIDAgMCA4NS44NTgwMTQtODUuODU4MDE1VjM3NC42MTY1MDVhOTEuMDYzMzI3IDkxLjA2MzMyNyAwIDAgMC0yMy4yNjM4MzQtNjAuNzQ0NDU2eiBtLTk0LjAyNzYyOC04MS4xNjI1NjJsODIuMTQ2NzEgOTEuNjc5OTAyYTc3LjQyNzU0MyA3Ny40Mjc1NDMgMCAwIDEgMTQuMjI4NjQ1IDIzLjI2MzgzNGgtODUuNDkwNDQyYTM4Ljk2Mjc3MyAzOC45NjI3NzMgMCAwIDEtMzguOTc0NjMtMzguOTc0NjN2LTk1Ljg3NzM1MmE3Ny4yODUyNTYgNzcuMjg1MjU2IDAgMCAxIDI4LjA4OTcxNyAxOS45MjAxMDN6IG0xMDEuNDUwMjM4IDYwOC43MDE0MjhhNzAuMTIzNTA1IDcwLjEyMzUwNSAwIDAgMS03MC4wMjg2NDcgNzAuMDI4NjQ3SDI0Ni41MDUzNDRhNzAuMTIzNTA1IDcwLjEyMzUwNSAwIDAgMS03MC4wMjg2NDctNzAuMDI4NjQ3VjI3Ni43NDcxNDNhNzAuMTIzNTA1IDcwLjEyMzUwNSAwIDAgMSA3MC4wMjg2NDctNzAuMDI4NjQ3aDM2OS44MDI0OGE3OS40NDMyNjcgNzkuNDQzMjY3IDAgMCAxIDE0LjM0NzIxNyAxLjM2MzU3OHYxMDAuNTg0NjYyYTU0LjkxMDcxMiA1NC45MTA3MTIgMCAwIDAgNTQuODAzOTk3IDU0LjgwMzk5N2g4OS42OTk3NDlhODQuMzUyMTUgODQuMzUyMTUgMCAwIDEgMC44NjU1NzYgMTEuMTMzOTE1djQ2Ni43OTQ0MDl6IG0wIDAiIGZpbGw9IiNkYmRiZGIiIHAtaWQ9IjI1MzMiPjwvcGF0aD48L3N2Zz4=',
}
/**
 * 定义结果函数
 */
const axResult = (elem, state) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let dom = axIdToDom(elem),
        svg = '';
    switch (state) {
        case 'success':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M26.316,42.859L37.9984,54.5414L60.3826,32.1572"></path>`;
            dom.querySelector('svg').classList.add('svg-success');
            break;
        case 'error':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M28.774,57.9246L57.9247,28.7739"></path>
            <path class="svg-line svg-in-2" d="M57.9246,57.9246L28.7739,28.7739"></path>`;
            dom.querySelector('svg').classList.add('svg-error');
            break;
        case 'question':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M32.3757 35.7255c-0.2203,-11.823 12.5789,-14.1087 18.4056,-9.4189 5.4663,4.3995 4.7426,12.804 -3.1088,17.9938 -3.0015,1.9839 -3.0003,3.8403 -3.0003,10.1707"></path>
            <circle class="svg-circle svg-in-2" cx="44.6612" cy="60.5502" r="2.1166"></circle>`;
            dom.querySelector('svg').classList.add('svg-question');
            break;
        case 'info':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M43.3493,65.0602L43.3493,30.9723"></path>
            <circle class="svg-circle svg-in-2" cx="43.3492" cy="23.5856" r="2.1166"></circle>`;
            dom.querySelector('svg').classList.add('svg-info');
            break;
    }
    dom.classList.add('ax-result-show');
    if (dom.querySelector('svg').innerHTML.indexOf('svg-in-1') == -1) {
        dom.querySelector('svg').insertAdjacentHTML('beforeend', svg);
    }
}
/**
 * 获取主体内容，适用于dialog|drawer|popup
 */
const axCreateContent = (options, instance, callback) => {
    let html = options.content;
    if (options.type == 'html' && typeof options.content === 'string' && options.content.substr(0, 1) == '#') {
        options.content = document.querySelector(options.content).innerHTML;
    } else if (options.type == 'html' && typeof options.content === 'function') {
        options.content = options.content.call(instance);
    } else if (options.type == 'async' && options.url) {
        if (options.url.indexOf('#') > -1) {
            let ajaxUrl = options.url.match(/(\S*)\#/)[1],
                ajaxSelector = '#' + options.url.match(/\#(\S*)/)[1],
                content = options.content;
            axAjax({
                url: ajaxUrl,
                selector: ajaxSelector,
                before: (loading) => {
                    options.content = loading;
                },
                success: (data) => {
                    options.content = data;
                    if (typeof content === 'function') {
                        instance.content.innerHTML = content(data);
                    } else {
                        instance.content.innerHTML = data;
                    }
                    callback && callback();
                }
            });
        } else {
            let content = options.content;
            axAjax({
                url: options.url,
                before: (loading) => {
                    options.content = loading;
                },
                success: (data) => {
                    options.content = data;
                    if (typeof content === 'function') {
                        instance.content.innerHTML = content(data);
                    } else {
                        instance.content.innerHTML = data;
                    }
                    callback && callback();
                }
            });
        }
    } else if (options.type == 'iframe' && options.url) {
        options.content = `<iframe src="${options.url}" frameborder="0" width="100%" height="100%"></iframe>`;
        options.footerShow = false;
    } else if (options.content) {
        options.content = options.content;
    } else {
        options.content = '没有任何内容！';
    }
    if (options.type == 'picture' && options.url) {
        options.content = `
        <div class="ax-media-container"><img src="${options.url}" /></div>
        <div class="ax-media-title">${options.name}</div>
        ${html}
        `;
    } else if (options.type == 'video' && options.url) {
        options.content = `
        <div class="ax-media-container"><video src="${options.url}" controls="controls" ></video></div>
        <div class="ax-media-title">${options.name}</div>
        ${html}
        `;
    } else if (options.type == 'audio' && options.url) {
        options.content = `
        <div class="ax-media-container"><audio src="${options.url}" controls="controls" ></audio></div>
        <div class="ax-media-title">${options.name}</div>
        ${html}
        `;
    }
    return options.content;
}
/**
 * 获取底部内容，适用于dialog|drawer|popup
 */
const axFooterBtns = (options, instance) => {
    let lineBreak = options.footerBreak ? `<div class="ax-break-line"></div>` : '';
    let footer = '';
    options.note ? options.note = `<div class="ax-note">${options.note}</div>` : null
    if (!options.footerShow) {
        footer = '';
    } else if (options.footerType == 'right') {
        let btnCancel = '',
            btnConfirm = '',
            btnDiy = '';
        options.confirm.text ? btnConfirm = `<a href="###" class="ax-btn ax-primary ${options.confirm.classname}"  confirm>${options.confirm.icon}${options.confirm.text}</a>` : null;
        options.cancel.text ? btnCancel = `<a href="###" class="ax-btn ax-text ax-ignore ${options.cancel.classname}"  cancel>${options.cancel.icon}${options.cancel.text}</a>` : null;
        if (options.diy.text && options.diy.callback) {
            btnDiy = `<a href="###" class="ax-btn ax-text ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a>`;
        } else if (options.diy.text && !options.diy.callback) {
            btnDiy = `<a href="${options.diy.url}" target="${options.diy.url}" class="ax-btn ax-text ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a>`;
        }
        footer = `
                                        ${lineBreak}
                                        <div class="ax-padding">
                                              <div class="ax-row">
                                                  <div class="ax-col">
                                                  ${options.note}
                                                  </div>
                                                  <div class="ax-btns">${btnDiy}${btnCancel}${btnConfirm}</div>
                                              </div>
                                          </div>
                          `;
    } else if (options.footerType == 'line') {
        let btnCancel = '',
            btnConfirm = '',
            btnDiy = '';
        options.confirm.text ? btnConfirm = `<a href="###" class="ax-col ax-col-12 ${options.confirm.classname}"  confirm>${options.confirm.icon}${options.confirm.text}</a>` : null;
        options.cancel.text ? btnCancel = `<a href="###" class="ax-col ax-col-12 ${options.cancel.classname}"  cancel>${options.cancel.icon}${options.cancel.text}</a><span class="ax-gutter-line"></span>` : null;
        if (options.diy.text && options.diy.callback) {
            btnDiy = `<a href="###" class="ax-col ax-col-12 ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a><span class="ax-gutter-line"></span>`;
        } else if (options.diy.text && !options.diy.callback) {
            btnDiy = `<a href="${options.diy.url}" target="${options.diy.url}" class="ax-col ax-col-12 ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a><span class="ax-gutter-line"></span>`;
        }
        footer = `
                          <div class="ax-break-line"></div>
                          <div class="ax-row">${btnDiy}${btnCancel}${btnConfirm}</div>${options.note}
                          `
    } else {
        let btnCancel = '',
            btnConfirm = '',
            btnDiy = '';
        options.confirm.text ? btnConfirm = `<a href="###" class="ax-btn ax-primary ${options.confirm.classname}"  confirm>${options.confirm.icon}${options.confirm.text}</a>` : null;
        options.cancel.text ? btnCancel = `<a href="###" class="ax-btn ax-ignore ${options.cancel.classname}" cancel>${options.cancel.icon}${options.cancel.text}</a>` : null;
        if (options.diy.text && options.diy.callback) {
            btnDiy = `<a href="###" class="ax-btn ${options.diy.classname}" diy>${options.diy.icon}${options.diy.text}</a>`;
        } else if (options.diy.text && !options.diy.callback) {
            btnDiy = `<a href="${options.diy.url}" target="${options.diy.url}" class="ax-btn ${options.diy.classname}" diy>${options.diy.icon}${options.diy.text}</a>`;
        }
        footer = `
                                        ${lineBreak}
                                         <div class="ax-padding ax-align-center">${btnDiy}${btnCancel}${btnConfirm}</div>
                                         <div class="ax-break"></div>${options.note}
                         `
    }
    return footer;
}
/**
 * 日期时间均转成本地时间戳
 * 类似2021-1-12和2021-01-12字符“-”均转成“/”分隔
 * axLocalTime('2070-1-20') - new Date(axLocalTime('2070-1-20')).getTimezoneOffset() * 60000) % 86400000 = 0 （能整除）
 * new Date('2070-01-20 12:11:13').getTime() == new Date('2070-1-20 12:11:13').getTime() == axLocalTime('2070-1-20 12:11:13')
 * new Date('2070/1/20').getTime() == new Date('2070-01-20').getTime() == axLocalTime('2070-1-20',true)
 * new Date('2070-1-20').getTime() == axLocalTime('2070-1-20')
 * axLocalTime('2070-1-20')和new Date(axLocalTime('2070-1-20'))可以互转
*/
const axLocalTime = (date, utc) => {
    let para, localDate, flag, loacalTime, localOffset;
    if (date) {
        date = date.trim();
        localDate = new Date(date);
        flag = localDate instanceof Date && !isNaN(localDate.getTime());
        if (!flag) {
            return console.error('Date format must be "YYYY-MM-DD" or "YYYY/MM/DD"');
        }
        para = date.replace(/-/g, "/");
        loacalTime = new Date(para).getTime();
        if (para.indexOf(':') !== -1) {
            localOffset = 0
        } else {
            localOffset = new Date(para).getTimezoneOffset() * 60000;
        }
    } else {
        loacalTime = new Date().getTime();
        localOffset = 0;
    }
    if (utc) {
        return loacalTime - localOffset;
    } else {
        return loacalTime;
    }
}
/**
 * 将元素内容转成数组[{x:'',y:'',z:''}],主要用于axLightbox
 */
const axCreateData = (
    src,
    roles = ['src', 'cover', 'caption', 'type'],
    node = 'figure',
    keys = ['media', 'cover', 'caption', 'type'],
    dft = ['', '', '', 'image'],
    callback
) => {
    let data = [],
        string = '';
    /* 
        if (axTypeIs('Array', src)) {
            string = JSON.stringify(src);
        } else if (axTypeIs('Object', src)) {
            string = JSON.stringify(src)
        } else if (axTypeIs('String', src)) {
            if (src.substr(0, 1) == '#') {
                data = axTplToArr(src, roles, keys, node, dft)
            } else {
                data = axStrToArr(src, keys, dft);
            }
        } */
    if (axTypeIs('String', src) && src.substr(0, 1) == '#') {
        data = axTplToArr(src, roles, keys, node, dft)
    } else {
        if (axTypeIs('Array', src) || axTypeIs('Object', src)) {
            string = JSON.stringify(src);
        } else if (axTypeIs('String', src)) {
            string = src;
        }
        data = axStrToArr(string, keys, dft);
    }
    callback && callback(data);
    return data;
}
/**
 * 获得多值字段的值并转为数组，适用于radio、checkbox、select-multiple、file以及带multiple的文本字段
*/
const axValuesToArr = (name, type) => {
    if (!name) {
        console.error('The name of input is required!');
        return;
    }
    let input = typeof name == 'string' ? document.querySelector('[name = ' + name + ']') : name;
    if (type == 'checkbox' || type == 'radio') {
        if (typeof name != 'string') {
            console.error('The name must be of type string!');
            return;
        }
        let inputs = document.getElementsByName(name),
            values = [];
        inputs.forEach((item) => {
            let value = item.value.trim();
            if (item.checked && value) {
                values.push(value)
            }
        })
        return values;
    } else if (type == 'select-multiple') {
        let options = input.querySelectorAll('option'),
            values = [];
        options.forEach((item) => {
            let value = item.value.trim();
            if (item.selected && value) {
                values.push(value)
            }
        })
        return values;
    } else if (type == 'file') {
        let files = Array.prototype.slice.call(input.files);
        return files;
    } else {
        let value = input.value.trim(),
            values = value.split(","),
            filtered = values.filter(function (item) {
                return item != null;
            });
        return filtered;
    }
}
/*!
 * 定义cookie方法
 * 支持axCookie.set、axCookie.get、axCookie.del三个方法
 * set方法支持options参数，支持追加path、domain、secure和sameSite属性
 * 默认过期时间是365天
 */
 class AXCOOKIE{
    set(name,value,options={type:'d',expires:365}){
        if(!name){
            console.error('The name of cookie can not be empty!');
            return false;
        }
        let now = new Date(),
        opt = Object.assign({},options),
        string = opt.path?';path='+opt.path:'';
        string += opt.domain?';domain='+opt.domain:'';
        string += opt.secure?';secure='+opt.secure:'';
        string += opt.sameSite?';sameSite='+opt.sameSite:'';
        if(opt.type == 'second' || opt.type == 's'){
            now.setSeconds(now.getSeconds() + ~~opt.expires);
            opt.expires = now.toUTCString();
        }else if(opt.type == 'minute' || opt.type == 'm'){
            now.setMinutes(now.getMinutes() + ~~opt.expires);
            opt.expires = now.toUTCString();
        }else if(opt.type == 'hour' || opt.type == 'h'){
            now.setHours(now.getHours() + ~~opt.expires);
            opt.expires = now.toUTCString();
        }else{
            now.setDate(now.getDate() + ~~opt.expires);
            opt.expires = now.toUTCString();
        }
        document.cookie = name + "=" + encodeURIComponent(value) + ";expires=" + opt.expires + string;
    }
    get(name){
        let cookieArr = document.cookie.replace(/;\s*/,';').split(';');
        let value ='';
        for(let i = 0; i < cookieArr.length;i++){
            let k = cookieArr[i].split('=')[0],
                v = cookieArr[i].split('=')[1];
             if(k == name){
                value = v;
                break;
             }
        }
        if(value){
            return decodeURIComponent(value);
        }else{
            return false;
        }
    }
    del(name){
        document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT";
    }
}
const axCookie = new AXCOOKIE();
/*!
 * 插件：表单校验；使用方法：new axValid('#id',{参数})
 */
const axValids = [];
class axValid {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        if (!this.targetDom.getAttribute('name')) {
            console.error('The element to be verified must have a name attribute!');
            return false;
        }
        this.options = axExtend({
            label: '',
            mode: 'newline', 
            url: '', 
            iconShow: true, 
            type: '', 
            label: '', 
            parent: null,
            error: '', 
            success: '通过验证！', 
            rule: {}, 
            number: '', 
            max: '', 
            min: '', 
            length: '', 
            maxLength: '', 
            minLength: '', 
            include: [], 
            exclude: [], 
            date: '', 
            earliest: '', 
            latest: '', 
            compare: null, 
            compareLabel: '', 
            least: 0, 
            most: 0, 
            format: '', 
            inputSuccess: 'ax-check-primary', 
            inputError: 'ax-check-danger', 
            boxSuccess: 'ax-color-primary', 
            boxError: 'ax-color-danger', 
            chars: '~!@#', 
            charsShow: false, 
            trigger: 'blur', 
            onTrigger: '', 
            onChange: '',
            onInit: '',
        }, options, this.targetDom);
        if (this.options.parent) {
            this.parent = axIdToDom(this.options.parent);
        } else {
            this.parent = this.targetDom.closest('form') ? this.targetDom.closest('form') : document;
        }
        if (typeof this.options.compare == 'string') {
            this.compare = this.parent.querySelector('[name=' + this.options.compare + ']');
        } else {
            this.compare = this.options.compare;
        }
        if (this.options.compareLabel) {
            this.compareLabel = this.options.compareLabel;
        } else {
            if (this.compare && this.compare.getAttribute('data-label')) {
                this.compareLabel = this.compare.getAttribute('data-label');
            }
        }
        this.handlers = {};
        this.strong = 0;
        this.msgBox = axAddElem('div', { 'valid': '' });
        this.value = null;
        this.label = this.options.label;
        this.name = this.targetDom.getAttribute('name');
        this.type = this.targetDom.getAttribute('type') ? this.targetDom.getAttribute('type') : this.targetDom.type;
        this.text = '';
        this.verified = null;
        this.verifieds = [];
        this.getRules();
        this.strongParse = this.parseFormat();
        this.checks = {
            /**
             * 为空校验，不填则直接返回结果
             */
            required: function (value) {
                if (value) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label ? this.label + '是必填项！' : '这是必填项！' };
                }
            },
            /**
             * 特定字符串校验
             */
            email: function (value) {
                let pattern = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/;
                return this.doTest(pattern, value, '请填写正确的邮箱！');
            },
            telephone: function (value) {
                let pattern = /^[1][3456789][0-9]{9}$/;
                return this.doTest(pattern, value, '请填写11位手机号！');
            },
            landline: function (value) {
                let pattern = /^([0-9]{3,4}-)?[0-9]{7,8}$/;
                return this.doTest(pattern, value, '请填写正确的座机号码！');
            },
            ip: function (value) {
                let pattern = /^\d+\.\d+\.\d+\.\d+$/;
                return this.doTest(pattern, value, '请填写正确的IP地址！');
            },
            plate: function (value) {
                let pattern = '';
                if (value.length == 8) {
                    pattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}(([0-9]{5}[DF]$)|([DF][A-HJ-NP-Z0-9][0-9]{4}$))/;
                } else {
                    pattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]{1}$/;
                }
                return this.doTest(pattern, value, '请填写正确的车牌号！');
            },
            idCard: function (value) {
                let pattern = /^(([1][1-5])|([2][1-3])|([3][1-7])|([4][1-6])|([5][0-4])|([6][1-5])|([7][1])|([8][1-2]))\d{4}(([1][9]\d{2})|([2]\d{3}))(([0][1-9])|([1][0-2]))(([0][1-9])|([1-2][0-9])|([3][0-1]))\d{3}[0-9xX]$/;
                return this.doTest(pattern, value, '请填写正确的身份证号！');
            },
            zip: function (value) {
                let pattern = /^\d{6}$/;
                return this.doTest(pattern, value, '只能填写6位数字邮编！');
            },
            url: function (value) {
                let pattern = /^(?=^.{3,255}$)(http(s)?:\/\/)?(www\.)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+(:\d+)*(\/\w+\.\w+)*$/;
                return this.doTest(pattern, value, '请填写正确的域名！');
            },
            /**
             * 字符类型校验
             */
            chinese: function (value) {
                let pattern = /^[\u0391-\uFFE5]+$/;
                return this.doTest(pattern, value, this.label + '只能填写中文！');
            },
            letter: function (value) {
                let pattern = /^[a-zA-Z]+$/;
                return this.doTest(pattern, value, this.label + '只能填写大小写英文字母！');
            },
            string: function (value) {
                let pattern = /^[a-zA-Z0-9]+$/;
                return this.doTest(pattern, value, this.label + '只能填写大小写英文字母和数字！');
            },
            password: function (value) {
                let pattern = new RegExp('^[a-zA-Z0-9' + this.options.chars + ']+$');
                return this.doTest(pattern, value, this.label + '只能填写大小写英文字母、数字以及特殊字符！');
            },
            /** 
             *日期格式校验
             */
            ymdhms: function (value) {
                let pattern = /^(\d{4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2022-11-13 2:56:12的日期格式！');
            },
            ymd: function (value) {
                let pattern = /^(\d{4})(-|\/)(\d{1,2})\2(\d{1,2})$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2022-11-13的日期格式！');
            },
            hms: function (value) {
                let pattern = /^((20|21|22|23|[0-1]\d)\:[0-5][0-9])(\:[0-5][0-9])?$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2:56:12的日期格式！');
            },
            ym: function (value) {
                let pattern = /^(\d{4})(-|\/)(\d{1,2})$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2022-11的日期格式！');
            },
            y: function (value) {
                let pattern = /^(\d{4})$/;
                return this.doTest(pattern, value, this.label + '只能填写4位数字年份！');
            },
            m: function (value) {
                let pattern = /^(0?[1-9]|1[0-2])$/;
                return this.doTest(pattern, value, this.label + '只能填写1~12月份！');
            },
            d: function (value) {
                let pattern = /^((0?[1-9])|((1|2)[0-9])|30|31)$/;
                return this.doTest(pattern, value, this.label + '只能填写1~31日！');
            },
            date: function (value) {
                let ymdhms = /^(\d{4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/,
                    ymd = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/,
                    ym = /^(\d{1,4})(-|\/)(\d{1,2})$/,
                    y = /^(\d{4})$/;
                if (ymdhms.test(value) || ymd.test(value) || ym.test(value) || y.test(value)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '请填写有效的日期！' };
                }
            },
            earlier: function (value) {
                if (!this.options.date || isNaN(Date.parse(this.options.date))) {
                    console.error('Please enter a valid target date!');
                    return;
                }
                if (isNaN(Date.parse(value))) {
                    console.error('The value is not a valid date!');
                    return;
                }
                let timestamp = axLocalTime(value),
                    target = axLocalTime(this.options.date);
                if (timestamp < target) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可晚于' + this.options.date + '！' };
                }
            },
            later: function (value) {
                if (!this.options.date || isNaN(Date.parse(this.options.date))) {
                    console.error('Please enter a valid target date!');
                    return;
                }
                if (isNaN(Date.parse(value))) {
                    console.error('The value is not a valid date!');
                    return;
                }
                let timestamp = axLocalTime(value),
                    target = axLocalTime(this.options.date);
                if (timestamp > target) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可早于' + this.options.date + '！' };
                }
            },
            dateRange: function (value) {
                if (!this.options.earliest || isNaN(Date.parse(this.options.earliest))) {
                    console.error('Please enter a valid earliest date!');
                    return;
                }
                if (!this.options.latest || isNaN(Date.parse(this.options.latest))) {
                    console.error('Please enter a valid latest date!');
                    return;
                }
                if (isNaN(Date.parse(value))) {
                    console.error('The value is not a valid date!');
                    return;
                }
                let timestamp = axLocalTime(value),
                    earliest = axLocalTime(this.options.earliest),
                    latest = axLocalTime(this.options.latest);
                if (timestamp > earliest && timestamp < latest) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可早于' + this.options.latest + '，且不可晚于' + this.options.earliest + '！' };
                }
            },
            /** 
             *数字校验
             */
            integer: function (value) {
                let pattern = /^[1-9]d*$/;
                return this.doTest(pattern, value, this.label + '只能填写非0开头的正整数！');
            },
            number: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                return this.doTest(pattern, value, this.label + '只能填写数字，包括正数、负数、整数、小数！');
            },
            moreThan: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value > this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要大于' + this.options.number + '！' };
                }
            },
            moreEqual: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value >= this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要大于或等于' + this.options.number + '！' };
                }
            },
            lessThan: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value < this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要小于' + this.options.number + '！' };
                }
            },
            lessEqual: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value <= this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要小于或等于' + this.options.number + '！' };
                }
            },
            equal: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value == this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要等于' + this.options.number + '！' };
                }
            },
            range: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value >= this.options.min && value < this.options.max) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要大于等于' + this.options.min + '并小于' + this.options.max + '！' };
                }
            },
            /*
             *字符长度校验
             */
            length: function (value) {
                let pattern = new RegExp('^.{' + this.options.length + '}$');
                return this.doTest(pattern, value, this.label + '只能填写' + this.options.length + '个字符！');
            },
            lengthMore: function (value) {
                let pattern = new RegExp('^.{' + this.options.length + ',}$');
                return this.doTest(pattern, value, this.label + '字符数量不可少于' + this.options.length + '个！');
            },
            lengthLess: function (value) {
                let pattern = new RegExp('^.{0,' + this.options.length + '}$');
                return this.doTest(pattern, value, this.label + '字符数量不可多于' + this.options.length + '个！');
            },
            lengthRange: function (value) {
                let pattern = new RegExp('^.{' + this.options.minLength + ',' + this.options.maxLength + '}$');
                return this.doTest(pattern, value, this.label + '字符数量不可少于' + this.options.minLength + '个，而且不可多于' + this.options.maxLength + '个！');
            },
            /**
             * 包含与否检验
             */
            include: function (value) {
                if (axIsEmpty(this.options.include)) {
                    console.error('The array of include can not be empty!');
                    return;
                }
                if (this.options.include.includes(value)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '填写的值在指定内容中不存在！' };
                }
            },
            exclude: function (value) {
                if (axIsEmpty(this.options.exclude)) {
                    console.error('The array of exclude can not be empty!');
                    return;
                }
                if (!this.options.exclude.includes(value)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可填写该值！' };
                }
            },
            /**
             * 强度校验
             */
            strong: function (value) {
                if (!this.options.format) {
                    console.error(axError.formatError);
                    return;
                }
                this.getStrong(value);
                let pattern = new RegExp(this.strongParse.pattern);
                return this.doTest(pattern, value, this.strongParse.message);
            },
            /**
             * 异步校验，需要配合this.options.url参数
             */
            asyn: function (value) {
                if (!this.options.format) {
                    console.error(axError.formatError);
                    return;
                }
                this.getStrong(value);
                let pattern = new RegExp(this.strongParse.pattern);
                return this.doTest(pattern, value, this.strongParse.message);
            },
            /**
             * 选择数量校验，radio、checkbox、select使用
             */
            oneChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (value.length > 0) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '至少选择1项！' };
                }
            },
            leastChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (!this.options.least || value.length >= this.options.least) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '至少选择' + this.options.least + '项！' };
                }
            },
            mostChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (!this.options.most || value.length <= this.options.most) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '最多选择' + this.options.most + '项！' };
                }
            },
            checkedRange: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (this.options.least && this.options.most && this.options.most > this.options.least) {
                    if (value.length >= this.options.least && value.length <= this.options.most) {
                        return { verified: true, message: '' };
                    } else {
                        return { verified: false, message: this.label + '至少选择' + this.options.least + '项，且不能多于' + this.options.most + '项！' };
                    }
                } else {
                    console.error(axError.paraError);
                    return;
                }
            },
            /**
             * 对比校验
            */
            same: function (value) {
                if (!this.compare) {
                    console.error(axError.noNode);
                    return;
                }
                if (value == this.compare.value) {
                    return { verified: true, message: '' };
                } else {
                    let info = this.compareLabel ? this.label + '与' + this.compareLabel + '不一致！' : '两个字段值不一致！';
                    return { verified: false, message: info };
                }
            },
        }
        Object.assign(this.checks, this.options.extend);
        this.init()
    }
    init(callback) {
        let _this = this;
        let info = { dom: this.targetDom, name: this.name, instance: this };
        if (axIsEmpty(axValids)) {
            if (this.parent) {
                axValids.push({ parent: this.parent, children: [info] });
            }
        } else {
            if (axValids.some(item => (item.parent == this.parent))) {
                let index = axValids.findIndex(i => (i.parent == this.parent)),
                    infoArr = axValids[index].children;
                if (infoArr.some(i => (i.name == this.name))) {
                    for (let k = 0; k < infoArr.length; k++) {
                        if (infoArr[k].name == this.name) {
                            infoArr[k] = info;
                            break;
                        }
                    }
                } else {
                    infoArr.push(info);
                }
            } else {
                axValids.push({ parent: this.parent, children: [info] });
            }
        }
        /* 
        axValids的最终格式如下：
        [
            {
                parent:'', children: [
                    { dom: '', name: '', instance: '', verified: '' },
                    { dom: '', name: '', instance: '', verified: '' },
                ]
            },
            {
                parent:'', children: [
                    { dom: '', name: '', instance: '', verified: '' },
                    { dom: '', name: '', instance: '', verified: '' },
                ]
            },
            ...
        ] 
        以parent循环监听submit事件，以dom和instance执行校验，以name去重，以verfied确认表单验证是否全部通过
        */
        /**
         * 触发校验
         * */
        let checkFun = function () {
            if (!axIsEmpty(_this.options.extend)) {
                for (let i in _this.options.extend) {
                    _this.rules[i] = ['', _this.options.success]
                }
            }
            let value = '';
            if (_this.type == 'radio' || _this.type == 'checkbox' || _this.type == 'select-multiple' || _this.type == 'file') {
                value = axValuesToArr(_this.name, _this.type);
            } else {
                value = _this.targetDom.value.trim();
            }
            let len = Object.keys(_this.rules).length,
                index = 0;
            _this.value = value;
            for (let i in _this.rules) {
                index++;
                if (axIsEmpty(value)) {
                    if (i == 'required') {
                        !_this.rules[i][0] ? _this.text = _this.checks.required.call(_this).message : _this.text = _this.rules[i][0];
                        _this.verified = false;
                        break;
                    } else {
                        _this.text = _this.rules[i][1];
                        _this.verified = true;
                    }
                } else {
                    if (_this.options.type) {
                        let result = _this.checks[i].call(_this, value);
                        if (!result.verified) {
                            !_this.rules[i][0] ? _this.text = result.message : _this.text = _this.rules[i][0];
                            _this.verified = false;
                            break;
                        } else {
                            if (index == len) {
                                _this.text = _this.rules[i][1];
                                _this.verified = true;
                            }
                        }
                    }
                }
            }
            if (_this.options.url && !_this.options.type) {
                axAjax({
                    url: _this.options.url,
                    data: { name: _this.name, value: _this.value, parent: _this.parent },
                    type: 'post',
                    success: function (content) {
                        _this.verified = content.verified;
                        _this.text = content.text;
                        _this.refreshDom(_this.options.mode);
                        info.verified = _this.verified;
                        callback && callback.call(_this, _this.verified, _this.text, _this.strong);
                        _this.options.onInit && _this.options.onInit.call(_this, _this.verified, _this.text, _this.strong);
                    },
                })
            } else {
                _this.refreshDom(_this.options.mode);
                info.verified = _this.verified;
                callback && callback.call(_this, _this.verified, _this.text, _this.strong);
                _this.options.onInit && _this.options.onInit.call(_this, _this.verified, _this.text, _this.strong);
            }
            _this.options.onTrigger && _this.options.onTrigger.call(_this, _this.strong, _this.verified, _this.text);
            _this.verifieds.unshift(_this.verified);
            if (_this.verifieds.length >= 2) {
                if (_this.verifieds.length > 2) {
                    _this.verifieds.splice(2);
                }
                if (_this.verifieds[0] != _this.verifieds[1]) {
                    _this.options.onChange && _this.options.onChange.call(_this, _this.strong, _this.verified, _this.text);
                    'change' in _this.handlers ? _this.emit('change', _this.verified, _this.text, _this.strong) : null;
                }
            }
        }
        if (this.options.trigger == 'submit') {
            checkFun();
        } else {
            this.targetDom.addEventListener(this.options.trigger, checkFun, false);
        }
    }
    parseFormat() {
        if (this.options.format) {
            let upperLen = '', 
                lowerLen = '', 
                numberLen = '', 
                charLen = '', 
                cnLen = '', 
                formatMin = '', 
                formatMax = '', 
                onlyName = {},
                scaleNameGroup = [],
                scaleName = {},
                scale = '',
                regExp = '',
                regText = [],
                message = '',
                lengthOnly = null,
                formatType = '',
                formatLength = '',
                formatScale = '';
            formatType = this.options.format.split("#")[0];
            if (this.options.format.split("#")[1]) {
                formatLength = this.options.format.split("#")[1];
                formatMin = formatLength.split(",")[0];
                if (formatLength.indexOf(',') == -1) {
                    lengthOnly = true;
                    formatMax = '';
                } else if (formatLength.indexOf(',') !== -1 && formatLength.split(",")[1]) {
                    formatMax = formatLength.split(",")[1];
                } else {
                    formatMax = '';
                }
            } else {
                formatMin = '';
                formatMax = '';
            }
            if (this.options.format.split("#")[2]) {
                formatScale = this.options.format.split("#")[2];
                if (formatScale.indexOf('a') !== -1) {
                    scaleName.lower = '小写字母';
                    scale += 'a-z';
                    regText.push('a-z');
                    scaleNameGroup.push(scaleName.lower);
                }
                if (formatScale.indexOf('A') !== -1) {
                    scaleName.upper = '大写字母';
                    scale += 'A-Z';
                    regText.push('A-Z');
                    scaleNameGroup.push(scaleName.upper);
                }
                if (formatScale.indexOf('9') !== -1) {
                    scaleName.number = '数字';
                    scale += '0-9';
                    regText.push('0-9');
                    scaleNameGroup.push(scaleName.number);
                }
                if (formatScale.indexOf('~') !== -1) {
                    scaleName.char = this.options.charsShow ? '特殊字符"' + this.options.chars + '"' : '特殊字符';
                    scale += this.options.chars;
                    regText.push(this.options.chars);
                    scaleNameGroup.push(scaleName.char);
                }
                if (formatScale.indexOf('中') !== -1) {
                    scaleName.cn = '中文';
                    scale += '\u4e00-\u9fa5';
                    regText.push('\u4e00-\u9fa5');
                    scaleNameGroup.push(scaleName.cn);
                }
                if (scaleNameGroup.length > 2) {
                    scaleNameGroup = axRangeReplace(scaleNameGroup.join(), '和', scaleNameGroup.join().lastIndexOf(','));
                } else {
                    scaleNameGroup = scaleNameGroup.join()
                }
                scaleNameGroup = scaleNameGroup.replaceAll(',', '、');
                !axIsEmpty(scaleNameGroup) ? message += '必须是' + scaleNameGroup + '，并且要求' : null;
            }
            if (axIsEmpty(this.options.format.split("#")[0]) && this.options.format.split("#")[3]) {
                if (this.options.format.split("#")[3] < formatScale.length && this.options.format.split("#")[3] > 0) {
                    if (this.options.format.split("#")[3] == 2) {
                        regText.forEach(item => {
                            regExp += '(?![' + item + ']+$)';
                        });
                    } else if (this.options.format.split("#")[3] == 3) {
                        axArrange(regText, 2).forEach(item => {
                            regExp += '(?![' + item.join().replaceAll(',', '') + ']+$)';
                        });
                    } else if (this.options.format.split("#")[3] == 4) {
                        axArrange(regExp, 3).forEach(item => {
                            regExp += '(?![' + item.join().replaceAll(',', '') + ']+$)';
                        });
                    }
                } else {
                    console.error('随机字符类型必须有1种，并且不能超过允许字符类型范围！');
                }
                message = scaleNameGroup + '中至少选择' + this.options.format.split("#")[3] + '种字符。';
            }
            if (formatType.indexOf('a') !== -1) {
                let index = formatType.lastIndexOf("a");
                onlyName.lower = '小写字母';
                lowerLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.lower + '至少' + lowerLen + '个，';
            }
            if (formatType.indexOf('A') !== -1) {
                let index = formatType.lastIndexOf("A");
                onlyName.upper = '大写字母';
                upperLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.upper + '至少' + upperLen + '个，';
            }
            if (formatType.indexOf('9') !== -1) {
                let index = formatType.lastIndexOf("9");
                onlyName.number = '数字';
                numberLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.number + '至少' + numberLen + '个，';
            }
            if (formatType.indexOf('~') !== -1) {
                let index = formatType.lastIndexOf("~");
                onlyName.char = this.options.charsShow ? '特殊字符"' + this.options.chars + '"' : '特殊字符';
                charLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.char + '至少' + charLen + '个。';
            }
            if (formatType.indexOf('中') !== -1) {
                let index = formatType.lastIndexOf("中");
                onlyName.cn = '中文';
                cnLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.cn + '至少' + cnLen + '个。';
            }
            lowerLen ? regExp += '(?=' + Array(lowerLen + 1).join('.*?[a-z]') + ')' : null;
            upperLen ? regExp += '(?=' + Array(upperLen + 1).join('.*?[A-Z]') + ')' : null;
            numberLen ? regExp += '(?=' + Array(numberLen + 1).join('.*?[0-9]') + ')' : null;
            charLen ? regExp += '(?=' + Array(charLen + 1).join('.*?[' + this.options.chars + ']') + ')' : null;
            cnLen ? regExp += '(?=' + Array(cnLen + 1).join('.*?[\u4e00-\u9fa5]') + ')' : null;
            if (!axIsEmpty(scale)) {
                if (formatMin) {
                    regExp += '[' + scale + ']';
                } else {
                    regExp += '[' + scale + ']+';
                }
            } else if (axIsEmpty(scale) && formatMin) {
                regExp += '.'
            } else {
                regExp += '.{0,}'
            }
            if (formatMin && lengthOnly && !formatMax) {
                regExp += '{' + formatMin + '}';
                message += '总共只能是' + formatMin + '个字符。';
            } else if (formatMin && !formatMax) {
                regExp += '{' + formatMin + ',}';
                message += '总共至少' + formatMin + '个字符。';
            } else if (formatMin && formatMax) {
                regExp += '{' + formatMin + ',' + formatMax + '}';
                message += '总共至少' + formatMin + '个字符，且不能超过' + formatMax + '个字符。';
            }
            regExp = '^' + regExp + '$';
            return { pattern: regExp, message: message }
        } else {
            return {}
        }
    }
    getStrong(value) {
        let upVal = 0,
            lowVal = 0,
            numVal = 0,
            charVal = 0,
            cnVal = 0,
            lenVal = 0;
        if (this.options.format) {
            let minLength = this.options.format.split("#")[1].split(",")[0];
            if (value && value.match(new RegExp('[a-z]'))) { lowVal = 1; };
            if (value && value.match(new RegExp('[A-Z]'))) { upVal = 1; };
            if (value && value.match(new RegExp('[0-9]'))) { numVal = 1; }
            if (value && value.match(new RegExp('[' + this.options.chars + ']'))) { charVal = 1; };
            if (value && value.match(new RegExp('[\u4e00-\u9fa5]'))) { cnVal = 1; }
            if (value && minLength && value.length >= minLength) { lenVal = 1; };
        }
        this.strong = upVal + lowVal + numVal + charVal + cnVal + lenVal;
        return this.strong;
    }
    doTest(pattern, value, message) {
        if (pattern.test(value)) {
            return { verified: true, message: '' };
        } else {
            return { verified: false, message: message };
        }
    }
    getRules() {
        this.rules = {};
        let types = this.options.type.trim().split(",");
        if (types[0] != 'required' && types.includes('required')) {
            for (let i = 0; i < types.length; i++) {
                if (types[i] === 'required') {
                    types.splice(i, 1);
                    break;
                }
            }
            types.unshift('required');
        }
        types.forEach(item => {
            this.rules[item] = ['', ''];
            if (!axIsEmpty(this.options.rule)) {
                this.options.rule[item] ? this.rules[item] = this.options.rule[item] : null;
            }
            !this.rules[item][0] ? this.rules[item][0] = this.options.error : null;
            !this.rules[item][1] ? this.rules[item][1] = this.options.success : null;
        });
        return this.rules;
    }
    refreshText() {
        let icon = this.verified ? axIcon.font.successFill : axIcon.font.errorFill;
        if (this.options.iconShow) {
            this.msgBox.innerHTML = icon + ' ' + this.text;
        } else {
            this.msgBox.innerHTML = this.text;
        }
    }
    refreshDom(mode) {
        let _this = this,
            classToggle = function () {
                if (_this.verified) {
                    _this.msgBox.classList.remove(_this.options.boxError)
                    _this.msgBox.classList.add(_this.options.boxSuccess)
                    _this.targetDom.classList.remove(_this.options.inputError);
                    _this.targetDom.classList.add(_this.options.inputSuccess);
                } else {
                    _this.msgBox.classList.remove(_this.options.boxSuccess)
                    _this.msgBox.classList.add(_this.options.boxError)
                    _this.targetDom.classList.remove(_this.options.inputSuccess);
                    _this.targetDom.classList.add(_this.options.inputError);
                }
            };
        this.refreshText();
        if (this.options.mode.nodeType == 1 || mode.substr(0, 1) == "#") {
            let dom = axIdToDom(mode);
            if (!this.msgBox.parentNode) {
                dom.appendChild(this.msgBox);
            }
            classToggle();
        } else if (mode == 'note') {
            this.msgBox.classList.add('ax-form-txt');
            let parent = this.targetDom.closest('.ax-form-con'),
                brother = parent.nextElementSibling;
            if (this.type == 'raido' || this.type == 'checkbox') {
                if (brother && brother.hasAttribute('valid')) {
                    brother.remove();
                }
                parent.insertAdjacentElement('afterend', this.msgBox);
            } else {
                if (brother != this.msgBox) {
                    parent.insertAdjacentElement('afterend', this.msgBox);
                }
            }
            classToggle();
        } else if (mode == 'popup') {
            if (!this.popup) {
                this.popup = new axPopup(this.targetDom.closest('.ax-form-input'), {
                    content: _this.msgBox,
                    padding: false,
                    placement: 'bottom-start',
                    offsetShow: false,
                    arrow: false,
                    close: false,
                    footerShow: false,
                    theme: 'crude',
                    stay: true,
                }).show();
            } else {
                this.popup.content.innerHTML = '';
                this.popup.content.appendChild(this.msgBox);
            }
            classToggle();
        } else if (mode == 'message') {
            if (!this.verified) {
                new axMessage({
                    content: _this.text,
                    result: 'error',
                    iconShow: _this.options.iconShow,
                });
            } else {
                new axMessage({
                    content: _this.text,
                    result: 'success',
                    iconShow: _this.options.iconShow,
                });
            }
        } else {
            let brother = this.targetDom.closest('.ax-form-input');
            if (this.type == 'radio' || this.type == 'checkbox') {
                if (brother.nextElementSibling && brother.nextElementSibling.hasAttribute('valid')) {
                    brother.nextElementSibling.remove();
                }
                brother.insertAdjacentElement('afterend', this.msgBox);
            } else {
                if (brother != this.msgBox) {
                    brother.insertAdjacentElement('afterend', this.msgBox);
                }
            }
            this.msgBox.classList.add('ax-valid');
            classToggle();
        }
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/**
 * 点击提交表单校验，通常是对button使用js提交的时候使用
 * e：通常是window
 * data：数组数据，格式为：[{parent:'',children:{name:'',verified:'',text:''}},{}]
 * outer:表单项的父层，可以是form节点，也可以是某div节点，但是必须与表单项的父节点一致，所以建议是form节点
 * callback：校验成功后执行回调函数
 * interval：表单项校验的间隔时间，纯是为了显示逐个校验效果，默认100毫秒
*/
const axValidRepeat = (e, data, outer, callback, interval = 100) => {
    if (!outer) {
        console.error('A form node must be filled in!');
        return false;
    }
    if (axIsEmpty(data)) {
        console.error(axError.required);
        return false;
    }
    if (axIsEmpty(data.filter(i => i.parent == outer))) {
        console.error('No submittable form found!');
        return false;
    }
    let formValids =  [...axValids],
        children = formValids.filter(item => item.parent == outer)[0].children,
        k = 0,
        judge = () => {
            let form = axValids.filter(i => i.parent == outer)[0];
            if (form.children.some(i => !i.verified)) {
                axPreventDefault(e);
            } else {
                callback && callback();
            }
        };
    children.forEach((i, index) => {
        i.instance.options.trigger = 'submit';
        setTimeout(() => {
            k++;
            i.instance.init(function () {
                if (k == children.length) {
                    judge();
                }
            });
        }, interval * index);
    });
}
(() => {
    [...document.querySelectorAll('[axValid]')].filter(item => {
        return item.getAttribute('name');
    }).forEach(item => {
        new axValid(item);
    });
    if (!axIsEmpty(axValids)) {
        let formValids = [...axValids];
        formValids.forEach(item => {
            if (item.parent.nodeName == 'FORM') {
                item.parent.addEventListener("submit", function (e) {
                    axPreventDefault(e);
                    let children = item.children,
                        k = 0,
                        judge = () => {
                            let form = axValids.filter(i => i.parent == this)[0];
                            if (!form.children.some(i => !i.verified)) {
                                this.submit();
                            }
                        };
                    children.forEach((i, index) => {
                        i.instance.options.trigger = 'submit';
                        setTimeout(() => {
                            k++;
                            i.instance.init(function () {
                                if (k == children.length) {
                                    judge();
                                }
                            });
                        }, 100 * index)
                    });
                }, false);
            }
        })
    }
})();
/*!
* 插件：定义效果更好Hover操作；使用方法：new axHover('#id',{参数})
*/
class axHover {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            timeout: 50,
            interval: 80,
            sensitivity: 7,
            enter: () => { },
            leave: () => { },
            hold: '',
        }, options);
        let _this = this;
        this.curX;
        this.curY;
        this.preX;
        this.preY;
        this.countTimer;
        this.leaveTimer;
        this.isActive = false;
        this.options.hold ? this.hold = axIdToDom(this.options.hold) : this.hold = '';
        this.track = (ev) => {
            _this.curX = ev.pageX;
            _this.curY = ev.pageY;
        };
        this.compare = (elem, ev) => {
            let distX = _this.preX - _this.curX,
                distY = _this.preY - _this.curY,
                distance = Math.sqrt(distX * distX + distY * distY);
            if (distance < _this.options.sensitivity) {
                clearTimeout(_this.leaveTimer);
                if (_this.isActive) {
                    _this.options.leave.call(_this, elem, ev);
                    _this.isActive = false;
                }
                _this.options.enter.call(_this, elem, ev);
                _this.isActive = true;
            } else {
                _this.preX = _this.curX;
                _this.preY = _this.curY;
                _this.countTimer = setTimeout(() => {
                    _this.compare(elem, ev);
                }, _this.options.interval);
            }
        };
        this.init();
    }
    init() {
        let _this = this;
        this.targetDom.addEventListener('mousemove', this.track);
        this.targetDom.addEventListener('mouseenter', function (ev) {
            let elem = this;
            _this.preX = ev.pageX;
            _this.preY = ev.pageY;
            if (_this.isActive) {
                clearTimeout(_this.leaveTimer);
                return;
            }
            _this.countTimer = setTimeout(function () {
                _this.compare(elem, ev);
            }, _this.options.interval);
        });
        this.targetDom.addEventListener('mouseleave', function (ev) {
            let elem = this;
            clearTimeout(_this.countTimer);
            if (!_this.isActive) {
                return;
            }
            _this.leaveTimer = setTimeout(function () {
                _this.options.leave.call(_this, elem, ev);
                _this.isActive = false;
            }, _this.options.timeout);
        });
        if (this.hold) {
            this.hold.onmouseenter = function (ev) {
                if (_this.leaveTimer) clearTimeout(_this.leaveTimer)
                _this.options.enter.call(_this, _this.targetDom, ev);
            }
            this.hold.onmouseleave = function (ev) {
                clearTimeout(_this.countTimer);
                _this.leaveTimer = setTimeout(function () {
                    _this.options.leave.call(_this, _this.targetDom, ev);
                    _this.isActive = false;
                }, _this.options.timeout);
            }
        }
    };
}
/*!
 * 插件：查看更多；使用方法：new axMore('#id',{参数})
 */
const axMores = [];
class axMore {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            length: 60,
            textFold: '展开',
            textUnfold: '收起',
            classFold: 'ax-color-primary',
            classUnfold: 'ax-color-primary',
        }, options, this.targetDom);
        this.handlers = {};
        this.html = this.targetDom.innerHTML;
        this.pureHtml = this.targetDom.textContent;
        let _this = this,
            more = true;
        this.event = function() {
            if (more) {
                _this.targetDom.removeChild(this.previousSibling);
                this.innerHTML = _this.options.textUnfold;
                this.setAttribute('class', _this.options.classUnfold);
                this.insertAdjacentHTML('beforeBegin', _this.text);
                more = false;
                'unfold' in _this.handlers ? _this.emit('unfold', '') : null;
            } else {
                _this.targetDom.removeChild(this.previousSibling);
                this.innerHTML = _this.options.textFold;
                this.setAttribute('class', _this.options.classFold);
                this.insertAdjacentHTML('beforeBegin', _this.ell);
                more = true;
                'fold' in _this.handlers ? _this.emit('fold', '') : null;
            }
        };
        !!this.targetDom.getAttribute('axMore') ? this.referName = this.targetDom.getAttribute('axMore') : this.referName = '';
        this.init();
    }
    init() {
        this.text = this.pureHtml.trim().replace(/<[^>]+>/g, '').replace(/ +/g, ' ');
        this.ell = this.text.substring(0, this.options.length) + '...';
        let _this = this,
            textLength = [...this.text].length,
            link = `<a href="###" class="${this.options.classFold}">${this.options.textFold}</a>`;
        if (textLength > this.options.length) {
            this.targetDom.innerHTML = this.ell + link;
        }
        this.targetDom.lastChild.onclick = this.event;
        if (this.referName) {
            if (axIsEmpty(axMores)) {
                axMores.push({ name: this.referName, instance: this });
            } else {
                if (!axMores.some(item => (item.name == this.referName))) {
                    axMores.push({ name: this.referName, instance: this });
                }
                /*  for (let i = 0; i < axMores.length; i++) {
                     if (axMores[i].name == this.referName) {
                         axMores[i].instance = this;
                         break;
                     } else {
                         axMores.push({ name: this.referName, instance: this });
                     }
                 } */
            }
        }
        'load' in this.handlers ? this.emit('load', '') : null;
        return this;
    }
    destroy(callback) {
        this.targetDom.lastChild.removeEventListener('click', this.event, false);
        this.targetDom.innerHTML = this.html;
        callback && callback.call(this);
    }
    updateContent(text, callback) {
        let _this = this;
        if ((typeof text) === 'string') {
            if (text.substr(0, 1) == "#") {
                text = document.querySelector(text).textContent;
            } else {
                text = text;
            }
        } else {
            text = text.textContent;
        }
        this.pureHtml = text;
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    update(setting, callback) {
        let _this = this;
        this.options = axExtend(this.options, setting);
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axMore]').forEach(element => {
        new axMore(element);
    });
})();
/*!
 * 插件：手风琴折叠；使用方法：new axAccordion('#id',{参数})
 */
const axAccordions = [];
class axAccordion {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            index: '',
            cookie: '',
            active: '',
            disabled: '',
            multiple: false,
            collapse: true,
            trigger: 'click',
        }, options, this.targetDom);
        let _this = this;
        this.handlers = {};
        this.event = function (event) {
            let collapseBody = this.parentElement.querySelector('.ax-panel-body'),
                i = _this.elements.indexOf(this.parentElement);
            if (window.getComputedStyle(this.nextElementSibling).display === 'none') {
                'show' in _this.handlers ? _this.emit('show', i) : null;
                this.parentElement.classList.add('ax-show');
                axSlideDown(collapseBody, function () {
                    'shown' in _this.handlers ? _this.emit('shown', i) : null;
                });
                if (_this.options.cookie) {
                    axCookie.set(_this.options.cookie, i);
                }
                if (_this.options.multiple == false) {
                    axSiblings(this.parentElement, '', '.ax-item').forEach(item => {
                        axSlideUp(item.querySelector('.ax-panel-body'));
                        item.classList.remove('ax-show');
                    })
                }
            } else {
                'hide' in _this.handlers ? _this.emit('hide', i) : null;
                this.parentElement.classList.remove('ax-show');
                axSlideUp(collapseBody, function () {
                    'hidden' in _this.handlers ? _this.emit('hidden', i) : null;
                });
                if (_this.options.cookie) {
                    axCookie.set(_this.options.cookie, '');
                }
            }
            event.stopPropagation();
        }
        !!this.targetDom.getAttribute('axAccordion') ? this.referName = this.targetDom.getAttribute('axAccordion') : this.referName = '';
        this.init();
    };
    init() {
        let _this = this,
            itemSelected = [],
            itemDisabled = [];
        if (this.options.active) {
            itemSelected = itemSelected.concat(axArrToDom(this.options.active));
        }
        let filterSelected = [...this.targetDom.children].filter(item => {
            return item.classList.contains('ax-show');
        });
        if (filterSelected) {
            itemSelected = itemSelected.concat(filterSelected);
        }
        if (this.options.disabled) {
            itemDisabled = itemDisabled.concat(axArrToDom(this.options.disabled));
        }
        let filterDisabled = [...this.targetDom.children].filter(item => {
            return item.hasAttribute('disabled') || item.getAttribute('disabled') == 'true'
        });
        if (filterDisabled) {
            itemDisabled = itemDisabled.concat(filterDisabled);
        }
        this.elements = [...this.targetDom.children].filter(item => {
            return item.classList.contains('ax-item') && itemDisabled.indexOf(item) < 0;
        });
        if (this.options.index) {
            this.elements[this.options.index].classList.add('ax-show');
            axSlideDown(this.elements[this.options.index].querySelector('.ax-panel-body'));
        }
        if (!this.options.collapse) {
            for (let i = 0; i < this.elements.length; i++) {
                this.elements[i].classList.add('ax-show');
                axSlideDown(this.elements[i].querySelector('.ax-panel-body'));
            }
        }
        if (this.options.cookie) {
            let cookie = axCookie.get(this.options.cookie);
            if (cookie) {
                this.elements[cookie].classList.add('ax-show');
                axSlideDown(this.elements[cookie].querySelector('.ax-panel-body'))
            }
        }
        for (let i = 0; i < this.elements.length; i++) {
            let item = this.elements[i],
                collapseHeader = item.querySelector('.ax-panel-header'),
                collapseBody = item.querySelector('.ax-panel-body');
            if (itemSelected.indexOf(item) > -1) {
                item.classList.add('ax-show');
                axSlideDown(collapseBody);
            }
            if (itemDisabled.indexOf(item) < 0) {
                collapseHeader.addEventListener(this.options.trigger, this.event, false);
            } else {
                collapseHeader.removeEventListener(this.options.trigger, this.event, false);
            }
            let a = collapseHeader.querySelectorAll('a');
            for (let k = 0; k < a.length; k++) {
                a[k].addEventListener(this.options.trigger, function (event) {
                    event.stopPropagation();
                });
            }
        }
        if (this.referName) {
            if (axIsEmpty(axAccordions)) {
                axAccordions.push({ name: this.referName, instance: this });
            } else {
                if (!axAccordions.some(item => (item.name == this.referName))) {
                    axAccordions.push({ name: this.referName, instance: this });
                }
                /* for (let i = 0; i < axAccordions.length; i++) {
                    if (axAccordions[i].name == this.referName) {
                        axAccordions[i].instance = this;
                        break;
                    } else {
                        axAccordions.push({ name: this.referName, instance: this });
                    }
                } */
            }
        }
        'load' in this.handlers ? this.emit('load', '') : null;
    }
    destroy(callback) {
        let elements = [...this.targetDom.children].filter(item => {
            return item.classList.contains('ax-item');
        });
        elements.forEach(item => {
            item.querySelector('.ax-panel-header').removeEventListener(this.options.trigger, this.event, false);
        });
        callback && callback.call(this);
    }
    update(setting, callback) {
        let _this = this;
        this.options = axExtend(this.options, setting);
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
 document.querySelectorAll('[axAccordion]').forEach(element => {
    new axAccordion(element);
});
/*!
 * 插件：页签切换；使用方法：axTab('#id',{参数})
 */
const axTabs = [];
class axTab {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            index: '',
            cookie: '',
            trigger: 'click',
            disabled: '',
            active: 'ax-active',
            nav: '.ax-tab-nav',
            content: '.ax-tab-content',
        }, options, this.targetDom);
        let _this = this;
        this.handlers = {};
        this.event = function() {
            let i = [..._this.nav.children].indexOf(this);
            if (_this.options.cookie) {
                axCookie.set(_this.options.cookie, i);
            }
            for (let k = 0; k < axSiblings(this).length; k++) {
                axSiblings(this)[k].classList.remove(_this.options.active);
            }
            for (let k = 0; k < axSiblings(_this.content.children[i]).length; k++) {
                axSiblings(_this.content.children[i])[k].classList.remove(_this.options.active);
            }
            'show' in _this.handlers ? _this.emit('show', i) : null;
            this.classList.add(_this.options.active);
            _this.content.children[i].classList.add(_this.options.active);
        }
        !!this.targetDom.getAttribute('axTab') ? this.referName = this.targetDom.getAttribute('axTab') : this.referName = '';
        this.init();
    }
    init() {
        this.nav = this.targetDom.querySelector(this.options.nav);
        this.content = this.targetDom.querySelector(this.options.content);
        this.tabNum = Math.min.apply(null, [this.nav.children.length, this.content.children.length]);
        let _this = this,
            aDisabled = [];
        if (this.options.disabled) {
            aDisabled = aDisabled.concat(axArrToDom(this.options.disabled));
        }
        if (this.targetDom.querySelectorAll('[aria-disabled=true]')) {
            aDisabled = aDisabled.concat([...this.targetDom.querySelectorAll('[aria-disabled=true]')]);
        }
        if (_this.options.cookie) {
            let _cookie = axCookie.get(_this.options.cookie);
            if (_cookie) {
                _this.nav.children[_cookie].classList.add(_this.options.active);
                for (let k = 0; k < axSiblings(_this.nav.children[_cookie]).length; k++) {
                    axSiblings(_this.nav.children[_cookie])[k].classList.remove(_this.options.active);
                }
                _this.content.children[_cookie].classList.add(_this.options.active);
                for (let k = 0; k < axSiblings(_this.content.children[_cookie]).length; k++) {
                    axSiblings(_this.content.children[_cookie])[k].classList.remove(_this.options.active);
                }
            } else {
                _this.nav.children[0].classList.add(_this.options.active);
                _this.content.children[0].classList.add(_this.options.active);
            }
        } else if (_this.options.index == '' || _this.options.index < 0 || _this.options.index - _this.tabNum > -1) {
            for (let i = 0; i < _this.tabNum; i++) {
                if (i == 0) {
                    _this.nav.children[0].classList.add(_this.options.active);
                    _this.content.children[0].classList.add(_this.options.active);
                } else {
                    _this.nav.children[i].classList.remove(_this.options.active);
                    _this.content.children[i].classList.remove(_this.options.active);
                }
            }
        } else {
            for (let i = 0; i < _this.tabNum; i++) {
                if (i == _this.options.index) {
                    _this.nav.children[_this.options.index].classList.add(_this.options.active);
                    _this.content.children[_this.options.index].classList.add(_this.options.active);
                } else {
                    _this.nav.children[i].classList.remove(_this.options.active);
                    _this.content.children[i].classList.remove(_this.options.active);
                }
            }
        }
        for (let i = 0; i < _this.tabNum; i++) {
            let child = _this.nav.children[i];
            if (aDisabled.indexOf(child) < 0) {
                child.addEventListener(this.options.trigger, this.event, false);
            } else {
                child.removeEventListener(this.options.trigger, this.event, false);
            }
        }
        if (this.referName) {
            if (axIsEmpty(axTabs)) {
                axTabs.push({ name: this.referName, instance: this });
            } else {
                if (!axTabs.some(item => (item.name == this.referName))) {
                    axTabs.push({ name: this.referName, instance: this });
                }
                /* for (let i = 0; i < axTabs.length; i++) {
                    if (axTabs[i].name == this.referName) {
                        axTabs[i].instance = this;
                        break;
                    } else {
                        axTabs.push({ name: this.referName, instance: this });
                    }
                } */
            }
        }
        'load' in this.handlers ? this.emit('load', '') : null;
    }
    update(setting, callback) {
        let _this = this;
        this.options = axExtend(this.options, setting);
        this.init();
        'update' in this.handlers ? this.emit('update', '') : null;
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        for (let i = 0; i < this.tabNum; i++) {
            this.nav.children[i].removeEventListener(this.options.trigger, this.event, false);
        }
        callback && callback.call(this);
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
document.querySelectorAll('[axTab]').forEach(element => {
    new axTab(element);
});
/*!
* 插件：抽屉侧边窗；使用方法：new axDrawer({参数},'#id')；#id是可选参数，可以从该dom获取参数值
*/
const axDrawers = [];
class axDrawer {
    constructor(options, elem) {
        this.options = axExtend({
            title: '',
            titleBreak: true,
            overlay: true,
            overlayClose: true,
            placement: 'right',
            size: 'sm',
            padding: 'ax-padding',
            offset: '100px', 
            content: '',
            type: 'html',
            url: '',
            close: true,
            footerType: 'center',
            footerShow: true,
            footerBreak: false,
            note: '',
            confirm: {
                text: '确定',
                classname: '',
                icon: '',
                type:'close',
                url: '',
                callback: ''
            },
            cancel: {
                text: '关闭',
                classname: '',
                icon: '',
                callback: ''
            },
            diy: {
                text: '',
                classname: '',
                icon: '',
                url: '',
                target: '',
                callback: ''
            }
        }, options, elem);
        let _this = this;
        this.handlers = {};
        this.form = null;
        elem && !!elem.getAttribute('axDrawer') ? this.referName = elem.getAttribute('axDrawer') : this.referName = '';
        this.init();
    }
    init() {
        let _this = this;
        this.renderDom();
        this.setAttribute();
        if (this.options.content.nodeType == 1) {
            this.content.innerHTML = '';
            this.content.appendChild(this.options.content);
        } else if (this.options.type == 'form' && typeof this.options.content === 'string' && this.options.content.substr(0, 1) == '#') {
            this.form = document.querySelector(this.options.content).querySelector('form');
            if (this.form) {
                this.content.innerHTML = '';
                this.content.appendChild(this.form);
            } else {
                console.error('Form node is required!');
                return false;
            }
        } else {
            this.content.innerHTML = axCreateContent(this.options, this, function () {
                axPreventScroll(_this.wrapper, _this.body);
            });
        }
        this.footer.innerHTML = axFooterBtns(this.options, this);
        this.targetDom.querySelectorAll('[confirm]').forEach(elem => {
            elem.onclick = function (e) {
                let button = this;
                if (_this.options.confirm.type == 'submit') {
                    if (_this.form && _this.options.type == 'form') {
                        axValidRepeat(e, axValids, _this.form, function () {
                            _this.form.submit();
                        });
                        _this.options.confirm.callback && _this.options.confirm.callback.call(_this);
                    } else {
                        console.error('Form node is required and type of options must be form string!');
                        return false;
                    }
                } else if (_this.options.confirm.type == 'asyn') {
                    if (_this.form && _this.options.type == 'form' && _this.options.confirm.url) {
                        axValidRepeat(e, axValids, _this.form, function () {
                            axAjaxSubmit(_this.options.confirm.url, _this.form, button, function (content) {
                                _this.options.confirm.callback && _this.options.confirm.callback.call(_this,content);
                            });
                        })
                    } else {
                        console.error('Form node is required & type of options must be form string & url of asyn is required!');
                        return false;
                    }
                } else {
                    _this.hide();
                    _this.options.confirm.callback && _this.options.confirm.callback.call(_this);
                }
            };
        });
        this.targetDom.querySelectorAll('[diy]').forEach(elem => {
            elem.onclick =function () {
                _this.options.diy.callback &&  _this.options.diy.callback.call(_this);
            };
        });
        this.targetDom.querySelectorAll('[cancel]').forEach(elem => {
            elem.onclick=function () {
                _this.hide();
                _this.options.cancel.callback && _this.options.cancel.callback.call(_this);
            };
        });
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', function () {
                _this.hide();
            }, false);
        });
        document.body.appendChild(this.targetDom);
        axPreventScroll(this.wrapper, this.body);
        axDrawers.push({ name: this.referName, instance: this });
        return this;
    }
    createTemplate() {
        return `
                    <div class="ax-drawer" data-overlay="true" id="${axCreateId('drawer')}">
                        <# if(this.overlay){ #><div class="ax-drawer-overlay" <# if(this.overlayClose){ #>close<# } #>></div><# } #>
                        <div class="ax-drawer-wrapper">
                            <# if(this.close){ #> <a href="###" class="ax-drawer-close" close><i class="ax-iconfont ax-icon-close"></i></a><# } #>
                            <# if(this.title){ #><div class="ax-drawer-header"><div class="ax-col ax-align-center"><# this.title #></div></div><# } #>
                            <# if(this.title && this.titleBreak){ #><div class="ax-break-line"></div><# } #>
                            <div class="ax-drawer-body">
                                <# if(this.padding){ #><div class="<# this.padding #>" <# if(this.type == 'iframe'){ #>style="height:100%;"<# } #>> <# } #>
                                    <div class="ax-drawer-content" <# if(this.type == 'iframe'){ #>style="height:100%;"<# } #>><# this.content #></div>
                                <# if(this.padding){ #></div><# } #>
                            </div>
                            <div class="ax-drawer-footer">
                            </div>
                        </div>
                    </div>
                  `;
    }
    renderDom() {
        this.template = axTplEngine(this.createTemplate(), this.options);
        this.targetDom = axStrToDom(this.template);
        this.wrapper = this.targetDom.querySelector('.ax-drawer-wrapper');
        this.targetDom.querySelector('.ax-drawer-overlay') ? this.overlay = this.targetDom.querySelector('.ax-drawer-overlay') : null;
        this.content = this.targetDom.querySelector('.ax-drawer-content');
        this.body = this.targetDom.querySelector('.ax-drawer-body');
        this.targetDom.querySelector('.ax-drawer-footer') ? this.footer = this.targetDom.querySelector('.ax-drawer-footer') : null;
        this.width = window.getComputedStyle(this.wrapper).width;
        this.height = window.getComputedStyle(this.wrapper).height;
        this.left = window.getComputedStyle(this.wrapper).left;
        this.right = window.getComputedStyle(this.wrapper).right;
        this.top = window.getComputedStyle(this.wrapper).top;
        this.bottom = window.getComputedStyle(this.wrapper).bottom;
    }
    setAttribute() {
        if (this.options.placement == "left") {
            this.targetDom.setAttribute('data-placement', 'left');
        } else if (this.options.placement == "right") {
            this.targetDom.setAttribute('data-placement', 'right');
        } else if (this.options.placement == "top") {
            this.targetDom.setAttribute('data-placement', 'top');
        } else if (this.options.placement == "bottom") {
            this.targetDom.setAttribute('data-placement', 'bottom');
        } else {
            return;
        }
        if (this.options.size == "sm") {
            this.targetDom.setAttribute('data-size', 'sm');
        } else if (this.options.size == 'md') {
            this.targetDom.setAttribute('data-size', 'md');
        } else if (this.options.size == 'lg') {
            this.targetDom.setAttribute('data-size', 'lg');
        } else {
            return;
        }
    }
    show(callback) {
        'show' in this.handlers ? this.emit('show', '') : null;
        this.delete ? console.error('Instance is destroyed!') : null;
        let _this = this;
        axDrawers.forEach(item => {
            if (item.instance.targetDom.classList.contains('ax-drawer-show') && item.instance.options.placement == this.options.placement) {
                let wrapper = item.instance.targetDom.querySelector('.ax-drawer-wrapper');
                switch (this.options.placement) {
                    case 'left':
                        !wrapper.style.left ? wrapper.style.left = this.options.offset : wrapper.style.left = parseInt(wrapper.style.left) + parseInt(this.options.offset) + 'px';
                        break;
                    case 'right':
                        !wrapper.style.right ? wrapper.style.right = this.options.offset : wrapper.style.right = parseInt(wrapper.style.right) + parseInt(this.options.offset) + 'px';
                        break;
                    case 'top':
                        !wrapper.style.top ? wrapper.style.top = this.options.offset : wrapper.style.top = parseInt(wrapper.style.top) + parseInt(this.options.offset) + 'px';
                        break;
                    case 'bottom':
                        !wrapper.style.bottom ? wrapper.style.bottom = this.options.offset : wrapper.style.bottom = parseInt(wrapper.style.bottom) + parseInt(this.options.offset) + 'px';
                        break;
                    default:
                        null;
                }
            }
        });
        this.targetDom.classList.add("ax-drawer-show");
        callback && callback.call(this);
        'shown' in this.handlers ? this.emit('shown', '') : null;
        return this;
    }
    hide(callback) {
        'hide' in this.handlers ? this.emit('hide', '') : null;
        let _this = this,
            timeHide = function (instance) {
                let overlay = instance.targetDom.querySelector('.ax-drawer-overlay'),
                    wrapper = instance.targetDom.querySelector('.ax-drawer-wrapper');
                overlay.style.opacity = 0;
                switch (instance.options.placement) {
                    case 'left':
                        wrapper.style.left = '-' + getComputedStyle(wrapper).width;
                        break;
                    case 'right':
                        wrapper.style.right = '-' + getComputedStyle(wrapper).width;
                        break;
                    case 'top':
                        wrapper.style.top = '-' + getComputedStyle(wrapper).height;
                        break;
                    case 'bottom':
                        wrapper.style.bottom = '-' + getComputedStyle(wrapper).height;
                        break;
                    default:
                        null;
                }
                setTimeout(function () {
                    instance.targetDom.classList.remove("ax-drawer-show");
                    overlay.removeAttribute("style");
                    wrapper.removeAttribute("style");
                }, parseFloat(axStyle(wrapper).animationDuration) * 1000);
            };
        timeHide(this);
        axDrawers.forEach(item => {
            if (item.instance.targetDom.classList.contains('ax-drawer-show') && item.instance.options.placement == this.options.placement) {
                let wrapper = item.instance.targetDom.querySelector('.ax-drawer-wrapper');
                switch (this.options.placement) {
                    case 'left':
                        wrapper.style.left = parseInt(wrapper.style.left) - parseInt(this.options.offset) + 'px';
                        break;
                    case 'right':
                        wrapper.style.right = parseInt(wrapper.style.right) - parseInt(this.options.offset) + 'px';
                        break;
                    case 'top':
                        wrapper.style.top = parseInt(wrapper.style.top) - parseInt(this.options.offset) + 'px';
                        break;
                    case 'bottom':
                        wrapper.style.bottom = parseInt(wrapper.style.bottom) - parseInt(this.options.offset) + 'px';
                        break;
                    default:
                        null;
                }
            }
        });
        this.targetDom.querySelectorAll('video,audio').forEach(elem => {
            elem.pause();
        });
        callback && callback.call(this);
        'hidden' in this.handlers ? this.emit('hidden', '') : null;
        return this;
    }
    destroy(callback) {
        this.targetDom.remove();
        callback && callback.call(this);
    }
    update(setting, callback) {
        'update' in this.handlers ? this.emit('update', '') : null;
        let targetDom = this.targetDom,
            before = axClone(this.options),
            after = axExtend(this.options, setting),
            update = false;
        if (setting && JSON.stringify(after) != JSON.stringify(before)) {
            this.options = after;
            this.init();
            targetDom.remove();
            update = true;
        } else {
            update = false;
        }
        callback && callback.call(this, update, before, after);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        return this;
    }
    updateContent(html, callback) {
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = this.content.innerHTML,
            update = false;
        if (html.substr(0, 1) == "#") {
            if (document.querySelector(html)) {
                this.content.innerHTML = document.querySelector(html).innerHTML;
            } else {
                this.content.innerHTML == `No ${html} node exist!`;
            }
        } else {
            this.content.innerHTML = html;
        }
        if (this.content.innerHTML == before) {
            update = false;
        } else {
            update = true;
        }
        callback && callback.call(this, update, before, this.content.innerHTML, this.options.content);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    function eachInstance(arr, parent) {
        arr.forEach(elem => {
            let instance = new axDrawer('', elem);
            parent ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
            elem.onclick = () => instance.show();
            eachInstance(instance.targetDom.querySelectorAll('[axDrawer]'), instance);
        });
    }
    let arrInstance = document.querySelectorAll('[axDrawer]');
    eachInstance(arrInstance);
})();
/*!
 * 插件：对话弹窗；使用方法：new axDialog({参数},'#id')；#id是可选参数，可以从该dom获取参数值
 */
const axDialogs = [];
class axDialog {
    constructor(options, elem) {
        this.options = axExtend({
            title: '',
            titleBreak: false,
            overlay: true,
            overlayClose: true,
            duration: '',
            in: 'springIn',
            out: 'scaleOut',
            multiple: true,
            size: 'md',
            padding: 'ax-padding',
            drag: false,
            content: '',
            type: 'html',
            url: '',
            btnClass: 'ax-dialog-open',
            name: '',
            width: '',
            height: '',
            close: true,
            closePlace: 'inside',
            footerShow: true,
            footerType: 'center',
            footerBreak: false,
            note: '',
            confirm: {
                text: '确定',
                classname: '',
                icon: '',
                type: 'close',
                url: '',
                callback: ''
            },
            cancel: {
                text: '关闭',
                classname: '',
                icon: '',
                callback: ''
            },
            diy: {
                text: '',
                classname: '',
                icon: '',
                url: '',
                target: '',
                callback: ''
            }
        }, options, elem);
        this.wrapper = '';
        this.content = '';
        this.overlay = '';
        this.handlers = {};
        this.wrapPosition = '';
        this.wrapLeft = '';
        this.wrapTop = '';
        this.form = null;
        this.referName = ''
        if (elem) {
            this.button = axIdToDom(elem);
            this.button && !!this.button.getAttribute('axDialog') ? this.referName = this.button.getAttribute('axDialog') : null;
        }
        this.init();
    }
    init() {
        let _this = this;
        this.renderDom();
        this.setAttribute();
        if (this.options.content.nodeType == 1) {
            this.content.innerHTML = '';
            this.content.appendChild(this.options.content);
        } else if (this.options.type == 'form' && typeof this.options.content === 'string' && this.options.content.substr(0, 1) == '#') {
            this.form = document.querySelector(this.options.content).querySelector('form');
            if (this.form) {
                this.content.innerHTML = '';
                this.content.appendChild(this.form);
            } else {
                console.error('Form node is required!');
                return false;
            }
        } else {
            this.content.innerHTML = axCreateContent(this.options, this, function () {
                axPreventScroll(_this.wrapper, _this.body);
            });
        }
        this.footer.innerHTML = axFooterBtns(this.options, this);
        if (this.options.drag) {
            this.drag();
        }
        this.targetDom.querySelectorAll('[confirm]').forEach(elem => {
            elem.onclick = function (e) {
                let button = this;
                if (_this.options.confirm.type == 'submit') {
                    if (_this.form && _this.options.type == 'form') {
                        axValidRepeat(e, axValids, _this.form, function () {
                            _this.form.submit();
                        });
                        _this.options.confirm.callback && _this.options.confirm.callback.call(_this);
                    } else {
                        console.error('Form node is required and type of options must be form string!');
                        return false;
                    }
                } else if (_this.options.confirm.type == 'asyn') {
                    if (_this.form && _this.options.type == 'form' && _this.options.confirm.url) {
                        axValidRepeat(e, axValids, _this.form, function () {
                            axAjaxSubmit(_this.options.confirm.url, _this.form, button, function (content) {
                                _this.options.confirm.callback && _this.options.confirm.callback.call(_this,content);
                            });
                        })
                    } else {
                        console.error('Form node is required & type of options must be form string & url of asyn is required!');
                        return false;
                    }
                } else {
                    _this.hide();
                    _this.options.confirm.callback && _this.options.confirm.callback.call(_this);
                }
            };
        });
        this.targetDom.querySelectorAll('[diy]').forEach(elem => {
            elem.onclick =function () {
                _this.options.diy.callback &&  _this.options.diy.callback.call(_this);
            };
        });
        this.targetDom.querySelectorAll('[cancel]').forEach(elem => {
            elem.onclick=function () {
                _this.hide();
                _this.options.cancel.callback && _this.options.cancel.callback.call(_this);
            };
        });
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', function () {
                _this.hide();
            }, false);
        });
        document.body.appendChild(this.targetDom);
        axPreventScroll(this.wrapper, this.body);
        if (this.referName) {
            if (axIsEmpty(axDialogs)) {
                axDialogs.push({ name: this.referName, instance: this });
            } else {
                if (!axDialogs.some(item => (item.name == this.referName))) {
                    axDialogs.push({ name: this.referName, instance: this });
                }
                /* for (let i = 0; i < axDialogs.length; i++) {
                    if (axDialogs[i].name == this.referName) {
                        axDialogs[i].instance = this;
                        break;
                    } else {
                        axDialogs.push({ name: this.referName, instance: this });
                    }
                } */
            }
        }
        this.wrapperHeight = axArrHeight(this.wrapper).height;
        return this;
    }
    createTemplate() {
        return `
        <div class="ax-dialog" data-overlay="true" id="${axCreateId('dialog')}">
        <# if(this.overlay){ #><div class="ax-dialog-overlay" <# if(this.overlayClose){ #>close<# } #>></div><# } #>
            <div class="ax-dialog-wrapper">
                <# if(this.close){ #><a href="###" class="ax-dialog-close" close><i class="ax-iconfont ax-icon-close"></i></a><# } #>
                <# if(this.title){ #><div class="ax-dialog-header"><# this.title #></div><# } #>
                <# if(this.titleBreak){ #><div class="ax-break-line"></div><# } #>
                <div class="ax-dialog-body">
                    <# if(typeof this.padding == 'string'){ #><div class="<# this.padding #>"> <# }else if(this.padding){ #><div class="ax-padding"> <# } #>
                    <div class="ax-dialog-content"><# this.content #></div>
                    <# if(this.padding){ #></div><# } #>
                </div>
                <div class="ax-dialog-footer">
                </div>
            </div>
        </div>
      `
    }
    renderDom() {
        this.template = axTplEngine(this.createTemplate(), this.options);
        this.targetDom = axStrToDom(this.template);
        this.wrapper = this.targetDom.querySelector('.ax-dialog-wrapper');
        this.header = this.targetDom.querySelector('.ax-dialog-header');
        this.content = this.targetDom.querySelector('.ax-dialog-content');
        this.body = this.targetDom.querySelector('.ax-dialog-body');
        this.overlay = this.targetDom.querySelector('.ax-dialog-overlay');
        this.footer = this.targetDom.querySelector('.ax-dialog-footer');
    }
    setAttribute() {
        this.options.size ? this.targetDom.setAttribute('data-size', this.options.size) : null;
        this.options.footerType ? this.targetDom.setAttribute('data-footerType', this.options.footerType) : null;
        this.options.height ? this.content.style.height = this.options.height : null;
        this.oldStyle = this.options.width ? `width:${this.options.width};` : null;
        this.options.type ? this.targetDom.setAttribute('data-type', this.options.type) : null;
        !this.options.overlay ? this.targetDom.setAttribute('data-overlay', 'false') : null;
        if (!this.options.title && this.options.close) {
            if (this.options.size == 'lg') {
                this.targetDom.setAttribute('data-closePlace', 'bottom');
            } else if (!this.options.title && this.options.closePlace == 'inside') {
                this.targetDom.setAttribute('data-closePlace', 'outside');
            } else {
                this.targetDom.setAttribute('data-closePlace', this.options.closePlace)
            }
        } else if (this.options.closePlace && this.options.close) {
            this.targetDom.setAttribute('data-closePlace', this.options.closePlace)
        }
    }
    drag(callback) {
        if (this.options.title) {
            let _this = this,
                header = this.targetDom.querySelector('.ax-dialog-header');
            this.targetDom.setAttribute('data-drag', this.options.drag);
            header.onmousedown = function (e) {
                'drag' in _this.handlers ? _this.emit('drag', '') : null;
                this.style.cursor = 'move';
                let moveDiv = this.parentNode;
                moveDiv.style.cssText += 'position:fixed ;';
                _this.wrapPosition = 'fixed';
                let x = e.clientX - moveDiv.offsetLeft;
                let y = e.clientY - moveDiv.offsetTop;
                document.onmousemove = function (ev) {
                    let _x = ev.clientX - x;
                    let _y = ev.clientY - y;
                    let maxX = document.documentElement.clientWidth - moveDiv.clientWidth;
                    let maxY = document.documentElement.clientHeight - moveDiv.clientHeight;
                    if (_x < 0) {
                        _x = 0;
                    }
                    if (_x > maxX) {
                        _x = maxX;
                    }
                    if (_y < 0) {
                        _y = 0;
                    }
                    if (_y > maxY) {
                        _y = maxY;
                    }
                    moveDiv.style.left = _x + 'px';
                    moveDiv.style.top = _y + 'px';
                    _this.wrapLeft = moveDiv.style.left;
                    _this.wrapTop = moveDiv.style.top;
                };
            };
            header.onmouseup = function () {
                document.onmousemove = null;
                document.onmouseup = null;
                'dragged' in _this.handlers ? _this.emit('dragged', '') : null;
            }
            header.ondragstart = function (ev) {
                axPreventDefault(ev);
            };
            header.ondragend = function (ev) {
                axPreventDefault(ev);
            };
            callback && callback.call(this);
        } else {
            return false;
        }
        return this;
    }
    update(setting, callback) {
        let targetDom = this.targetDom,
            before = axClone(this.options),
            after = axExtend(this.options, setting),
            update = false;
        if (setting && JSON.stringify(after) != JSON.stringify(before)) {
            this.options = after;
            this.init();
            targetDom.remove();
            update = true;
        } else {
            update = false;
        }
        callback && callback.call(this, update, before, after);
        return this;
    }
    updateContent(html, callback) {
        let before = this.content.innerHTML,
            update = false;
        if (html.substr(0, 1) == "#") {
            if (document.querySelector(html)) {
                this.content.innerHTML = document.querySelector(html).innerHTML;
            } else {
                this.content.innerHTML == `No ${html} node exist!`;
            }
        } else {
            this.content.innerHTML = html;
        }
        if (this.content.innerHTML == before) {
            update = false;
        } else {
            update = true;
        }
        callback && callback.call(this, update, before, this.content.innerHTML, this.options.content);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        return this;
    }
    destroy(callback) {
        this.targetDom.remove();
        callback && callback.call(this);
    }
    show(callback) {
        this.delete ? console.error('Instance is destroyed!') : null;
        let _this = this;
        if (!_this.options.multiple) {
            axDialogs.forEach((elem) => {
                (elem.instance != _this && elem.instance.targetDom.classList.contains('ax-dialog-show')) ? elem.instance.hide() : null;
            })
        }
        'show' in this.handlers ? this.emit('show', '') : null;
        this.targetDom.classList.remove('ax-dialog-hide');
        this.targetDom.classList.add('ax-dialog-show');
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        this.options.duration ? this.wrapper.style.animationDuration = this.options.duration : null;
        let dragStyle = '';
        this.wrapPosition ? dragStyle = `position:${this.wrapPosition};left:${this.wrapLeft};top:${this.wrapTop};` : null;
        if (this.options.in == 'slideDown') {
            axHeightDown(_this.wrapper, { height: this.wrapperHeight }, '', _this.options.duration ? parseFloat(_this.options.duration) : '');
        } else {
            this.options.in ? this.wrapper.style.cssText = `animation-name: ${this.options.in};${dragStyle};${this.oldStyle}` : null;
        }
        callback && callback.call(this);
        'shown' in this.handlers ? this.emit('shown', '') : null;
        return this;
    }
    hide(callback) {
        'hide' in this.handlers ? this.emit('hide', '') : null;
        let _this = this;
        this.button ? this.button.classList.remove('ax-dialog-open') : null;
        this.options.duration ? this.targetDom.style.animationDuration = this.options.duration : null;
        this.targetDom.classList.add('ax-dialog-hide');
        let dragStyle = '';
        this.wrapPosition ? dragStyle = `position:${this.wrapPosition};left:${this.wrapLeft};top:${this.wrapTop};` : null;
        if (this.options.out == 'slideUp') {
            axHeightUp(_this.wrapper, { height: this.wrapperHeight }, '', _this.options.duration ? parseFloat(_this.options.duration) : '');
        } else {
            this.options.out ? this.wrapper.style.cssText = `animation-name: ${this.options.out};${dragStyle};${this.oldStyle}` : null;
        }
        setTimeout(function () {
            _this.targetDom.classList.remove('ax-dialog-show');
            _this.wrapper.style.cssText = _this.oldStyle;
        }, _this.options.duration ? parseFloat(_this.options.duration) : parseFloat(axStyle(_this.wrapper).animationDuration) * 1000)
        this.targetDom.querySelectorAll('video,audio').forEach(elem => {
            elem.pause();
        });
        callback && callback.call(this);
        'hidden' in this.handlers ? this.emit('hidden', '') : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    function eachInstance(arr, parent) {
        arr.forEach(elem => {
            let instance = new axDialog('', elem);
            parent ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
            elem.onclick = () => instance.show();
            eachInstance(instance.targetDom.querySelectorAll('[axDialog]'), instance);
        });
    }
    let arrInstance = document.querySelectorAll('[axDialog]');
    eachInstance(arrInstance);
})();
/*!
* 插件：气泡弹窗；使用方法：new axPopup('#id',{参数})
*/
const axPopups = [];
class axPopup {
    constructor(elem, options) {
        this.options = axExtend({
            title: '',
            titleBreak: false,
            placement: 'top',
            arrow: true,
            trigger: 'click',
            pageClose: true,
            size: '',
            duration: '',
            in: 'fadeIn',
            out: 'fadeOut',
            multiple: false,
            offsetShow: true,
            rel: '',
            theme: '',
            stay: false,
            fixDistance: 24,
            name: '',
            size: 'md',
            width: '',
            height: '',
            padding: 'ax-padding',
            content: '',
            type: 'html',
            url: '',
            btnClass: 'ax-popup-open',
            close: true,
            footerShow: true,
            footerType: 'line',
            footerBreak: false,
            note: '',
            confirm: {
                text: '确定',
                classname: '',
                icon: '',
                type: 'close',
                url: '',
                callback: ''
            },
            cancel: {
                text: '关闭',
                classname: '',
                icon: '',
                callback: ''
            },
            diy: {
                text: '',
                classname: '',
                icon: '',
                url: '',
                target: '',
                callback: ''
            }
        }, options, elem);
        let _this = this;
        this.handlers = {};
        this.form = null;
        this.button = axIdToDom(elem);
        this.button && !!this.button.getAttribute('axPopup') ? this.referName = this.button.getAttribute('axPopup') : this.referName = '';
        this.isShow = false;
        this.init();
        this.showEvent();
    }
    init() {
        let _this = this;
        this.renderDom();
        this.setAttribute();
        if (this.options.content.nodeType == 1) {
            this.content.innerHTML = '';
            this.content.appendChild(this.options.content);
        } else if (this.options.type == 'form' && typeof this.options.content === 'string' && this.options.content.substr(0, 1) == '#') {
            this.form = document.querySelector(this.options.content).querySelector('form');
            if (this.form) {
                this.content.innerHTML = '';
                this.content.appendChild(this.form);
            } else {
                console.error('Form node is required!');
                return false;
            }
        } else {
            this.content.innerHTML = axCreateContent(this.options, this, () => {
                axPreventScroll(_this.wrapper, _this.body);
            });
        }
        this.footer.innerHTML = axFooterBtns(this.options, this);
        this.createPopup();
        this.targetDom.querySelectorAll('[confirm]').forEach(elem => {
            elem.onclick = function (e) {
                let button = this;
                if (_this.options.confirm.type == 'submit') {
                    if (_this.form && _this.options.type == 'form') {
                        axValidRepeat(e, axValids, _this.form, function () {
                            _this.form.submit();
                        });
                        _this.options.confirm.callback && _this.options.confirm.callback.call(_this);
                    } else {
                        console.error('Form node is required and type of options must be form string!');
                        return false;
                    }
                } else if (_this.options.confirm.type == 'asyn') {
                    if (_this.form && _this.options.type == 'form' && _this.options.confirm.url) {
                        axValidRepeat(e, axValids, _this.form, function () {
                            axAjaxSubmit(_this.options.confirm.url, _this.form, button, function (content) {
                                _this.options.confirm.callback && _this.options.confirm.callback.call(_this, content);
                            });
                        })
                    } else {
                        console.error('Form node is required & type of options must be form string & url of asyn is required!');
                        return false;
                    }
                } else {
                    _this.hide();
                    _this.options.confirm.callback && _this.options.confirm.callback.call(_this);
                }
            };
        });
        this.targetDom.querySelectorAll('[diy]').forEach(elem => {
            elem.onclick = function () {
                _this.options.diy.callback && _this.options.diy.callback.call(_this);
            };
        });
        this.targetDom.querySelectorAll('[cancel]').forEach(elem => {
            elem.onclick = function () {
                _this.hide();
                _this.options.cancel.callback && _this.options.cancel.callback.call(_this);
            };
        });
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', () => {
                _this.hide();
            }, false);
        });
        document.body.appendChild(this.targetDom);
        axPreventScroll(this.wrapper, this.body);
        axPopups.push({ name: this.referName, button: this.button, instance: this });
        this.wrapperHeight = axArrHeight(this.wrapper).height;
    }
    createTemplate() {
        return `
                            <div class="ax-popup" id="popup${new Date().getTime()}">
                                <div class="ax-popup-wrapper">
                                    <# if(this.close){ #><a href="###" class="ax-close" close></a><# } #>
                                    <# if(this.title){ #><div class="ax-popup-header"><# this.title #></div><# } #>
                                    <# if(this.titleBreak){ #><div class="ax-break-line"></div><# } #>
                                    <div class="ax-popup-body">
                                        <# if(typeof this.padding == 'string'){ #><div class="<# this.padding #>"> <# }else if(this.padding){ #><div class="ax-padding"> <# } #>
                                        <# this.media #>
                                        <div class="ax-popup-content"><# this.content #></div>
                                        <# if(this.padding){ #></div><# } #>
                                    </div>
                                    <div class="ax-popup-footer">
                                    </div>
                                </div>
                                <# if(this.arrow && this.placement!=='center' && !axIsMobi()){ #><i arrow></i><# } #>
                            </div>
                            `
    }
    renderDom() {
        this.template = axTplEngine(this.createTemplate(), this.options);
        this.targetDom = axStrToDom(this.template);
        this.wrapper = this.targetDom.querySelector('.ax-popup-wrapper');
        this.content = this.targetDom.querySelector('.ax-popup-content');
        this.body = this.targetDom.querySelector('.ax-popup-body');
        this.targetDom.querySelector('.ax-popup-header') ? this.header = this.targetDom.querySelector('.ax-popup-header') : null;
        this.footer = this.targetDom.querySelector('.ax-popup-footer');
    }
    setAttribute() {
        this.options.size ? this.targetDom.setAttribute('data-size', this.options.size) : null;
        !this.options.arrow ? this.targetDom.setAttribute('data-arrow', 'false') : null;
        this.options.type ? this.targetDom.setAttribute('data-type', this.options.type) : null;
        this.options.footerType ? this.targetDom.setAttribute('data-footerType', this.options.footerType) : null;
        this.options.height ? this.content.style.height = this.options.height : null;
        this.options.theme ? this.targetDom.setAttribute('data-theme', this.options.theme) : null;
    }
    createPopup() {
        let _this = this;
        if (this.options.placement == 'center' || axIsMobi()) {
            this.popper = new Popper.createPopper(this.button, this.targetDom, {
                strategy: 'fixed',
                modifiers: [
                    {
                        name: 'computeStyles',
                        fn: (data) => {
                            data.state.styles.popper = Object.assign(data.state.styles.popper, {
                                left: '50%',
                                top: '50%',
                                marginLeft: -parseFloat(axStyle(data.state.elements.popper).width) / 2 + 'px',
                                marginTop: -parseFloat(axStyle(data.state.elements.popper).height) / 2 + 'px',
                            });
                        }
                    },
                ],
            });
        } else {
            this.popper = new Popper.createPopper(this.button, this.targetDom, {
                fixDistance: this.options.fixDistance,
                placement: this.options.placement,
                modifiers: [
                    {
                        name: 'offset',
                        options: {
                            offset: [0, _this.options.offsetShow ? _this.options.arrow ? 8 : 4 : 0],
                        },
                    },
                    {
                        name: 'computeStyles',
                        options: {
                            gpuAcceleration: false,
                        },
                    },
                ],
            });
        }
        this.oldStyle = this.options.width ? `width:${this.options.width};` : '';
    }
    showEvent() {
        let _this = this;
        let clickShow = () => {
            if (!_this.targetDom.classList.contains('ax-show')) {
                _this.show();
                if (!_this.options.multiple) {
                    let newPopups = axPopups.map(item => {
                        return item.instance
                    }).filter(item => {
                        return item !== _this && item.targetDom.classList.contains('ax-show');
                    });
                    newPopups.forEach(item => {
                        item.hide();
                    });
                }
            } else {
                _this.hide();
            }
        }
        if (this.options.trigger == 'click') {
            this.button.addEventListener(this.options.trigger, () => {
                clickShow();
            }, false);
            if (this.options.rel && this.options.rel instanceof Array) {
                this.options.rel.forEach(item => {
                    document.querySelector(item).addEventListener(this.options.trigger, () => {
                        clickShow();
                    }, false);
                });
            } else if (this.options.rel) {
                axIdToDom(this.options.rel).addEventListener(this.options.trigger, () => {
                    clickShow();
                }, false);
            }
        } else if (this.options.trigger == 'hover') {
            new axHover(_this.button, {
                enter: () => {
                    _this.show();
                },
                leave: () => {
                    _this.hide();
                },
                hold: _this.targetDom,
            });
        } else if (this.options.trigger == 'input') {
            this.button.addEventListener('input', () => {
                if (!_this.button.value) {
                    _this.hide();
                } else {
                    _this.show();
                }
            }, false);
        } else if (this.options.trigger == 'sticky') {
            this.show();
        }
        if (this.options.pageClose && !_this.options.multiple) {
            document.addEventListener('click', (ev) => {
                let relOut;
                if (_this.options.rel instanceof Array) {
                    for (let i = 0; i < _this.options.rel.length; i++) {
                        if (!axIsOutside(window.event, axIdToDom(_this.options.rel[i]))) {
                            relOut = false;
                            break;
                        } else {
                            relOut = true;
                        }
                    }
                } else {
                    relOut = axIsOutside(window.event, _this.options.rel);
                }
                if (axIsOutside(ev, _this.targetDom) && axIsOutside(ev, _this.button) && relOut && _this.targetDom.classList.contains('ax-show')) {
                    _this.hide();
                };
            }, false);
        }
    }
    update(setting, callback) {
        'update' in this.handlers ? this.emit('update', '') : null;
        let targetDom = this.targetDom,
            before = axClone(this.options),
            after = axExtend(this.options, setting),
            update = false;
        this.options = after;
        this.targetDom.remove();
        this.popper = '';
        this.init();
        callback && callback.call(this, update);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        return this;
    }
    updateContent(html, callback) {
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = this.content.innerHTML,
            update = false;
        if (html.substr(0, 1) == "#") {
            if (document.querySelector(html)) {
                this.content.innerHTML = document.querySelector(html).innerHTML;
            } else {
                this.content.innerHTML == `No ${html} node exist!`;
            }
        } else {
            this.content.innerHTML = html;
        }
        if (this.content.innerHTML == before) {
            update = false;
        } else {
            update = true;
        }
        callback && callback.call(this, update, before, this.content.innerHTML, this.options.content);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        return this;
    }
    updatePosition(obj, callback) {
        'update' in this.handlers ? this.emit('update', '') : null;
        let newButton = axIdToDom(obj);
        this.popper.update(newButton);
        callback && callback.call(this);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        return this;
    }
    show(callback) {
        this.popper.update();
        this.delete ? console.error('Instance is destroyed!') : null;
        let _this = this;
        'show' in this.handlers ? this.emit('show', '') : null;
        this.targetDom.classList.add('ax-show');
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        this.options.duration ? this.targetDom.style.animationDuration = this.options.duration : null;
        if (this.options.in == 'slideDown') {
            axHeightDown(_this.wrapper, { height: this.wrapperHeight }, '', _this.options.duration ? parseFloat(_this.options.duration) : '')
        } else {
            this.options.in ? this.targetDom.style.animationName = this.options.in : null;
        }
        this.targetDom.style.cssText += `;${this.oldStyle}`;
        this.isShow = true;
        callback && callback.call(this);
        'shown' in this.handlers ? this.emit('shown', '') : null;
        return this;
    }
    hide(callback) {
        if (!this.options.stay) {
            'hide' in this.handlers ? this.emit('hide', '') : null;
            let _this = this;
            this.button ? this.button.classList.remove('ax-popup-open') : null;
            this.options.duration ? this.targetDom.style.animationDuration = this.options.duration : null;
            setTimeout(() => {
                _this.targetDom.classList.remove('ax-show');
                'hidden' in _this.handlers ? _this.emit('hidden', '') : null;
            }, _this.options.duration ? parseFloat(_this.options.duration) : parseFloat(axStyle(_this.targetDom).animationDuration) * 1000);
            if (this.options.out == 'slideUp') {
                axHeightUp(_this.wrapper, { height: this.wrapperHeight }, '', _this.options.duration ? parseFloat(_this.options.duration) : '')
            } else {
                this.options.out ? this.targetDom.style.animationName = this.options.out : null;
            }
            this.targetDom.style.cssText += `;${this.oldStyle}`;
            this.targetDom.querySelectorAll('video,audio').forEach(elem => {
                elem.pause();
            });
            this.isShow = false;
            callback && callback.call(this);
        }
        return this;
    }
    destroy(callback) {
        this.targetDom.remove();
        this.popper = '';
        callback && callback.call(this);
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    function eachInstance(arr, parent) {
        arr.forEach(elem => {
            let instance = new axPopup(elem, '');
            parent ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
            eachInstance(instance.targetDom.querySelectorAll('[axPopup]'), instance);
        });
    }
    let arrInstance = document.querySelectorAll('[axPopup]');
    eachInstance(arrInstance);
})();
/*!
 * 插件：小窗文字提示；使用方法：axTooltip('#id',{参数})
 */
class axTooltip {
    constructor(elem, options) {
        this.button = axIdToDom(elem);
        this.options = axExtend({
            placement: 'top', 
            arrow: true, 
            trigger: 'hover', 
            size: '', 
            multiple: true, 
            theme: 'dark', 
            content: '', 
        }, options, this.button);
        this.init();
    }
    init() {
        if (this.button.getAttribute('axTooltip')) {
            this.options.content = this.button.getAttribute('axTooltip');
        }
        let popOptions = Object.assign({
            type: 'html',
            close: false,
            footerShow: false,
            padding: false,
        }, this.options);
        this.popup = new axPopup(this.button, popOptions);
        this.content = this.popup.content;
        this.setAttribute();
    }
    setAttribute() {
        this.popup.targetDom.classList.add('ax-tooltip');
        if (this.options.theme) {
            this.popup.targetDom.setAttribute('theme', this.options.theme)
        }
    }
    updateContent(str,callback){
        this.content.innerHTML = str;
        callback && callback.call(this, update, before, this.content.innerHTML, this.options.content);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axTooltip]').forEach(element => {
        new axTooltip(element);
    });
})();
/*!
* 插件：即时消息/警告小窗；使用方法：new axMessage({参数})
*/
const axMessages = [];
class axMessage {
    constructor(options) {
        this.options = axExtend({
            className: '',
            placement: 'center-top',
            content: '',
            result: 'info',
            delay: 3000,
            progress: true,
            title: {
                warning: '操作警告！',
                success: '操作成功！',
                error: '操作失败！',
                question: '操作疑问！',
                info: '信息提示！',
            },
            close: false,
            iconShow: false,
            style: 'simple',
            icon: '',
        }, options);
        this.handlers = {};
        this.init();
    }
    init() {
        let _this = this;
        if (this.options.style == 'simple' || !this.options.style) {
            switch (this.options.result) {
                case 'success':
                    this.options.icon = axIcon.font.success;
                    !this.options.content ? this.options.content = this.options.title.success : null;
                    break;
                case 'error':
                    this.options.icon = axIcon.font.error;
                    !this.options.content ? this.options.content = this.options.title.error : null;
                    break;
                case 'question':
                    this.options.icon = axIcon.font.question;
                    !this.options.content ? this.options.content = this.options.title.question : null;
                    break;
                case 'warning':
                    this.options.icon = axIcon.font.warning;
                    !this.options.content ? this.options.content = this.options.title.warning : null;
                    break;
                default:
                    this.options.icon = axIcon.font.info;
                    !this.options.content ? this.options.content = this.options.title.info : null;
            }
        } else if (this.options.style == 'complex') {
            switch (this.options.result) {
                case 'success':
                    this.options.icon = axIcon.svg.success;
                    break;
                case 'error':
                    this.options.icon = axIcon.svg.error;
                    break;
                case 'question':
                    this.options.icon = axIcon.svg.question;
                    break;
                case 'warning':
                    this.options.icon = axIcon.svg.warning;
                    break;
                default:
                    this.options.icon = axIcon.svg.info;
            }
        }
        if (this.options.style == 'simple' || !this.options.style) {
            this.template = axTplEngine(`
            <section data-style="simple">
                <div class="ax-message-content">
                    <# if(this.iconShow){ #><span class="ax-message-icon"><# this.icon #></span><# } #>
                    <div class="ax-message-body"><# this.content #></div>
                    <# if(this.close){ #><a href="###" class="ax-close"></a> <# } #>
                </div>
            </section>
            `, this.options);
        } else if (this.options.style == 'complex') {
            this.template = axTplEngine(`
            <section data-style="complex">
                <div class="ax-message-content">
                    <div class="ax-message-header">
                    <# if(this.iconShow){ #><span class="ax-message-icon ax-result ax-result-show"><# this.icon #></span><# } #>
                    <span class="ax-message-title"><# if(this.result == 'success'){ #> <# this.title.success #> <# }else if(this.result == 'error'){ #> <# this.title.error #> <# }else if(this.result == 'question'){#> <# this.title.question #> <# }else if(this.result == 'warning'){#> <# this.title.warning #> <# } else {#> <# this.title.info #> <# } #></span></div>
                    <div class="ax-message-body"><# this.content #></div>
                </div>
                <# if(this.close){ #><a href="###" class="ax-close"></a> <# } #>
                <# if(this.progress){ #><div class="ax-message-progress" style="transition-duration:<# this.delay #>ms;"></div><# } #>
            </section>
            `, this.options);
        }
        this.targetDom = axStrToDom(this.template);
        this.content = this.targetDom.querySelector('.ax-message-body');
        this.title = this.targetDom.querySelector('.ax-message-title');
        this.close = this.targetDom.querySelector('.ax-close');
        this.progress = this.targetDom.querySelector('.ax-message-progress');
        switch (this.options.result) {
            case 'success':
                this.targetDom.setAttribute('data-result', 'success');
                break;
            case 'error':
                this.targetDom.setAttribute('data-result', 'error');
                break;
            case 'question':
                this.targetDom.setAttribute('data-result', 'question');
                break;
            case 'warning':
                this.targetDom.setAttribute('data-result', 'warning');
                break;
            default:
                this.targetDom.setAttribute('data-result', 'info');
        }
        let className = '';
        !this.options.className ? className = ' ' + this.options.className : className = '';
        this.options.close ? this.targetDom.setAttribute('data-close', 'true') : null;
        this.content.innerHTML = this.options.content;
        this.event = (position) => {
            if (JSON.stringify(axMessages).indexOf(position) === -1) {
                let dom = axAddElem('div', { 'class': 'ax-message' + className, 'data-placement': position });
                axMessages.push({
                    postion: position,
                    parent: dom,
                });
                dom.appendChild(_this.targetDom);
                document.body.appendChild(dom);
                axSlideDown(_this.targetDom, () => {
                    'shown' in _this.handlers ? _this.emit('shown', '') : null;
                });
                if (!_this.options.close) {
                    _this.options.progress && _this.progress ? _this.progress.style.cssText += `width:0;` : null;
                    setTimeout(() => {
                        axSlideUp(_this.targetDom, () => {
                            _this.targetDom.remove();
                            'hidden' in _this.handlers ? _this.emit('hidden', '') : null;
                        });
                    }, this.options.delay);
                } else {
                    _this.close.addEventListener('click', () => {
                        axSlideUp(_this.targetDom, () => {
                            _this.targetDom.remove();
                            'hidden' in _this.handlers ? _this.emit('hidden', '') : null;
                        });
                    }, false);
                }
            } else {
                let _item = axMessages.find(item => {
                    return item.postion == position;
                });
                _item.parent.insertAdjacentElement('beforeend', _this.targetDom);
                axSlideDown(_this.targetDom, () => {
                    'shown' in _this.handlers ? _this.emit('shown', '') : null;
                });
                if (!_this.options.close) {
                    _this.options.progress && _this.progress ? _this.progress.style.cssText += `width:0;` : null;
                    setTimeout(() => {
                        axSlideUp(_this.targetDom, () => {
                            _this.targetDom.remove();
                            'hidden' in _this.handlers ? _this.emit('hidden', '') : null;
                        });
                    }, this.options.delay);
                } else {
                    _this.close.addEventListener('click', () => {
                        axSlideUp(_this.targetDom, () => {
                            _this.targetDom.remove();
                            'hidden' in _this.handlers ? _this.emit('hidden', '') : null;
                        });
                    }, false);
                }
            }
        }
        switch (this.options.placement) {
            case 'left-top':
                this.event('left-top');
                break;
            case 'center-top':
                this.event('center-top');
                break;
            case 'right-top':
                this.event('right-top');
                break;
            case 'left-center':
                this.event('left-center');
                break;
            case 'center-center':
                this.event('center-center');
                break;
            case 'right-center':
                this.event('right-center');
                break;
            case 'left-bottom':
                this.event('left-bottom');
                break;
            case 'center-bottom':
                this.event('center-bottom');
                break;
            case 'right-bottom':
                this.event('right-bottom');
                break;
            case 'left':
                this.event('left-top');
                break;
            case 'top':
                this.event('center-top');
                break;
            case 'right':
                this.event('right-top');
                break;
            case 'center':
                this.event('center-center');
                break;
            default:
                this.event('center-top');
        }
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
* 插件：纵向折叠菜单；使用方法：new axMenu('#id',{参数})
*/
const axMenus = [];
class axMenu {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            active: '',
            disabled: '',
            toggle: true,
            cookie: '',
            collapse: true,
            trigger: 'click',
            dispose: false,
            url: '',
            row: false,
            headerWidth: '',
            dropWidth: '',
            gutter: '',
        }, options, this.targetDom);
        let _this = this;
        this.handlers = {};
        this.ul = this.targetDom.querySelectorAll('ul');
        this.li = this.targetDom.querySelectorAll('li');
        this.a = this.targetDom.querySelectorAll('a');
        this.showUl = function (elem, i) {
            let parent = elem.parentElement;
            'show' in _this.handlers ? _this.emit('show', i) : null;
            parent.classList.add('ax-active');
            elem.setAttribute('aria-expand', 'true');
            axSlideDown(parent.querySelector('ul'), () => {
                'shown' in _this.handlers ? _this.emit('shown', i) : null;
            });
        }
        this.closeUl = function (elem, i) {
            let parent = elem.parentElement;
            'hide' in _this.handlers ? _this.emit('hide', i) : null;
            parent.classList.remove('ax-active');
            elem.setAttribute('aria-expand', 'false');
            axSlideUp(parent.querySelector('ul'), function () {
                'hidden' in _this.handlers ? _this.emit('hidden', i) : null;
            });
        }
        this.event = function () {
            let dom = this.parentElement,
                domOther = axSiblings(dom),
                aOther = [..._this.a].filter(item => {
                    return item !== this;
                }),
                i = '';
            _this.li.forEach((elem, index) => {
                if (elem == dom) {
                    i = index;
                }
            });
            if (this.getAttribute('aria-child') == 'false') {
                this.classList.add('ax-selected');
                aOther.forEach(item => {
                    item.classList.remove('ax-selected');
                });
                'selected' in _this.handlers ? _this.emit('selected', i) : null;
            }
            if (dom.querySelector('ul')) {
                if (window.getComputedStyle(dom.querySelector('ul')).display === 'none') {
                    _this.showUl(this,i);
                    if (_this.options.toggle && domOther) {
                        domOther.forEach(elem => {
                            elem.classList.remove('ax-active');
                            if (elem.querySelector('ul')) {
                                axSlideUp(elem.querySelector('ul'));
                            }
                        })
                    }
                } else {
                    _this.closeUl(this,i);
                }
            }
            if (_this.options.cookie) {
                axCookie.set(_this.options.cookie, i);
            }
        }
        !!this.targetDom.getAttribute('axMenu') ? this.referName = this.targetDom.getAttribute('axMenu') : this.referName = '';
        this.init();
    }
    init() {
        let _this = this,
            aSelected = [],
            aDisabled = [];
        if (this.options.row) {
            this.targetDom.classList.add('ax-menu-row');
            if (this.options.headerWidth) {
                axChildren(this.targetDom, 'li').forEach(item => {
                    item.style.width = this.options.headerWidth;
                });
            }
            if (this.options.gutter) {
                axChildren(this.targetDom, 'li').forEach(item => {
                    item.style.marginLeft = this.options.gutter;
                    item.style.marginRight = this.options.gutter;
                });
            }
            if (this.options.dropWidth) {
                axChildren(this.targetDom, 'li').forEach(item => {
                    let ul = item.querySelector('ul');
                    if (ul) {
                        ul.style.width = this.options.dropWidth;
                    }
                });
            }
        }
        if (this.options.active) {
            aSelected = aSelected.concat(axArrToDom(this.options.active));
        }
        if (this.targetDom.querySelectorAll('a.ax-selected')) {
            aSelected = aSelected.concat([...this.targetDom.querySelectorAll('.ax-selected')]);
        }
        if (this.options.disabled) {
            aDisabled = aDisabled.concat(axArrToDom(this.options.disabled));
        }
        if (this.targetDom.querySelectorAll('[aria-disabled=true]')) {
            aDisabled = aDisabled.concat([...this.targetDom.querySelectorAll('[aria-disabled=true]')]);
        }
        if (!this.options.collapse) {
            this.li.forEach(item => {
                item.classList.add('ax-active');
            });
            this.ul.forEach(item => {
                axSlideDown(item);
            });
        }
        if (!axIsEmpty(aSelected)) {
            aSelected.forEach(item => {
                axParents(item.parentElement, this.targetDom, true, false).forEach(elem => {
                    if (elem.nodeName == 'LI') {
                        elem.classList.add('ax-active');
                        elem.querySelector('a').setAttribute('aria-expand', 'true');
                        if (!elem.querySelector('ul')) {
                            elem.querySelector('a').classList.add('ax-selected');
                        }
                    } else if (elem.nodeName == 'UL') {
                        axSlideDown(elem);
                    }
                });
                item.parentElement.classList.add('ax-active');
                axSiblings(item, false, 'ul')[0] ? axSlideDown(axSiblings(item, false, 'ul')[0]) : null;
            });
        } else if (!this.options.active && this.options.cookie) {
            let _cookie = axCookie.get(this.options.cookie),
                cookieDom = this.targetDom.querySelectorAll('li')[_cookie];
            if (cookieDom) {
                axParents(cookieDom, this.targetDom, true, false).forEach(elem => {
                    if (elem.nodeName == 'LI') {
                        elem.classList.add('ax-active');
                        elem.querySelector('a').setAttribute('aria-expand', 'true');
                        if (!elem.querySelector('ul')) {
                            elem.querySelector('a').classList.add('ax-selected');
                        }
                    } else if (elem.nodeName == 'UL') {
                        axSlideDown(elem);
                    }
                });
                cookieDom.querySelector('ul') ? axSlideDown(cookieDom.querySelector('ul')) : null;
            }
        }
        for (let i = 0; i < this.li.length; i++) {
            let _li = this.li[i],
                _a = _li.querySelector('a');
            if (!_li.querySelector('ul')) {
                _a.setAttribute('aria-child', 'false');
                _a.setAttribute('aria-expand', 'false');
            }
            if (this.options.dispose) {
                _a.removeEventListener('click', this.event, false);
            } else {
                if (aDisabled.indexOf(_a) < 0) {
                    if (this.options.trigger == 'hover' && this.options.row && _a.nextElementSibling) {
                        if (_a.nextElementSibling.nodeName == 'UL') {
                            new axHover(_a, {
                                enter: () => {
                                    _this.showUl(_a,i);
                                },
                                leave: () => {
                                    _this.closeUl(_a,i);
                                },
                                hold: _a.nextElementSibling,
                            });
                        }
                    } else {
                        _a.addEventListener('click', this.event, false);
                    }
                } else {
                    _a.removeEventListener('click', this.event, false);
                }
            }
        }
        if (this.referName) {
            if (axIsEmpty(axMenus)) {
                axMenus.push({ name: this.referName, instance: this });
            } else {
                if (!axMenus.some(item => (item.name == this.referName))) {
                    axMenus.push({ name: this.referName, instance: this });
                }
                /* for (let i = 0; i < axMenus.length; i++) {
                    if (axMenus[i].name == this.referName) {
                        axMenus[i].instance = this;
                        break;
                    } else {
                        axMenus.push({ name: this.referName, instance: this });
                    }
                } */
            }
        }
        'load' in this.handlers ? this.emit('load', '') : null;
    }
    update(setting, callback) {
        let _this = this;
        this.options = axExtend(this.options, setting);
        if (this.options.url) {
            axAjax({
                url: _this.options.url,
                success: (data) => {
                    _this.targetDom.appendChild(axStrToDom(data));
                    _this.li = _this.targetDom.querySelectorAll('li');
                    _this.init();
                }
            });
        }
        this.init();
        'update' in this.handlers ? this.emit('update', '') : null;
        callback && callback.call(this);
        return this;
    }
    openAll(){
    }
    closeAll(){
    }
    open(index){
    }
    close(index){
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axMenu]').forEach(element => {
        new axMenu(element);
    });
})();
/*!
* 插件：黏住顶部或盒子；使用方法：new axStick('#id',{参数})
*/
const axSticks = [];
class axStick {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            refer: 'body',
            space: '0px',
            width: '',
            zIndex: '',
        }, options, this.targetDom);
        let _this = this;
        this.handlers = {};
        this.height = this.targetDom.offsetHeight;
        this.width = this.targetDom.offsetWidth;
        this.left = axOffset(this.targetDom).left;
        this.top = axOffset(this.targetDom).top;
        this.bottom = axOffset(this.targetDom).top + this.height;
        this.style = this.targetDom.getAttribute('style');
        this.placeholder = axAddElem('DIV', { style: `width:${this.width}px;height:${this.height}px;display:none;` });
        this.targetDom.insertAdjacentElement('beforebegin', this.placeholder);
        !!this.targetDom.getAttribute('axStick') ? this.referName = this.targetDom.getAttribute('axStick') : this.referName = '';
        this.init();
    }
    init() {
        this.refer = this.targetDom.closest(this.options.refer);
        this.referHeight = this.refer.offsetHeight;
        this.referWidth = this.refer.offsetWidth;
        this.referLeft = axOffset(this.refer).left;
        this.referTop = axOffset(this.refer).top;
        this.referBottom = axOffset(this.refer).top + this.referHeight;
        if (this.options.refer !== 'body' && (getComputedStyle(this.refer).position !== 'fixed' || getComputedStyle(this.refer).position !== 'absolute')) {
            this.refer.style.position = 'relative';
        }
        this.options.zIndex ? this.targetDom.style.zIndex = this.options.zIndex : null;
        getComputedStyle(this.targetDom).float !== 'none' ? this.placeholder.style.float = getComputedStyle(this.targetDom).float : null;
        let _this = this;
        window.addEventListener("scroll", () => {
            if (_this.height > window.innerHeight) {
                if (_this.bottom < document.documentElement.scrollTop + window.innerHeight && _this.referBottom > document.documentElement.scrollTop + window.innerHeight) {
                    _this.targetDom.style.cssText += `width:${_this.targetDom.offsetWidth}px;`;
                    _this.targetDom.style.cssText += `left:${axOffset(_this.targetDom).left}px;`
                    _this.targetDom.style.cssText += `position:fixed;bottom:${_this.options.space};margin:0;`;
                    _this.placeholder.style.display = 'block';
                    'sticked' in _this.handlers ? _this.emit('sticked', 'fixed') : null;
                } else if (_this.referBottom < document.documentElement.scrollTop + window.innerHeight) {
                    _this.targetDom.style.position = 'absolute';
                    _this.targetDom.style.left = _this.left - _this.referLeft + 'px';
                    _this.targetDom.style.cssText += `position:absolute;bottom:${_this.options.space};margin:0;`;
                    _this.placeholder.style.display = 'none';
                    'sticked' in _this.handlers ? _this.emit('sticked', 'absolute') : null;
                } else if (axOffset(_this.refer).top > document.documentElement.scrollTop) {
                    _this.targetDom.setAttribute('style', _this.style);
                    _this.placeholder.style.display = 'none';
                    'unsticked' in _this.handlers ? _this.emit('unsticked', '') : null;
                }
            } else {
                if (_this.top < document.documentElement.scrollTop) {
                    if (!_this.options.width) {
                        _this.targetDom.style.cssText += `width:${_this.targetDom.offsetWidth}px;`;
                        _this.targetDom.style.cssText += `left:${_this.left}px;`
                    } else {
                        _this.targetDom.style.cssText += `width:${_this.options.width};`;
                        _this.targetDom.style.cssText += `left:calc(50% - ${_this.options.width}/2);`;
                    }
                    _this.targetDom.style.cssText += `position:fixed;top:${_this.options.space};bottom:auto;margin:0;`;
                    _this.placeholder.style.display = 'block';
                    'sticked' in _this.handlers ? _this.emit('sticked', 'fixed') : null;
                    if (_this.height > _this.referBottom - document.documentElement.scrollTop) {
                        _this.targetDom.style.position = 'absolute';
                        _this.targetDom.style.left = _this.left - _this.referLeft + 'px';
                        _this.targetDom.style.top = 'auto';
                        _this.targetDom.style.bottom = 0;
                        'sticked' in _this.handlers ? _this.emit('sticked', 'absolute') : null;
                    }
                } else {
                    _this.targetDom.setAttribute('style', _this.style);
                    _this.placeholder.style.display = 'none';
                    'unsticked' in _this.handlers ? _this.emit('unsticked', '') : null;
                }
            }
        }, false);
        if (this.referName) {
            if (axIsEmpty(axSticks)) {
                axSticks.push({ name: this.referName, instance: this });
            } else {
                if (!axSticks.some(item => (item.name == this.referName))) {
                    axSticks.push({ name: this.referName, instance: this });
                }
                /* for (let i = 0; i < axSticks.length; i++) {
                    if (axSticks[i].name == this.referName) {
                        axSticks[i].instance = this;
                        break;
                    } else {
                        axSticks.push({ name: this.referName, instance: this });
                    }
                } */
            }
        }
    }
    destroy(callback) {
        this.targetDom.lastChild.removeEventListener('click', this.event, false);
        this.targetDom.innerHTML = this.html;
        callback && callback.call(this);
    }
    update(setting, callback) {
        let _this = this;
        this.targetDom.style = this.style;
        this.options = axExtend(this.options, setting);
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axStick]').forEach(element => {
        new axStick(element);
    });
})();
/*!
* 插件：轮滑选择；改造自mobile-select 20201110更新 https://github.com/onlyhom/mobile-select；使用方法：new axScrollSelect('#id',{参数})
*/
const axScrollSelects = [];
(() => {
    const getClass = (dom, string) => {
        return dom.getElementsByClassName(string);
    }
    const wheel = (dom, handle, callback, capture) => {
        let eventCompat = function (event) {
            let type = event.type;
            if (type == 'DOMMouseScroll' || type == 'mousewheel') {
                event.delta = (event.wheelDelta) ? event.wheelDelta / 120 : -(event.detail || 0) / 3;
            }
            if (event.srcElement && !event.target) {
                event.target = event.srcElement;
            }
            axPreventDefault(event);
            /* if (!event.preventDefault && event.returnValue !== undefined) {
                event.preventDefault = function () {
                    event.returnValue = false;
                };
            } */
            return event;
        };
        return function () {
            if (handle === "mousewheel" && document.mozFullScreen !== undefined) {
                handle = "DOMMouseScroll";
            }
            dom.addEventListener(handle, function (event) {
                callback.call(this, eventCompat(event));
            }, capture || false);
        }();
    }
    class axScrollSelect {
        constructor(targetDom, options) {
            this.targetDom = axIdToDom(targetDom);
            this.options = axExtend({
                wheels: [],
                title: '',
                position: [],
                final: false,
                connector: ' ',
                confirmText: '确认',
                cancelText: '取消',
                className: '',
                type: 'actionbar',
                labels: '',
                keyMap: { id: 'id', name: 'name', value: 'value', children: 'children' },
                triggerDisplayData: true,
                callback: function () { },
                transitionEnd: function () { },
                cancel: function () { },
                onShow: function () { },
                onHide: function () { },
            }, options, this.targetDom);
            this.jsonType = false;
            this.cascadeJsonData = [];
            this.displayJson = [];
            this.curValue = null;
            this.curIndexArr = [];
            this.cascade = false;
            this.startY;
            this.moveEndY;
            this.moveY;
            this.oldMoveY;
            this.offset = 0;
            this.offsetSum = 0;
            this.oversizeBorder;
            this.curDistance = [];
            this.clickStatus = false;
            this.init();
            this.targetDom.setAttribute('autocomplete', 'off');
            this.targetDom.setAttribute('readonly', 'true');
        }
        init() {
            let _this = this;
            if (typeof _this.options.wheels === 'string' && _this.options.wheels.indexOf('#') != -1) {
                if (document.querySelector(_this.options.wheels).nodeName == 'UL') {
                    _this.options.wheels = [{ data: axUlToArr(_this.options.wheels) }]
                } else if (document.querySelector(_this.options.wheels).nodeName == 'SELECT') {
                    _this.options.wheels = [{ data: axSelectToArr(_this.options.wheels) }]
                }
            } else if (_this.options.wheels.indexOf('date') == 0) {
                let dateArr = _this.options.wheels.split("-"),
                    dateStart = dateArr[1],
                    dateEnd = dateArr[2],
                    dateFormat = dateArr[3];
                _this.options.wheels = _this.getDate(dateStart, dateEnd, dateFormat);
            }
            _this.checkDataType();
            _this.renderWheels(_this.options.wheels, this.options.cancelText, this.options.confirmText);
            if (!_this.targetDom) {
                console.error('SwiperSelect instance has been created , but there is no trigger is found on page.');
                return false;
            }
            _this.targetDom.style.cursor = 'pointer';
            _this.checkCascade();
            _this.addListenerAll();
            if (_this.cascade) {
                _this.initCascade();
            }
            let colHTML = '';
            for (let i = 0; i < _this.wheel.length; i++) {
                if (!axIsEmpty(_this.options.labels)) {
                    colHTML += '<li>' + _this.options.labels[i] + '</li>';
                }
            }
            _this.group.innerHTML = colHTML;
            if (_this.options.position.length < _this.slider.length) {
                let diff = _this.slider.length - _this.options.position.length;
                for (let i = 0; i < diff; i++) {
                    _this.options.position.push(0);
                }
            }
            _this.setCurDistance(_this.options.position);
            _this.cancelBtn.addEventListener('click', function (event) {
                _this.hide();
                _this.popup ? _this.popup.hide() : null;
            });
            _this.ensureBtn.addEventListener('click', function (event) {
                _this.hide();
                _this.popup ? _this.popup.hide() : null;
                if (!_this.liHeight) {
                    _this.liHeight = _this.mobileSelect.querySelector('li').offsetHeight;
                }
                _this.setValue();
                _this.curIndexArr = _this.getIndexArr();
                _this.curValue = _this.getCurValue();
                _this.options.callback.call(_this, _this.curIndexArr, _this.curValue);
            });
            _this.targetDom.addEventListener('click', function (event) {
                _this.show();
            });
            if (_this.grayLayer) {
                _this.grayLayer.addEventListener('click', function (event) {
                    _this.hide();
                });
            }
            _this.wrapper.addEventListener('click', function (event) {
                event.stopPropagation();
            });
            _this.fixRowStyle(); 
        }
        setValue(value) {
            let _this = this;
            let tempValue = '';
            if (_this.options.final) {
                tempValue = _this.getCurValue()[_this.getCurValue().length - 1].value;
            } else {
                for (let i = 0; i < _this.wheel.length; i++) {
                    i == _this.wheel.length - 1 ? tempValue += _this.getInnerHtml(i) : tempValue += _this.getInnerHtml(i) + _this.options.connector;
                }
            }
            if (_this.options.triggerDisplayData) {
                if (_this.targetDom.nodeName == 'INPUT') {
                    value ? _this.targetDom.value = value : _this.targetDom.value = tempValue;
                } else {
                    value ? _this.targetDom.innerHTML = value : _this.targetDom.innerHTML = tempValue;
                }
            }
        }
        getDate(start, end, format) {
            let _this = this,
                _start = start,
                _end = end,
                loadArr = [];
            let now = new Date();
            if (_start == 'auto' && _end == 'auto') {
                start = now.getFullYear() - 20;
                end = now.getFullYear();
                now.getDate()
                loadArr.push(0, now.getMonth());
            } else if (_end > _start) {
                loadArr.push(0, 0);
            }
            let dateData = [{ data: [] }];
            let returnDayLen = function (year, month) {
                if ([1,3,5,7,8,10,12].includes(month)) {
                    return 31
                } else if (month == 2) {
                    if (year % 4 == 0 && year % 100 != 0) {
                        return 29
                    } else if (year % 400 == 0) {
                        return 29
                    } else {
                        return 28
                    }
                } else {
                    return 30
                }
            };
            for (let i = end; i >= start; i--) {
                if (i == 0) {
                    return;
                }
                let data = { id: i, name: i + "年", value: i, children: [] };
                for (let k = 1; k <= 12; k++) {
                    if (format.toUpperCase() == 'YMD') {
                        let dayArr = [];
                        let len = returnDayLen(i, k);
                        for (let x = 1; x <= len; x++) {
                            dayArr.push({ id: x, name: x + "日", value: x })
                        }
                        data.children.push({ id: k, name: k + "月", value: k, children: dayArr });
                        if (_start == 'auto' && _end == 'auto') {
                            loadArr.push(now.getDate() - 1);
                        } else if (_end > _start) {
                            loadArr.push(0);
                        }
                    } else if (format.toUpperCase() == 'YM') {
                        data.children.push({ id: k, name: k + "月", value: k });
                    }
                }
                dateData[0].data.push(data);
            }
            axIsEmpty(_this.options.position) ? _this.options.position = loadArr : null;
            _this.options.connector = '-';
            return dateData
        }
        show() {
            this.mobileSelect.classList.add('ax-show');
            if (typeof this.options.onShow === 'function') {
                this.options.onShow(this);
            }
        }
        hide() {
            this.mobileSelect.classList.remove('ax-show');
            if (typeof this.options.onHide === 'function') {
                this.options.onHide(this);
            }
        }
        renderWheels(wheelsData) {
            let _this = this;
            let tempHTML = '';
            for (let i = 0; i < wheelsData.length; i++) {
                tempHTML += '<div class="ax-wheel"><ul class="ax-item-list">';
                if (_this.jsonType) {
                    for (let j = 0; j < wheelsData[i].data.length; j++) {
                        tempHTML += '<li data-id="' + wheelsData[i].data[j][_this.options.keyMap.id] + '">' + wheelsData[i].data[j][_this.options.keyMap.name] + '</li>';
                    }
                } else {
                    for (let j = 0; j < wheelsData[i].data.length; j++) {
                        tempHTML += '<li>' + wheelsData[i].data[j] + '</li>';
                    }
                }
                tempHTML += '</ul></div>';
            }
            if (!this.options.title) {
                if (this.targetDom.nodeName == 'INPUT') {
                    if (this.targetDom.getAttribute('placeholder')) {
                        this.options.title = this.targetDom.getAttribute('placeholder');
                    } else if (this.targetDom.getAttribute('value')) {
                        this.options.title = this.targetDom.getAttribute("value");
                    } else {
                        this.options.title = '';
                    }
                } else {
                    this.options.title = this.targetDom.textContent.trim().replace(/<[^>]+>/g, '').replace(/ +/g, ' ');
                }
            }
            this.template =
                axTplEngine(`
            <div class="ax-scrollSelect<# if(this.className){ #> <# this.className #><# } #>" data-type="<# this.type #>" id="scrollSelect${new Date().getTime()}">
            <# if(this.type == 'actionbar'){ #><div class="ax-scrollSelect-overlay"></div><# } #>
            <div class="ax-scrollSelect-wrapper">
                <div class="ax-scrollSelect-header">
                    <div class="ax-inner">
                        <a href="###" class="ax-cancel"><# this.cancelText #></a>
                        <div class="ax-title"><# this.title #></div>
                        <a href="###" class="ax-confirm"><# this.confirmText #></a>
                    </div>
                </div>
                <div class="ax-group"></div>
                <div class="ax-scrollSelect-body">
                    <div class="ax-inner">
                        <div class="ax-wheels"></div>
                        <div class="ax-line"></div>
                        <div class="ax-mask"></div>
                    </div>
                </div>
            </div>
        </div>
          `, this.options);
            _this.mobileSelect = axStrToDom(this.template);
            _this.wheels = _this.mobileSelect.querySelector('.ax-wheels')
            _this.wheels.innerHTML = tempHTML;
            if (_this.options.type == 'actionbar') {
                document.body.appendChild(_this.mobileSelect);
            } else if (_this.options.type == 'popup') {
                _this.popup = new axPopup(this.targetDom, {
                    content: _this.mobileSelect,
                    padding: false,
                    placement: 'bottom-start',
                    close: false,
                    footerShow: false,
                });
            } else if (_this.options.type == 'inline') {
                _this.targetDom.insertAdjacentElement('afterEnd', _this.mobileSelect);
                _this.header = _this.mobileSelect.querySelector('.ax-scrollSelect-header');
                _this.header.style.display = 'none';
            }
            _this.wheel = getClass(_this.mobileSelect, 'ax-wheel');
            _this.slider = getClass(_this.mobileSelect, 'ax-item-list');
            _this.wheels = _this.mobileSelect.querySelector('.ax-wheels');
            _this.liHeight = _this.mobileSelect.querySelector('li').offsetHeight;
            _this.ensureBtn = _this.mobileSelect.querySelector('.ax-confirm');
            _this.cancelBtn = _this.mobileSelect.querySelector('.ax-cancel');
            _this.grayLayer = _this.mobileSelect.querySelector('.ax-scrollSelect-overlay');
            _this.wrapper = _this.mobileSelect.querySelector('.ax-scrollSelect-wrapper');
            _this.body = _this.mobileSelect.querySelector('.ax-scrollSelect-body');
            _this.group = _this.mobileSelect.querySelector('.ax-group');
            _this.title = _this.mobileSelect.querySelector('.ax-title');
            axPreventScroll(_this.wrapper);
        }
        addListenerAll() {
            let _this = this;
            for (let i = 0; i < _this.slider.length; i++) {
                (function (i) {
                    _this.addListenerWheel(_this.wheel[i], i);
                })(i);
            }
        }
        addListenerWheel(theWheel, index) {
            let _this = this;
            theWheel.addEventListener('touchstart', function (event) {
                _this.touch(event, this.firstChild, index);
            }, false);
            theWheel.addEventListener('touchend', function (event) {
                _this.touch(event, this.firstChild, index);
            }, false);
            theWheel.addEventListener('touchmove', function (event) {
                _this.touch(event, this.firstChild, index);
            }, false);
            if (!axIsMobi()) {
                theWheel.addEventListener('mousedown', function (event) {
                    _this.dragClick(event, this.firstChild, index);
                }, false);
                theWheel.addEventListener('mousemove', function (event) {
                    _this.dragClick(event, this.firstChild, index);
                }, false);
                theWheel.addEventListener('mouseup', function (event) {
                    _this.dragClick(event, this.firstChild, index);
                }, true);
                wheel(theWheel, "mousewheel", function (event) {
                    if (event.delta < 0) {
                        event.direction = 'wheelUp';
                    } else if (event.delta > 0) {
                        event.direction = 'wheelDown';
                    }
                    _this.dragClick(event, this.firstChild, index);
                });
            }
        }
        checkDataType() {
            let _this = this;
            if (typeof (_this.options.wheels[0].data[0]) == 'object') {
                _this.jsonType = true;
            }
        }
        checkCascade() {
            let _this = this;
            if (_this.jsonType) {
                let node = _this.options.wheels[0].data;
                for (let i = 0; i < node.length; i++) {
                    if (_this.options.keyMap.children in node[i] && node[i][_this.options.keyMap.children].length > 0) {
                        _this.cascade = true;
                        _this.cascadeJsonData = _this.options.wheels[0].data;
                        break;
                    }
                }
            } else {
                _this.cascade = false;
            }
        }
        generateArrData(targetArr) {
            let tempArr = [];
            let keyMap_id = this.options.keyMap.id;
            let keyMap_value = this.options.keyMap.value;
            let keyMap_name = this.options.keyMap.name;
            for (let i = 0; i < targetArr.length; i++) {
                let tempObj = {};
                tempObj[keyMap_id] = targetArr[i][this.options.keyMap.id];
                tempObj[keyMap_value] = targetArr[i][this.options.keyMap.value];
                tempObj[keyMap_name] = targetArr[i][this.options.keyMap.name];
                tempArr.push(tempObj);
            }
            return tempArr;
        }
        initCascade() {
            let _this = this;
            _this.displayJson.push(_this.generateArrData(_this.cascadeJsonData));
            if (_this.options.position.length > 0) {
                _this.initDeepCount = 0;
                _this.initCheckArrDeep(_this.cascadeJsonData[_this.options.position[0]]);
            } else {
                _this.checkArrDeep(_this.cascadeJsonData[0]);
            }
            _this.reRenderWheels();
        }
        initCheckArrDeep(parent) {
            let _this = this;
            if (parent) {
                if (_this.options.keyMap.children in parent && parent[_this.options.keyMap.children].length > 0) {
                    _this.displayJson.push(_this.generateArrData(parent[_this.options.keyMap.children]));
                    _this.initDeepCount++;
                    let nextNode = parent[_this.options.keyMap.children][_this.options.position[_this.initDeepCount]];
                    if (nextNode) {
                        _this.initCheckArrDeep(nextNode);
                    } else {
                        _this.checkArrDeep(parent[_this.options.keyMap.children][0]);
                    }
                }
            }
        }
        checkArrDeep(parent) {
            let _this = this;
            if (parent) {
                if (_this.options.keyMap.children in parent && parent[_this.options.keyMap.children].length > 0) {
                    _this.displayJson.push(_this.generateArrData(parent[_this.options.keyMap.children])); 
                    _this.checkArrDeep(parent[_this.options.keyMap.children][0]);
                }
            }
        }
        checkRange(index, posIndexArr) {
            let _this = this;
            let deleteNum = _this.displayJson.length - 1 - index;
            for (let i = 0; i < deleteNum; i++) {
                _this.displayJson.pop(); 
            }
            let resultNode;
            for (let i = 0; i <= index; i++) {
                if (i == 0)
                    resultNode = _this.cascadeJsonData[posIndexArr[0]];
                else {
                    resultNode = resultNode[_this.options.keyMap.children][posIndexArr[i]];
                }
            }
            _this.checkArrDeep(resultNode);
            _this.reRenderWheels();
            _this.fixRowStyle();
            _this.setCurDistance(_this.resetPosition(index, posIndexArr));
        }
        resetPosition(index, posIndexArr) {
            let _this = this;
            let tempPosArr = posIndexArr;
            let tempCount;
            if (_this.slider.length > posIndexArr.length) {
                tempCount = _this.slider.length - posIndexArr.length;
                for (let i = 0; i < tempCount; i++) {
                    tempPosArr.push(0);
                }
            } else if (_this.slider.length < posIndexArr.length) {
                tempCount = posIndexArr.length - _this.slider.length;
                for (let i = 0; i < tempCount; i++) {
                    tempPosArr.pop();
                }
            }
            for (let i = index + 1; i < tempPosArr.length; i++) {
                tempPosArr[i] = 0;
            }
            return tempPosArr;
        }
        reRenderWheels() {
            let _this = this;
            if (_this.wheel.length > _this.displayJson.length) {
                let count = _this.wheel.length - _this.displayJson.length;
                for (let i = 0; i < count; i++) {
                    _this.wheels.removeChild(_this.wheel[_this.wheel.length - 1]);
                }
            }
            for (let i = 0; i < _this.displayJson.length; i++) {
                (function (i) {
                    let tempHTML = '';
                    if (_this.wheel[i]) {
                        for (let j = 0; j < _this.displayJson[i].length; j++) {
                            let name = _this.displayJson[i][j][_this.options.keyMap.name] ? _this.displayJson[i][j][_this.options.keyMap.name] : _this.displayJson[i][j][_this.options.keyMap.value];
                            tempHTML += '<li data-id="' + _this.displayJson[i][j][_this.options.keyMap.id] + '" data-value="' + _this.displayJson[i][j][_this.options.keyMap.value] + '" >'
                                + name + '</li>';
                        }
                        _this.slider[i].innerHTML = tempHTML;
                    } else {
                        let tempWheel = document.createElement("div");
                        tempWheel.className = "ax-wheel";
                        tempHTML = '<ul class="ax-item-list">';
                        for (let j = 0; j < _this.displayJson[i].length; j++) {
                            let name = _this.displayJson[i][j][_this.options.keyMap.name] ? _this.displayJson[i][j][_this.options.keyMap.name] : _this.displayJson[i][j][_this.options.keyMap.value];
                            tempHTML += '<li data-id="' + _this.displayJson[i][j][_this.options.keyMap.id] + '" data-value="' + _this.displayJson[i][j][_this.options.keyMap.value] + '">'
                                + name + '</li>';
                        }
                        tempHTML += '</ul>';
                        tempWheel.innerHTML = tempHTML;
                        _this.addListenerWheel(tempWheel, i);
                        _this.wheels.appendChild(tempWheel);
                    }
                })(i);
            }
            let colHTML = '';
            for (let i = 0; i < _this.wheel.length; i++) {
                if (!axIsEmpty(_this.options.labels)) {
                    colHTML += '<li>' + _this.options.labels[i] + '</li>';
                }
            }
            _this.group.innerHTML = colHTML;
        }
        updateWheels(data) {
            let _this = this;
            if (_this.cascade) {
                _this.cascadeJsonData = data;
                _this.displayJson = [];
                _this.initCascade();
                if (_this.options.position.length < _this.slider.length) {
                    let diff = _this.slider.length - _this.options.position.length;
                    for (let i = 0; i < diff; i++) {
                        _this.options.position.push(0);
                    }
                }
                _this.setCurDistance(_this.options.position);
                _this.fixRowStyle();
            }
        }
        updateWheel(sliderIndex, data) {
            let _this = this;
            let tempHTML = '';
            if (_this.cascade) {
                console.error('级联格式不支持updateWheel(),请使用updateWheels()更新整个数据源');
                return false;
            }
            else if (_this.jsonType) {
                for (let j = 0; j < data.length; j++) {
                    let name = data[j][_this.options.keyMap.name] ? data[j][_this.options.keyMap.name] : data[j][_this.options.keyMap.value];
                    tempHTML += '<li data-id="' + data[j][_this.options.keyMap.id] + '" data-value="' + data[j][_this.options.keyMap.value] + '">'
                        + name + '</li>';
                }
                _this.options.wheels[sliderIndex] = { data: data };
            } else {
                for (let j = 0; j < data.length; j++) {
                    tempHTML += '<li>' + data[j] + '</li>';
                }
                _this.options.wheels[sliderIndex] = data;
            }
            _this.slider[sliderIndex].innerHTML = tempHTML;
        }
        fixRowStyle() {
            let _this = this;
            let width = (100 / _this.wheel.length).toFixed(2);
            for (let i = 0; i < _this.wheel.length; i++) {
                _this.wheel[i].style.width = width + '%';
            }
        }
        getIndex(distance) {
            return Math.round((2 * this.liHeight - distance) / this.liHeight);
        }
        getIndexArr() {
            let _this = this;
            let temp = [];
            for (let i = 0; i < _this.curDistance.length; i++) {
                temp.push(_this.getIndex(_this.curDistance[i]));
            }
            return temp;
        }
        getCurValue() {
            let _this = this;
            let temp = [];
            let positionArr = _this.getIndexArr();
            if (_this.cascade) {
                for (let i = 0; i < _this.wheel.length; i++) {
                    temp.push(_this.displayJson[i][positionArr[i]]);
                }
            }
            else if (_this.jsonType) {
                for (let i = 0; i < _this.curDistance.length; i++) {
                    temp.push(_this.options.wheels[i].data[_this.getIndex(_this.curDistance[i])]);
                }
            } else {
                for (let i = 0; i < _this.curDistance.length; i++) {
                    temp.push(_this.getInnerHtml(i));
                }
            }
            return temp;
        }
        getValue() {
            return this.curValue;
        }
        calcDistance(index) {
            return 2 * this.liHeight - index * this.liHeight;
        }
        setCurDistance(indexArr) {
            let _this = this;
            let temp = [];
            for (let i = 0; i < _this.slider.length; i++) {
                temp.push(_this.calcDistance(indexArr[i]));
                _this.movePosition(_this.slider[i], temp[i]);
            }
            _this.curDistance = temp;
        }
        fixPosition(distance) {
            return -(this.getIndex(distance) - 2) * this.liHeight;
        }
        movePosition(theSlider, distance) {
            theSlider.style.webkitTransform = 'translate3d(0,' + distance + 'px, 0)';
            theSlider.style.transform = 'translate3d(0,' + distance + 'px, 0)';
        }
        locatePosition(index, posIndex) {
            let _this = this;
            this.curDistance[index] = this.calcDistance(posIndex);
            this.movePosition(this.slider[index], this.curDistance[index]);
            if (_this.cascade) {
                _this.checkRange(index, _this.getIndexArr());
            }
        }
        updateCurDistance(theSlider, index) {
            if (theSlider.style.transform) {
                this.curDistance[index] = parseInt(theSlider.style.transform.split(',')[1]);
            } else {
                this.curDistance[index] = parseInt(theSlider.style.webkitTransform.split(',')[1]);
            }
        }
        getDistance(theSlider) {
            if (theSlider.style.transform) {
                return parseInt(theSlider.style.transform.split(',')[1]);
            } else {
                return parseInt(theSlider.style.webkitTransform.split(',')[1]);
            }
        }
        getInnerHtml(sliderIndex) {
            let _this = this;
            let lengthOfList = _this.slider[sliderIndex].getElementsByTagName("li").length;
            let index = _this.getIndex(_this.curDistance[sliderIndex]);
            if (index >= lengthOfList) {
                index = lengthOfList - 1;
            } else if (index < 0) {
                index = 0;
            }
            if (_this.slider[sliderIndex].getElementsByTagName('li')[index].getAttribute('data-value')) {
                return _this.slider[sliderIndex].getElementsByTagName('li')[index].getAttribute('data-value');
            } else {
                return _this.slider[sliderIndex].getElementsByTagName('li')[index].textContent;
            }
        }
        setActive() {
            let _this = this;
            setTimeout(function () {
                if (!axIsEmpty(_this.getIndexArr())) {
                    for (let i = 0; i < _this.getIndexArr().length; i++) {
                        let list = [..._this.wheel][i].firstChild.children;
                        for (let k = 0; k < list.length; k++) {
                            list[k].classList.remove('ax-active');
                        }
                        list[_this.getIndexArr()[i]].classList.add('ax-active');
                    }
                }
            }, 100);
        }
        setTitle() {
            let _this = this;
            let titleArr = '';
            _this.getCurValue().forEach(item => {
                if (item.name) {
                    titleArr += item.name;
                } else if (item.value) {
                    titleArr += item.value;
                } else {
                    titleArr += item;
                }
            });
            _this.title.innerHTML = titleArr;
        }
        touch(event, theSlider, index) {
            let _this = this;
            event = event || window.event;
            switch (event.type) {
                case "touchstart":
                    _this.startY = event.touches[0].clientY;
                    _this.startY = parseInt(_this.startY);
                    _this.oldMoveY = _this.startY;
                    break;
                case "touchend":
                    _this.moveEndY = parseInt(event.changedTouches[0].clientY);
                    _this.offsetSum = _this.moveEndY - _this.startY;
                    _this.oversizeBorder = -(theSlider.getElementsByTagName('li').length - 3) * _this.liHeight;
                    if (_this.offsetSum == 0) {
                        let clickOffetNum = parseInt((document.documentElement.clientHeight - _this.moveEndY) / 40);
                        if (clickOffetNum != 2) {
                            let offset = clickOffetNum - 2;
                            let newDistance = _this.curDistance[index] + (offset * _this.liHeight);
                            if ((newDistance <= 2 * _this.liHeight) && (newDistance >= _this.oversizeBorder)) {
                                _this.curDistance[index] = newDistance;
                                _this.movePosition(theSlider, _this.curDistance[index]);
                                _this.options.transitionEnd.call(_this, _this.getIndexArr(), _this.getCurValue());
                            }
                        }
                        _this.options.type == 'inline' ? _this.setValue() : null;
                        _this.setTitle()
                        _this.setActive();
                    } else {
                        _this.updateCurDistance(theSlider, index);
                        _this.curDistance[index] = _this.fixPosition(_this.curDistance[index]);
                        _this.movePosition(theSlider, _this.curDistance[index]);
                        if (_this.curDistance[index] + _this.offsetSum > 2 * _this.liHeight) {
                            _this.curDistance[index] = 2 * _this.liHeight;
                            setTimeout(function () {
                                _this.movePosition(theSlider, _this.curDistance[index]);
                            }, 100);
                        } else if (_this.curDistance[index] + _this.offsetSum < _this.oversizeBorder) {
                            _this.curDistance[index] = _this.oversizeBorder;
                            setTimeout(function () {
                                _this.movePosition(theSlider, _this.curDistance[index]);
                            }, 100);
                        }
                        _this.options.transitionEnd(_this.getIndexArr(), _this.getCurValue());
                    }
                    if (_this.cascade) {
                        _this.checkRange(index, _this.getIndexArr());
                    }
                    break;
                case "touchmove":
                    axPreventDefault(event);
                    _this.moveY = event.touches[0].clientY;
                    _this.offset = _this.moveY - _this.oldMoveY;
                    _this.updateCurDistance(theSlider, index);
                    _this.curDistance[index] = _this.curDistance[index] + _this.offset;
                    _this.movePosition(theSlider, _this.curDistance[index]);
                    _this.oldMoveY = _this.moveY;
                    break;
            }
        }
        dragClick(event, theSlider, index) {
            let _this = this;
            event = event || window.event;
            _this.oversizeBorder = -(theSlider.getElementsByTagName('li').length - 3) * _this.liHeight;
            switch (event.type) {
                case "mousedown":
                    _this.startY = event.clientY;
                    _this.oldMoveY = _this.startY;
                    _this.clickStatus = true;
                    break;
                case "mouseup":
                    _this.moveEndY = event.clientY;
                    _this.offsetSum = _this.moveEndY - _this.startY;
                    if (_this.offsetSum == 0) {
                        let clickOffetNum = parseInt((document.documentElement.clientHeight - _this.moveEndY) / 40);
                        if (clickOffetNum != 2) {
                            let offset = clickOffetNum - 2;
                            let newDistance = _this.curDistance[index] + (offset * _this.liHeight);
                            if ((newDistance <= 2 * _this.liHeight) && (newDistance >= _this.oversizeBorder)) {
                                _this.curDistance[index] = newDistance;
                                _this.movePosition(theSlider, _this.curDistance[index]);
                                _this.options.transitionEnd.call(_this, _this.getIndexArr(), _this.getCurValue());
                            }
                        }
                    } else {
                        _this.updateCurDistance(theSlider, index);
                        _this.curDistance[index] = _this.fixPosition(_this.curDistance[index]);
                        _this.movePosition(theSlider, _this.curDistance[index]);
                        if (_this.curDistance[index] + _this.offsetSum > 2 * _this.liHeight) {
                            _this.curDistance[index] = 2 * _this.liHeight;
                            setTimeout(function () {
                                _this.movePosition(theSlider, _this.curDistance[index]);
                            }, 100);
                        } else if (_this.curDistance[index] + _this.offsetSum < _this.oversizeBorder) {
                            _this.curDistance[index] = _this.oversizeBorder;
                            setTimeout(function () {
                                _this.movePosition(theSlider, _this.curDistance[index]);
                            }, 100);
                        }
                        _this.options.transitionEnd(_this.getIndexArr(), _this.getCurValue());
                    }
                    _this.clickStatus = false;
                    if (_this.cascade) {
                        _this.checkRange(index, _this.getIndexArr());
                    }
                    _this.options.type == 'inline' ? _this.setValue() : null;
                    _this.setTitle();
                    _this.setActive();
                    break;
                case "mousemove":
                    axPreventDefault(event);
                    if (_this.clickStatus) {
                        _this.moveY = event.clientY;
                        _this.offset = _this.moveY - _this.oldMoveY;
                        if (_this.liHeight)
                            _this.updateCurDistance(theSlider, index);
                        _this.curDistance[index] = _this.curDistance[index] + _this.offset;
                        _this.movePosition(theSlider, _this.curDistance[index]);
                        _this.oldMoveY = _this.moveY;
                    }
                    break;
            }
            if (event.direction == 'wheelUp') {
                _this.curDistance[index] = _this.curDistance[index] - _this.liHeight;
                _this.movePosition(theSlider, _this.curDistance[index]);
                if (_this.curDistance[index] + _this.offsetSum < _this.oversizeBorder) {
                    _this.curDistance[index] = _this.oversizeBorder;
                    setTimeout(function () {
                        _this.movePosition(theSlider, _this.curDistance[index]);
                    }, 100);
                }
                _this.clickStatus = false;
                if (_this.cascade) {
                    _this.checkRange(index, _this.getIndexArr());
                }
                _this.options.type == 'inline' ? _this.setValue() : null;
                _this.setTitle();
                _this.setActive();
                _this.options.transitionEnd.call(_this, _this.getIndexArr(), _this.getCurValue());
            } else if (event.direction == 'wheelDown') {
                _this.curDistance[index] = _this.curDistance[index] + _this.liHeight;
                _this.movePosition(theSlider, _this.curDistance[index]);
                if (_this.curDistance[index] + _this.offsetSum > 2 * _this.liHeight) {
                    _this.curDistance[index] = 2 * _this.liHeight;
                    setTimeout(function () {
                        _this.movePosition(theSlider, _this.curDistance[index]);
                    }, 100);
                }
                _this.clickStatus = false;
                if (_this.cascade) {
                    _this.checkRange(index, _this.getIndexArr());
                }
                _this.options.type == 'inline' ? _this.setValue() : null;
                _this.setTitle();
                _this.setActive();
                _this.options.transitionEnd.call(_this, _this.getIndexArr(), _this.getCurValue());
            }
        }
    }
    window.axScrollSelect = axScrollSelect;
    document.querySelectorAll('[axScrollSelect]').forEach(element => {
        new axScrollSelect(element);
    });
})();
/*!
* 插件：下拉选择（单选和多选）；改造自Choices v10.1.0 https://github.com/Choices-js/Choices；使用方法：new axSelect('#id',{参数})
*/
(function (factory) {
  let global = window || global || self;
    typeof define === 'function' && define.amd ? define(factory) :
    global.axSelect = factory();
    document.querySelectorAll('[axSelect]').forEach(element => {
        new axSelect(element);
    });
})((function () { 'use strict';
    const EVENTS = {
        showDropdown: 'showDropdown',
        hideDropdown: 'hideDropdown',
        change: 'change',
        choice: 'choice',
        search: 'search',
        addItem: 'addItem',
        removeItem: 'removeItem',
        highlightItem: 'highlightItem',
        highlightChoice: 'highlightChoice',
        unhighlightItem: 'unhighlightItem',
    };
    const ACTION_TYPES = {
        ADD_CHOICE: 'ADD_CHOICE',
        FILTER_CHOICES: 'FILTER_CHOICES',
        ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',
        CLEAR_CHOICES: 'CLEAR_CHOICES',
        ADD_GROUP: 'ADD_GROUP',
        ADD_ITEM: 'ADD_ITEM',
        REMOVE_ITEM: 'REMOVE_ITEM',
        HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',
        CLEAR_ALL: 'CLEAR_ALL',
        RESET_TO: 'RESET_TO',
        SET_IS_LOADING: 'SET_IS_LOADING',
    };
    const KEY_CODES = {
        BACK_KEY: 46,
        DELETE_KEY: 8,
        ENTER_KEY: 13,
        A_KEY: 65,
        ESC_KEY: 27,
        UP_KEY: 38,
        DOWN_KEY: 40,
        PAGE_UP_KEY: 33,
        PAGE_DOWN_KEY: 34,
    };
    const TEXT_TYPE = 'text';
    const SELECT_ONE_TYPE = 'select-one';
    const SELECT_MULTIPLE_TYPE = 'select-multiple';
    const SCROLLING_SPEED = 4;
    const addChoice = ({ value, label, id, groupId, disabled, elementId, customProperties, placeholder, keyCode, }) => ({
        type: ACTION_TYPES.ADD_CHOICE,
        value,
        label,
        id,
        groupId,
        disabled,
        elementId,
        customProperties,
        placeholder,
        keyCode,
    });
    const filterChoices = (results) => ({
        type: ACTION_TYPES.FILTER_CHOICES,
        results,
    });
    const activateChoices = (active = true) => ({
        type: ACTION_TYPES.ACTIVATE_CHOICES,
        active,
    });
    const clearChoices = () => ({
        type: ACTION_TYPES.CLEAR_CHOICES,
    });
    const addGroup = ({ value, id, active, disabled, }) => ({
        type: ACTION_TYPES.ADD_GROUP,
        value,
        id,
        active,
        disabled,
    });
    const addItem = ({ value, label, id, choiceId, groupId, customProperties, placeholder, keyCode, }) => ({
        type: ACTION_TYPES.ADD_ITEM,
        value,
        label,
        id,
        choiceId,
        groupId,
        customProperties,
        placeholder,
        keyCode,
    });
    const removeItem = (id, choiceId) => ({
        type: ACTION_TYPES.REMOVE_ITEM,
        id,
        choiceId,
    });
    const highlightItem = (id, highlighted) => ({
        type: ACTION_TYPES.HIGHLIGHT_ITEM,
        id,
        highlighted,
    });
    const clearAll = () => ({
        type: ACTION_TYPES.CLEAR_ALL,
    });
    const resetTo = (state) => ({
        type: ACTION_TYPES.RESET_TO,
        state,
    });
    const setIsLoading = (isLoading) => ({
        type: ACTION_TYPES.SET_IS_LOADING,
        isLoading,
    });
    class Dropdown {
        constructor({ element, type, classNames, }) {
            this.element = element;
            this.classNames = classNames;
            this.type = type;
            this.isActive = false;
        }
        /**
         * Bottom position of dropdown in viewport coordinates
         */
        get distanceFromTopWindow() {
            return this.element.getBoundingClientRect().bottom;
        }
        getChild(selector) {
            return this.element.querySelector(selector);
        }
        /**
         * Show dropdown to user by adding active state class
         */
        show() {
            this.element.classList.add(this.classNames.activeState);
            this.element.setAttribute('aria-expanded', 'true');
            this.isActive = true;
            return this;
        }
        /**
         * Hide dropdown from user
         */
        hide() {
            this.element.classList.remove(this.classNames.activeState);
            this.element.setAttribute('aria-expanded', 'false');
            this.isActive = false;
            return this;
        }
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    const getRandomNumber = (min, max) => Math.floor(Math.random() * (max - min) + min);
    const generateChars = (length) => Array.from({ length }, () => getRandomNumber(0, 36).toString(36)).join('');
    const generateId = (element, prefix) => {
        let id = element.id ||
            (element.name && `${element.name}-${generateChars(2)}`) ||
            generateChars(4);
        id = id.replace(/(:|\.|\[|\]|,)/g, '');
        id = `${prefix}-${id}`;
        return id;
    };
    /*
    const getType = (obj) => Object.prototype.toString.call(obj).slice(8, -1);
    const isType = (type, obj) => obj !== undefined && obj !== null && getType(obj) === type;
    const wrap = (element, wrapper = document.createElement('div')) => {
        if (element.parentNode) {
            if (element.nextSibling) {
                element.parentNode.insertBefore(wrapper, element.nextSibling);
            }
            else {
                element.parentNode.appendChild(wrapper);
            }
        }
        return wrapper.appendChild(element);
    }; */
    const getAdjacentEl = (startEl, selector, direction = 1) => {
        const prop = `${direction > 0 ? 'next' : 'previous'}ElementSibling`;
        let sibling = startEl[prop];
        while (sibling) {
            if (sibling.matches(selector)) {
                return sibling;
            }
            sibling = sibling[prop];
        }
        return sibling;
    };
    const isScrolledIntoView = (element, parent, direction = 1) => {
        if (!element) {
            return false;
        }
        let isVisible;
        if (direction > 0) {
            isVisible =
                parent.scrollTop + parent.offsetHeight >=
                    element.offsetTop + element.offsetHeight;
        }
        else {
            isVisible = element.offsetTop >= parent.scrollTop;
        }
        return isVisible;
    };
/*     const sanitise = (value) => {
        if (typeof value !== 'string') {
            return value;
        }
        return value
            .replace(/&/g, '&amp;')
            .replace(/>/g, '&gt;')
            .replace(/</g, '&lt;')
            .replace(/"/g, '&quot;');
    }; */
    const strToEl = (() => {
        const tmpEl = document.createElement('div');
        return (str) => {
            const cleanedInput = str.trim();
            tmpEl.innerHTML = cleanedInput;
            const firldChild = tmpEl.children[0];
            while (tmpEl.firstChild) {
                tmpEl.removeChild(tmpEl.firstChild);
            }
            return firldChild;
        };
    })();
    const sortByAlpha = ({ value, label = value }, { value: value2, label: label2 = value2 }) => label.localeCompare(label2, [], {
        sensitivity: 'base',
        ignorePunctuation: true,
        numeric: true,
    });
    const sortByScore = (a, b) => {
        const { score: scoreA = 0 } = a;
        const { score: scoreB = 0 } = b;
        return scoreA - scoreB;
    };
    const dispatchEvent = (element, type, customArgs = null) => {
        const event = new CustomEvent(type, {
            detail: customArgs,
            bubbles: true,
            cancelable: true,
        });
        return element.dispatchEvent(event);
    };
    const existsInArray = (array, value, key = 'value') => array.some((item) => {
        if (typeof value === 'string') {
            return item[key] === value.trim();
        }
        return item[key] === value;
    });
    const cloneObject = (obj) => JSON.parse(JSON.stringify(obj));
    /**
     * Returns an array of keys present on the first but missing on the second object
     */
    const diff = (a, b) => {
        const aKeys = Object.keys(a).sort();
        const bKeys = Object.keys(b).sort();
        return aKeys.filter((i) => bKeys.indexOf(i) < 0);
    };
    class Container {
        constructor({ element, type, classNames, position, }) {
            this.element = element;
            this.classNames = classNames;
            this.type = type;
            this.position = position;
            this.isOpen = false;
            this.isFlipped = false;
            this.isFocussed = false;
            this.isDisabled = false;
            this.isLoading = false;
            this._onFocus = this._onFocus.bind(this);
            this._onBlur = this._onBlur.bind(this);
        }
        addEventListeners() {
            this.element.addEventListener('focus', this._onFocus);
            this.element.addEventListener('blur', this._onBlur);
        }
        removeEventListeners() {
            this.element.removeEventListener('focus', this._onFocus);
            this.element.removeEventListener('blur', this._onBlur);
        }
        /**
         * Determine whether container should be flipped based on passed
         * dropdown position
         */
        shouldFlip(dropdownPos) {
            if (typeof dropdownPos !== 'number') {
                return false;
            }
            let shouldFlip = false;
            if (this.position === 'auto') {
                shouldFlip = !window.matchMedia(`(min-height: ${dropdownPos + 1}px)`)
                    .matches;
            }
            else if (this.position === 'top') {
                shouldFlip = true;
            }
            return shouldFlip;
        }
        setActiveDescendant(activeDescendantID) {
            this.element.setAttribute('aria-activedescendant', activeDescendantID);
        }
        removeActiveDescendant() {
            this.element.removeAttribute('aria-activedescendant');
        }
        open(dropdownPos) {
            this.element.classList.add(this.classNames.openState);
            this.element.setAttribute('aria-expanded', 'true');
            this.isOpen = true;
            if (this.shouldFlip(dropdownPos)) {
                this.element.classList.add(this.classNames.flippedState);
                this.isFlipped = true;
            }
        }
        close() {
            this.element.classList.remove(this.classNames.openState);
            this.element.setAttribute('aria-expanded', 'false');
            this.removeActiveDescendant();
            this.isOpen = false;
            if (this.isFlipped) {
                this.element.classList.remove(this.classNames.flippedState);
                this.isFlipped = false;
            }
        }
        focus() {
            if (!this.isFocussed) {
                this.element.focus();
            }
        }
        addFocusState() {
            this.element.classList.add(this.classNames.focusState);
        }
        removeFocusState() {
            this.element.classList.remove(this.classNames.focusState);
        }
        enable() {
            this.element.classList.remove(this.classNames.disabledState);
            this.element.removeAttribute('aria-disabled');
            if (this.type === SELECT_ONE_TYPE) {
                this.element.setAttribute('tabindex', '0');
            }
            this.isDisabled = false;
        }
        disable() {
            this.element.classList.add(this.classNames.disabledState);
            this.element.setAttribute('aria-disabled', 'true');
            if (this.type === SELECT_ONE_TYPE) {
                this.element.setAttribute('tabindex', '-1');
            }
            this.isDisabled = true;
        }
        wrap(element) {
            axAddWrap(element, this.element) 
        }
        unwrap(element) {
            if (this.element.parentNode) {
                this.element.parentNode.insertBefore(element, this.element);
                this.element.parentNode.removeChild(this.element);
            }
        }
        addLoadingState() {
            this.element.classList.add(this.classNames.loadingState);
            this.element.setAttribute('aria-busy', 'true');
            this.isLoading = true;
        }
        removeLoadingState() {
            this.element.classList.remove(this.classNames.loadingState);
            this.element.removeAttribute('aria-busy');
            this.isLoading = false;
        }
        _onFocus() {
            this.isFocussed = true;
        }
        _onBlur() {
            this.isFocussed = false;
        }
    }
    class Input {
        constructor({ element, type, classNames, preventPaste, }) {
            this.element = element;
            this.type = type;
            this.classNames = classNames;
            this.preventPaste = preventPaste;
            this.isFocussed = this.element.isEqualNode(document.activeElement);
            this.isDisabled = element.disabled;
            this._onPaste = this._onPaste.bind(this);
            this._onInput = this._onInput.bind(this);
            this._onFocus = this._onFocus.bind(this);
            this._onBlur = this._onBlur.bind(this);
        }
        set placeholder(placeholder) {
            this.element.placeholder = placeholder;
        }
        get value() {
            return axCleanString(this.element.value);
        }
        set value(value) {
            this.element.value = value;
        }
        get rawValue() {
            return this.element.value;
        }
        addEventListeners() {
            this.element.addEventListener('paste', this._onPaste);
            this.element.addEventListener('input', this._onInput, {
                passive: true,
            });
            this.element.addEventListener('focus', this._onFocus, {
                passive: true,
            });
            this.element.addEventListener('blur', this._onBlur, {
                passive: true,
            });
        }
        removeEventListeners() {
            this.element.removeEventListener('input', this._onInput);
            this.element.removeEventListener('paste', this._onPaste);
            this.element.removeEventListener('focus', this._onFocus);
            this.element.removeEventListener('blur', this._onBlur);
        }
        enable() {
            this.element.removeAttribute('disabled');
            this.isDisabled = false;
        }
        disable() {
            this.element.setAttribute('disabled', '');
            this.isDisabled = true;
        }
        focus() {
            if (!this.isFocussed) {
                this.element.focus();
            }
        }
        blur() {
            if (this.isFocussed) {
                this.element.blur();
            }
        }
        clear(setWidth = true) {
            if (this.element.value) {
                this.element.value = '';
            }
            if (setWidth) {
                this.setWidth();
            }
            return this;
        }
        /**
         * Set the correct input width based on placeholder
         * value or input value
         */
        setWidth() {
            const { style, value, placeholder } = this.element;
            style.minWidth = placeholder.length + 1 + "em"; 
            style.width = value.length + 1 + "em"; 
        }
        setActiveDescendant(activeDescendantID) {
            this.element.setAttribute('aria-activedescendant', activeDescendantID);
        }
        removeActiveDescendant() {
            this.element.removeAttribute('aria-activedescendant');
        }
        _onInput() {
            if (this.type !== SELECT_ONE_TYPE) {
                this.setWidth();
            }
        }
        _onPaste(event) {
            if (this.preventPaste) {
                axPreventDefault(event);
            }
        }
        _onFocus() {
            this.isFocussed = true;
        }
        _onBlur() {
            this.isFocussed = false;
        }
    }
    class List {
        constructor({ element }) {
            this.element = element;
            this.scrollPos = this.element.scrollTop;
            this.height = this.element.offsetHeight;
        }
        clear() {
            this.element.innerHTML = '';
        }
        append(node) {
            this.element.appendChild(node);
        }
        getChild(selector) {
            return this.element.querySelector(selector);
        }
        hasChildren() {
            return this.element.hasChildNodes();
        }
        scrollToTop() {
            this.element.scrollTop = 0;
        }
        scrollToChildElement(element, direction) {
            if (!element) {
                return;
            }
            const listHeight = this.element.offsetHeight;
            const listScrollPosition = this.element.scrollTop + listHeight;
            const elementHeight = element.offsetHeight;
            const elementPos = element.offsetTop + elementHeight;
            const destination = direction > 0
                ? this.element.scrollTop + elementPos - listScrollPosition
                : element.offsetTop;
            requestAnimationFrame(() => {
                this._animateScroll(destination, direction);
            });
        }
        _scrollDown(scrollPos, strength, destination) {
            const easing = (destination - scrollPos) / strength;
            const distance = easing > 1 ? easing : 1;
            this.element.scrollTop = scrollPos + distance;
        }
        _scrollUp(scrollPos, strength, destination) {
            const easing = (scrollPos - destination) / strength;
            const distance = easing > 1 ? easing : 1;
            this.element.scrollTop = scrollPos - distance;
        }
        _animateScroll(destination, direction) {
            const strength = SCROLLING_SPEED;
            const choiceListScrollTop = this.element.scrollTop;
            let continueAnimation = false;
            if (direction > 0) {
                this._scrollDown(choiceListScrollTop, strength, destination);
                if (choiceListScrollTop < destination) {
                    continueAnimation = true;
                }
            }
            else {
                this._scrollUp(choiceListScrollTop, strength, destination);
                if (choiceListScrollTop > destination) {
                    continueAnimation = true;
                }
            }
            if (continueAnimation) {
                requestAnimationFrame(() => {
                    this._animateScroll(destination, direction);
                });
            }
        }
    }
    class WrappedElement {
        constructor({ element, classNames }) {
            this.element = element;
            this.classNames = classNames;
            if (!(element instanceof HTMLInputElement) &&
                !(element instanceof HTMLSelectElement)) {
                throw new TypeError('Invalid element passed');
            }
            this.isDisabled = false;
        }
        get isActive() {
            return this.element.dataset.choice === 'active';
        }
        get dir() {
            return this.element.dir;
        }
        get value() {
            return this.element.value;
        }
        set value(value) {
            this.element.value = value;
        }
        conceal() {
            this.element.classList.add(this.classNames.input);
            this.element.hidden = true;
            this.element.tabIndex = -1;
            const origStyle = this.element.getAttribute('style');
            if (origStyle) {
                this.element.setAttribute('data-choice-orig-style', origStyle);
            }
            this.element.setAttribute('data-choice', 'active');
        }
        reveal() {
            this.element.classList.remove(this.classNames.input);
            this.element.hidden = false;
            this.element.removeAttribute('tabindex');
            const origStyle = this.element.getAttribute('data-choice-orig-style');
            if (origStyle) {
                this.element.removeAttribute('data-choice-orig-style');
                this.element.setAttribute('style', origStyle);
            }
            else {
                this.element.removeAttribute('style');
            }
            this.element.removeAttribute('data-choice');
            this.element.value = this.element.value; 
        }
        enable() {
            this.element.removeAttribute('disabled');
            this.element.disabled = false;
            this.isDisabled = false;
        }
        disable() {
            this.element.setAttribute('disabled', '');
            this.element.disabled = true;
            this.isDisabled = true;
        }
        triggerEvent(eventType, data) {
            dispatchEvent(this.element, eventType, data);
        }
    }
    class WrappedInput extends WrappedElement {
        constructor({ element, classNames, delimiter, }) {
            super({ element, classNames });
            this.delimiter = delimiter;
        }
        get value() {
            return this.element.value;
        }
        set value(value) {
            this.element.setAttribute('value', value);
            this.element.value = value;
        }
    }
    class WrappedSelect extends WrappedElement {
        constructor({ element, classNames, template, }) {
            super({ element, classNames });
            this.template = template;
        }
        get placeholderOption() {
            return (this.element.querySelector('option[value=""]') ||
                this.element.querySelector('option[placeholder]'));
        }
        get optionGroups() {
            return Array.from(this.element.getElementsByTagName('OPTGROUP'));
        }
        get options() {
            return Array.from(this.element.options);
        }
        set options(options) {
            const fragment = document.createDocumentFragment();
            const addOptionToFragment = (data) => {
                const option = this.template(data);
                fragment.appendChild(option);
            };
            options.forEach((optionData) => addOptionToFragment(optionData));
            this.appendDocFragment(fragment);
        }
        appendDocFragment(fragment) {
            this.element.innerHTML = '';
            this.element.appendChild(fragment);
        }
    }
    const DEFAULT_CLASSNAMES = {
                    containerOuter: 'ax-select',
                    containerInner: 'ax-select-inner',
                    input: 'ax-select-input',
                    inputCloned: 'ax-input-cloned',
                    list: 'ax-select-list',
                    listItems: 'ax-label-multiple',
                    listSingle: 'ax-label-single',
                    listDropdown: 'ax-select-dropdown',
                    dropdownList: 'ax-item-list',
                    item: 'ax-item',
                    itemSelectable: 'ax-item-selectable',
                    itemDisabled: 'ax-item-disabled',
                    itemChoice: 'ax-item-done',
                    placeholder: 'ax-select-placeholder',
                    group: 'ax-item-group',
                    groupHeading: 'ax-group-name',
                    button: 'ax-close',
                    activeState: 'ax-active',
                    focusState: 'ax-focuse',
                    openState: 'ax-open',
                    disabledState: 'ax-disabled',
                    highlightedState: 'ax-highlight',
                    selectedState: 'ax-selected',
                    flippedState: 'ax-flipped',
                    loadingState: 'ax-buffer',
                    noResults: 'ax-no-results',
                    noChoices: 'ax-no-select'
                };
    const DEFAULT_CONFIG = {
        disabled:false,
        size:'',
        width:'',
        items: [],
        choices: [],
        silent: false,
        renderChoiceLimit: -1,
        className:'',
        maxItemCount: -1,
        addItems: true,
        addItemFilter: null,
        removeItems: true,
        removeItemButton: false,
        editItems: false,
        allowHTML: true,
        duplicateItemsAllowed: true,
        delimiter: ',',
        paste: true,
        searchEnabled: false,
        searchChoices: true,
        searchFloor: 1,
        searchResultLimit: 4,
        searchFields: ['label', 'value'],
        position: 'auto',
        resetScrollPosition: true,
        shouldSort: true,
        shouldSortItems: false,
        sorter: sortByAlpha,
        placeholder: true,
        placeholderValue: '请输入关键字...',
        searchPlaceholderValue: '请输入关键字...',
        prependValue: null,
        appendValue: null,
        renderSelectedChoices: 'auto',
        loadingText: '加载中...',
        noResultsText: '没有检索结果',
        noChoicesText: '没有符合条件的选项',
        itemSelectText: '点击选择',
        uniqueItemText: '只能添加唯一值',
        customAddItemText: '只可添加条件匹配的选项',
        addItemText: (value) => `按回车键添加 <b>"${axCleanString(value)}"</b> 选项`,
        maxItemText: (maxItemCount) => `只能添加 ${maxItemCount} 项`,
        valueComparer: (value1, value2) => value1 === value2,
        fuseOptions: {
            includeScore: true,
        },
        labelId: '',
        callbackOnInit: null,
        callbackOnCreateTemplates: null,
        classNames: DEFAULT_CLASSNAMES,
    };
    const defaultState$4 = [];
    function items(state = defaultState$4, action = {}) {
        switch (action.type) {
            case 'ADD_ITEM': {
                const addItemAction = action;
                const newState = [
                    ...state,
                    {
                        id: addItemAction.id,
                        choiceId: addItemAction.choiceId,
                        groupId: addItemAction.groupId,
                        value: addItemAction.value,
                        label: addItemAction.label,
                        active: true,
                        highlighted: false,
                        customProperties: addItemAction.customProperties,
                        placeholder: addItemAction.placeholder || false,
                        keyCode: null,
                    },
                ];
                return newState.map((obj) => {
                    const item = obj;
                    item.highlighted = false;
                    return item;
                });
            }
            case 'REMOVE_ITEM': {
                return state.map((obj) => {
                    const item = obj;
                    if (item.id === action.id) {
                        item.active = false;
                    }
                    return item;
                });
            }
            case 'HIGHLIGHT_ITEM': {
                const highlightItemAction = action;
                return state.map((obj) => {
                    const item = obj;
                    if (item.id === highlightItemAction.id) {
                        item.highlighted = highlightItemAction.highlighted;
                    }
                    return item;
                });
            }
            default: {
                return state;
            }
        }
    }
    const defaultState$3 = [];
    function groups(state = defaultState$3, action = {}) {
        switch (action.type) {
            case 'ADD_GROUP': {
                const addGroupAction = action;
                return [
                    ...state,
                    {
                        id: addGroupAction.id,
                        value: addGroupAction.value,
                        active: addGroupAction.active,
                        disabled: addGroupAction.disabled,
                    },
                ];
            }
            case 'CLEAR_CHOICES': {
                return [];
            }
            default: {
                return state;
            }
        }
    }
    const defaultState$2 = [];
    function choices(state = defaultState$2, action = {}) {
        switch (action.type) {
            case 'ADD_CHOICE': {
                const addChoiceAction = action;
                const choice = {
                    id: addChoiceAction.id,
                    elementId: addChoiceAction.elementId,
                    groupId: addChoiceAction.groupId,
                    value: addChoiceAction.value,
                    label: addChoiceAction.label || addChoiceAction.value,
                    disabled: addChoiceAction.disabled || false,
                    selected: false,
                    active: true,
                    score: 9999,
                    customProperties: addChoiceAction.customProperties,
                    placeholder: addChoiceAction.placeholder || false,
                };
                /*
                  A disabled choice appears in the choice dropdown but cannot be selected
                  A selected choice has been added to the passed input's value (added as an item)
                  An active choice appears within the choice dropdown
                */
                return [...state, choice];
            }
            case 'ADD_ITEM': {
                const addItemAction = action;
                if (addItemAction.choiceId > -1) {
                    return state.map((obj) => {
                        const choice = obj;
                        if (choice.id === parseInt(`${addItemAction.choiceId}`, 10)) {
                            choice.selected = true;
                        }
                        return choice;
                    });
                }
                return state;
            }
            case 'REMOVE_ITEM': {
                const removeItemAction = action;
                if (removeItemAction.choiceId && removeItemAction.choiceId > -1) {
                    return state.map((obj) => {
                        const choice = obj;
                        if (choice.id === parseInt(`${removeItemAction.choiceId}`, 10)) {
                            choice.selected = false;
                        }
                        return choice;
                    });
                }
                return state;
            }
            case 'FILTER_CHOICES': {
                const filterChoicesAction = action;
                return state.map((obj) => {
                    const choice = obj;
                    choice.active = filterChoicesAction.results.some(({ item, score }) => {
                        if (item.id === choice.id) {
                            choice.score = score;
                            return true;
                        }
                        return false;
                    });
                    return choice;
                });
            }
            case 'ACTIVATE_CHOICES': {
                const activateChoicesAction = action;
                return state.map((obj) => {
                    const choice = obj;
                    choice.active = activateChoicesAction.active;
                    return choice;
                });
            }
            case 'CLEAR_CHOICES': {
                return defaultState$2;
            }
            default: {
                return state;
            }
        }
    }
    const defaultState$1 = false;
    const general = (state = defaultState$1, action = {}) => {
        switch (action.type) {
            case 'SET_IS_LOADING': {
                return action.isLoading;
            }
            default: {
                return state;
            }
        }
    };
    const defaultState = {
        groups: [],
        items: [],
        choices: [],
        loading: false,
    };
    const appReducer = Redux.combineReducers({
        items,
        groups,
        choices,
        loading: general,
    });
    const rootReducer = (passedState, action) => {
        let state = passedState;
        if (action.type === 'CLEAR_ALL') {
            state = defaultState;
        }
        else if (action.type === 'RESET_TO') {
            return cloneObject(action.state);
        }
        return appReducer(state, action);
    };
    /* eslint-disable @typescript-eslint/no-explicit-any */
    class Store {
        constructor() {
            this._store = Redux.createStore(rootReducer, window.__REDUX_DEVTOOLS_EXTENSION__ &&
                window.__REDUX_DEVTOOLS_EXTENSION__());
        }
        /**
         * Subscribe store to function call (wrapped Redux method)
         */
        subscribe(onChange) {
            this._store.subscribe(onChange);
        }
        /**
         * Dispatch event to store (wrapped Redux method)
         */
        dispatch(action) {
            this._store.dispatch(action);
        }
        /**
         * Get store object (wrapping Redux method)
         */
        get state() {
            return this._store.getState();
        }
        /**
         * Get items from store
         */
        get items() {
            return this.state.items;
        }
        /**
         * Get active items from store
         */
        get activeItems() {
            return this.items.filter((item) => item.active === true);
        }
        /**
         * Get highlighted items from store
         */
        get highlightedActiveItems() {
            return this.items.filter((item) => item.active && item.highlighted);
        }
        /**
         * Get choices from store
         */
        get choices() {
            return this.state.choices;
        }
        /**
         * Get active choices from store
         */
        get activeChoices() {
            return this.choices.filter((choice) => choice.active === true);
        }
        /**
         * Get selectable choices from store
         */
        get selectableChoices() {
            return this.choices.filter((choice) => choice.disabled !== true);
        }
        /**
         * Get choices that can be searched (excluding placeholders)
         */
        get searchableChoices() {
            return this.selectableChoices.filter((choice) => choice.placeholder !== true);
        }
        /**
         * Get placeholder choice from store
         */
        get placeholderChoice() {
            return [...this.choices]
                .reverse()
                .find((choice) => choice.placeholder === true);
        }
        /**
         * Get groups from store
         */
        get groups() {
            return this.state.groups;
        }
        /**
         * Get active groups from store
         */
        get activeGroups() {
            const { groups, choices } = this;
            return groups.filter((group) => {
                const isActive = group.active === true && group.disabled === false;
                const hasActiveOptions = choices.some((choice) => choice.active === true && choice.disabled === false);
                return isActive && hasActiveOptions;
            }, []);
        }
        /**
         * Get loading state from store
         */
        isLoading() {
            return this.state.loading;
        }
        /**
         * Get single choice by it's ID
         */
        getChoiceById(id) {
            return this.activeChoices.find((choice) => choice.id === parseInt(id, 10));
        }
        /**
         * Get group by group id
         */
        getGroupById(id) {
            return this.groups.find((group) => group.id === id);
        }
    }
    /**
     * Helpers to create HTML elements used by Choices
     * Can be overridden by providing `callbackOnCreateTemplates` option
     */
    const templates = {
        containerOuter({ classNames: { containerOuter } }, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
            const div = Object.assign(document.createElement('div'), {
                className: containerOuter,
            });
            div.dataset.type = passedElementType;
            if (dir) {
                div.dir = dir;
            }
            if (isSelectOneElement) {
                div.tabIndex = 0;
            }
            if (isSelectElement) {
                div.setAttribute('role', searchEnabled ? 'combobox' : 'listbox');
                if (searchEnabled) {
                    div.setAttribute('aria-autocomplete', 'list');
                }
            }
            div.setAttribute('aria-haspopup', 'true');
            div.setAttribute('aria-expanded', 'false');
            this.config.className?div.classList.add(this.config.className):null;
            this.config.size?div.setAttribute('data-size',this.config.size):null;
            if (labelId) {
                div.setAttribute('aria-labeledby', labelId);
            }
            return div;
        },
        containerInner({ classNames: { containerInner }, }) {
            return Object.assign(document.createElement('div'), {
                className: containerInner,
            });
        },
        itemList({ classNames: { list, listSingle, listItems } }, isSelectOneElement) {
            return Object.assign(document.createElement('span'), { 
                className: `${isSelectOneElement ? listSingle : listItems}`,
            });
        },
        placeholder({ allowHTML, classNames: { placeholder } }, value) {
            return Object.assign(document.createElement('div'), {
                className: placeholder,
                [allowHTML ? 'innerHTML' : 'innerText']: value,
            });
        },
        item({ allowHTML, classNames: { item, button, highlightedState, itemSelectable, placeholder, }, }, { id, value, label, customProperties, active, disabled, highlighted, placeholder: isPlaceholder, }, removeItemButton) {
            const div = Object.assign(document.createElement('span'), {
                className: item,
                [allowHTML ? 'innerHTML' : 'innerText']: label,
            });
            Object.assign(div.dataset, {
                item: '',
                id,
                value,
                customProperties,
            });
            if (active) {
                div.setAttribute('aria-selected', 'true');
            }
            if (disabled) {
                div.setAttribute('aria-disabled', 'true');
            }
            if (isPlaceholder) {
                div.classList.add(placeholder);
            }
            div.classList.add(highlighted ? highlightedState : itemSelectable);
            if (removeItemButton) {
                if (disabled) {
                    div.classList.remove(itemSelectable);
                }
                div.dataset.deletable = '';
                /** @todo This MUST be localizable, not hardcoded! */
                const REMOVE_ITEM_TEXT = '';
                const removeButton = Object.assign(document.createElement('i'), {
                    type: 'button',
                    className: button,
                    [allowHTML ? 'innerHTML' : 'innerText']: REMOVE_ITEM_TEXT,
                });
                removeButton.setAttribute('aria-label', `${REMOVE_ITEM_TEXT}: '${value}'`);
                removeButton.dataset.button = '';
                div.appendChild(removeButton);
            }
            return div;
        },
        choiceList({ classNames: { dropdownList } }, isSelectOneElement) {
            const div = Object.assign(document.createElement('div'), {
                className: dropdownList,
            });
            if (!isSelectOneElement) {
                div.setAttribute('aria-multiselectable', 'true');
            }
            div.setAttribute('role', 'listbox');
            return div;
        },
        choiceGroup({ allowHTML, classNames: { group, groupHeading, itemDisabled }, }, { id, value, disabled }) {
            const div = Object.assign(document.createElement('div'), {
                className: `${group} ${disabled ? itemDisabled : ''}`,
            });
            div.setAttribute('role', 'group');
            Object.assign(div.dataset, {
                group: '',
                id,
                value,
            });
            if (disabled) {
                div.setAttribute('aria-disabled', 'true');
            }
            div.appendChild(Object.assign(document.createElement('div'), {
                className: groupHeading,
                [allowHTML ? 'innerHTML' : 'innerText']: value,
            }));
            return div;
        },
        choice({ allowHTML, classNames: { item, itemChoice, itemSelectable, selectedState, itemDisabled, placeholder, }, }, { id, value, label, groupId, elementId, disabled: isDisabled, selected: isSelected, placeholder: isPlaceholder, }, selectText) {
            const div = Object.assign(document.createElement('div'), {
                id: elementId,
                [allowHTML ? 'innerHTML' : 'innerText']: label,
                className: `${item} ${itemChoice}`,
            });
            if (isSelected) {
                div.classList.add(selectedState);
            }
            if (isPlaceholder) {
                div.classList.add(placeholder);
            }
            div.setAttribute('role', groupId && groupId > 0 ? 'treeitem' : 'option');
            Object.assign(div.dataset, {
                choice: '',
                id,
                value,
                selectText,
            });
            if (isDisabled) {
                div.classList.add(itemDisabled);
                div.dataset.choiceDisabled = '';
                div.setAttribute('aria-disabled', 'true');
            }
            else {
                div.classList.add(itemSelectable);
                div.dataset.choiceSelectable = '';
            }
            return div;
        },
        input({ classNames: { input, inputCloned } }, placeholderValue) {
            const inp = Object.assign(document.createElement('input'), {
                type: 'search',
                name: 'search_terms',
                className: `${input} ${inputCloned}`,
                autocomplete: 'off',
                autocapitalize: 'off',
                spellcheck: false,
            });
            inp.setAttribute('role', 'textbox');
            inp.setAttribute('aria-autocomplete', 'list');
            inp.setAttribute('aria-label', placeholderValue);
            return inp;
        },
        dropdown({ classNames: { list, listDropdown }, }) {
            const div = document.createElement('div');
            div.classList.add(listDropdown);
            div.setAttribute('aria-expanded', 'false');
            return div;
        },
        notice({ allowHTML, classNames: { item, itemChoice, noResults, noChoices }, }, innerText, type = '') {
            const classes = [item, itemChoice];
            if (type === 'no-choices') {
                classes.push(noChoices);
            }
            else if (type === 'no-results') {
                classes.push(noResults);
            }
            return Object.assign(document.createElement('div'), {
                [allowHTML ? 'innerHTML' : 'innerText']: innerText,
                className: classes.join(' '),
            });
        },
        option({ label, value, customProperties, active, disabled, }) {
            const opt = new Option(label, value, false, active);
            if (customProperties) {
                opt.dataset.customProperties = `${customProperties}`;
            }
            opt.disabled = !!disabled;
            return opt;
        },
    };
    /** @see {@link http://browserhacks.com/#hack-acea075d0ac6954f275a70023906050c} */
    const IS_IE11 = '-ms-scroll-limit' in document.documentElement.style &&
        '-ms-ime-align' in document.documentElement.style;
    const USER_DEFAULTS = {};
    /**
     * Choices
     * @author Josh Johnson<josh@joshuajohnson.co.uk>
     */
    class Choices {
        constructor(element = '[data-choice]', userConfig = {}) {
            if (userConfig.allowHTML === undefined) {
            }
            this.config = axClone(axMerge(axMerge(DEFAULT_CONFIG, Choices.defaults.options,{attrAppend:true,clone:true}),userConfig,{attrAppend:true,clone:true}));
            this.origElem = element;
            this.config = axDataset(element, this.config);
            const invalidConfigOptions = diff(this.config, DEFAULT_CONFIG);
            if (invalidConfigOptions.length) {
                console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));
            }
            const passedElement = typeof element === 'string' ? document.querySelector(element) : element;
            if (!(passedElement instanceof HTMLInputElement ||
                passedElement instanceof HTMLSelectElement)) {
                throw TypeError('Expected one of the following types text|select-one|select-multiple');
            }
            this._isTextElement = passedElement.type === TEXT_TYPE;
            this._isSelectOneElement = passedElement.type === SELECT_ONE_TYPE;
            this._isSelectMultipleElement = passedElement.type === SELECT_MULTIPLE_TYPE;
            this._isSelectElement =
                this._isSelectOneElement || this._isSelectMultipleElement;
            this.config.searchEnabled =
                this._isSelectMultipleElement || this.config.searchEnabled;
            if (!['auto', 'always'].includes(`${this.config.renderSelectedChoices}`)) {
                this.config.renderSelectedChoices = 'auto';
            }
            if (userConfig.addItemFilter &&
                typeof userConfig.addItemFilter !== 'function') {
                const re = userConfig.addItemFilter instanceof RegExp
                    ? userConfig.addItemFilter
                    : new RegExp(userConfig.addItemFilter);
                this.config.addItemFilter = re.test.bind(re);
            }
            if (this._isTextElement) {
                this.passedElement = new WrappedInput({
                    element: passedElement,
                    classNames: this.config.classNames,
                    delimiter: this.config.delimiter,
                });
            }
            else {
                this.passedElement = new WrappedSelect({
                    element: passedElement,
                    classNames: this.config.classNames,
                    template: (data) => this._templates.option(data),
                });
            }
            this.initialised = false;
            this._store = new Store();
            this._initialState = defaultState;
            this._currentState = defaultState;
            this._prevState = defaultState;
            this._currentValue = '';
            this._canSearch = !!this.config.searchEnabled;
            this._isScrollingOnIe = false;
            this._highlightPosition = 0;
            this._wasTap = true;
            this._placeholderValue = this._generatePlaceholderValue();
            this._baseId = axCreateId('choices-', '', this.passedElement.element); 
            /**
             * setting direction in cases where it's explicitly set on passedElement
             * or when calculated direction is different from the document
             */
            this._direction = this.passedElement.dir;
            if (!this._direction) {
                const { direction: elementDirection } = window.getComputedStyle(this.passedElement.element);
                const { direction: documentDirection } = window.getComputedStyle(document.documentElement);
                if (elementDirection !== documentDirection) {
                    this._direction = elementDirection;
                }
            }
            this._idNames = {
                itemChoice: 'item-choice',
            };
            if (this._isSelectElement) {
                this._presetGroups = this.passedElement.optionGroups;
                this._presetOptions = this.passedElement.options;
            }
            this._presetChoices = this.config.choices;
            this._presetItems = this.config.items;
            if (this.passedElement.value && this._isTextElement) {
                const splitValues = this.passedElement.value.split(this.config.delimiter);
                this._presetItems = this._presetItems.concat(splitValues);
            }
            if (this.passedElement.options) {
                this.passedElement.options.forEach((option) => {
                    this._presetChoices.push({
                        value: option.value,
                        label: option.innerHTML,
                        selected: !!option.selected,
                        disabled: option.disabled || option.parentNode.disabled,
                        placeholder: option.value === '' || option.hasAttribute('placeholder'),
                        customProperties: option.dataset['custom-properties'],
                    });
                });
            }
            this._render = this._render.bind(this);
            this._onFocus = this._onFocus.bind(this);
            this._onBlur = this._onBlur.bind(this);
            this._onKeyUp = this._onKeyUp.bind(this);
            this._onKeyDown = this._onKeyDown.bind(this);
            this._onClick = this._onClick.bind(this);
            this._onTouchMove = this._onTouchMove.bind(this);
            this._onTouchEnd = this._onTouchEnd.bind(this);
            this._onMouseDown = this._onMouseDown.bind(this);
            this._onMouseOver = this._onMouseOver.bind(this);
            this._onFormReset = this._onFormReset.bind(this);
            this._onSelectKey = this._onSelectKey.bind(this);
            this._onEnterKey = this._onEnterKey.bind(this);
            this._onEscapeKey = this._onEscapeKey.bind(this);
            this._onDirectionKey = this._onDirectionKey.bind(this);
            this._onDeleteKey = this._onDeleteKey.bind(this);
            if (this.passedElement.isActive) {
                if (!this.config.silent) {
                    console.warn('Trying to initialise Choices on element already initialised', { element });
                }
                this.initialised = true;
                return;
            }
            element && element.hasOwnProperty('axSelect') && !!element.getAttribute('axSelect') ? this.referName = element.getAttribute('axSelect') : this.referName = '';
            this.init();
            this.config.disabled?this.disable():null;
        }
        static get defaults() {
            return Object.preventExtensions({
                get options() {
                    return USER_DEFAULTS;
                },
                get templates() {
                    return templates;
                },
            });
        }
        init(callback) {
            if (this.initialised) {
                return;
            }
            this._createTemplates();
            this._createElements();
            this._createStructure();
            this._store.subscribe(this._render);
            this._render();
            this._addEventListeners();
            const shouldDisable = !this.config.addItems ||
                this.passedElement.element.hasAttribute('disabled');
            if (shouldDisable) {
                this.disable();
            }
            this.initialised = true;
            const { callbackOnInit } = this.config;
            if (callbackOnInit && typeof callbackOnInit === 'function') {
                callbackOnInit.call(this);
            }
            callback && callback.call(this);
            if (this.referName) {
                if (axIsEmpty(axSelects)) {
                    axSelects.push({ name: this.referName, instance: this });
                } else {
                    for (let i = 0; i < axSelects.length; i++) {
                        if (axSelects[i].name == this.referName) {
                            axSelects[i].instance = this;
                            break;
                        } else {
                            axSelects.push({ name: this.referName, instance: this });
                        }
                    }
                }
            }
        }
        destroy(callback) {
            if (!this.initialised) {
                return;
            }
            this._removeEventListeners();
            this.passedElement.reveal();
            this.containerOuter.unwrap(this.passedElement.element);
            this.clearStore();
            if (this._isSelectElement) {
                this.passedElement.options = this._presetOptions;
            }
            this._templates = templates;
            this.initialised = false;
            callback && callback.call(this);
        }
        enable(callback) {
            if (this.passedElement.isDisabled) {
                this.passedElement.enable();
            }
            if (this.containerOuter.isDisabled) {
                this._addEventListeners();
                this.input.enable();
                this.containerOuter.enable();
            }
            callback && callback.call(this);
            return this;
        }
        disable(callback) {
            if (!this.passedElement.isDisabled) {
                this.passedElement.disable();
            }
            if (!this.containerOuter.isDisabled) {
                this._removeEventListeners();
                this.input.disable();
                this.containerOuter.disable();
            }
            callback && callback.call(this);
            return this;
        }
        highlightItem(item, runEvent = true,callback) {
            if (!item || !item.id) {
                return this;
            }
            const { id, groupId = -1, value = '', label = '' } = item;
            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
            this._store.dispatch(highlightItem(id, true));
            if (runEvent) {
                this.passedElement.triggerEvent(EVENTS.highlightItem, {
                    id,
                    value,
                    label,
                    groupValue: group && group.value ? group.value : null,
                });
            }
            callback && callback.call(this);
            return this;
        }
        unhighlightItem(item,callback) {
            if (!item || !item.id) {
                return this;
            }
            const { id, groupId = -1, value = '', label = '' } = item;
            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
            this._store.dispatch(highlightItem(id, false));
            this.passedElement.triggerEvent(EVENTS.highlightItem, {
                id,
                value,
                label,
                groupValue: group && group.value ? group.value : null,
            });
            callback && callback.call(this);
            return this;
        }
        highlightAll(callback) {
            this._store.items.forEach((item) => this.highlightItem(item));
            callback && callback.call(this);
            return this;
        }
        unhighlightAll(callback) {
            this._store.items.forEach((item) => this.unhighlightItem(item));
            callback && callback.call(this);
            return this;
        }
        removeActiveItemsByValue(value,callback) {
            this._store.activeItems
                .filter((item) => item.value === value)
                .forEach((item) => this._removeItem(item));
                callback && callback.call(this);
            return this;
        }
        removeActiveItems(excludedId,callback) {
            this._store.activeItems
                .filter(({ id }) => id !== excludedId)
                .forEach((item) => this._removeItem(item));
                callback && callback.call(this);
            return this;
        }
        removeHighlightedItems(runEvent = false,callback) {
            this._store.highlightedActiveItems.forEach((item) => {
                this._removeItem(item);
                if (runEvent) {
                    this._triggerChange(item.value);
                }
            });
            callback && callback.call(this);
            return this;
        }
        showDropdown(preventInputFocus,callback) {
            if (this.dropdown.isActive) {
                return this;
            }
            requestAnimationFrame(() => {
                this.dropdown.show();
                this.containerOuter.open(this.dropdown.distanceFromTopWindow);
                if (!preventInputFocus && this._canSearch) {
                    this.input.focus();
                }
                this.passedElement.triggerEvent(EVENTS.showDropdown, {});
            });
            callback && callback.call(this);
            return this;
        }
        hideDropdown(preventInputBlur,callback) {
            if (!this.dropdown.isActive) {
                callback && callback.call(this);
                return this;
            }
            requestAnimationFrame(() => {
                this.dropdown.hide();
                this.containerOuter.close();
                if (!preventInputBlur && this._canSearch) {
                    this.input.removeActiveDescendant();
                    this.input.blur();
                }
                this.passedElement.triggerEvent(EVENTS.hideDropdown, {});
            });
            callback && callback.call(this);
            return this;
        }
        getValue(valueOnly = false,callback) {
            const values = this._store.activeItems.reduce((selectedItems, item) => {
                const itemValue = valueOnly ? item.value : item;
                selectedItems.push(itemValue);
                return selectedItems;
            }, []);
            callback && callback.call(this);
            return this._isSelectOneElement ? values[0] : values;
        }
        setValue(items,callback) {
            if (!this.initialised) {
                return this;
            }
            items.forEach((value) => this._setChoiceOrItem(value));
            callback && callback.call(this);
            return this;
        }
        setChoiceByValue(value,callback) {
            if (!this.initialised || this._isTextElement) {
                return this;
            }
            const choiceValue = Array.isArray(value) ? value : [value];
            choiceValue.forEach((val) => this._findAndSelectChoiceByValue(val));
            callback && callback.call(this);
            return this;
        }
        /**
         * Set choices of select input via an array of objects (or function that returns array of object or promise of it),
         * a value field name and a label field name.
         * This behaves the same as passing items via the choices option but can be called after initialising Choices.
         * This can also be used to add groups of choices (see example 2); Optionally pass a true `replaceChoices` value to remove any existing choices.
         * Optionally pass a `customProperties` object to add additional data to your choices (useful when searching/filtering etc).
         *
         * **Input types affected:** select-one, select-multiple
         *
         * @example
         * ```js
         * const example = new Choices(element);
         *
         * example.setChoices([
         *   {value: 'One', label: 'Label One', disabled: true},
         *   {value: 'Two', label: 'Label Two', selected: true},
         *   {value: 'Three', label: 'Label Three'},
         * ], 'value', 'label', false);
         * ```
         *
         * @example
         * ```js
         * const example = new Choices(element);
         *
         * example.setChoices(async () => {
         *   try {
         *      const items = await fetch('/items');
         *      return items.json()
         *   } catch(err) {
         *      console.error(err)
         *   }
         * });
         * ```
         *
         * @example
         * ```js
         * const example = new Choices(element);
         *
         * example.setChoices([{
         *   label: 'Group one',
         *   id: 1,
         *   disabled: false,
         *   choices: [
         *     {value: 'Child One', label: 'Child One', selected: true},
         *     {value: 'Child Two', label: 'Child Two',  disabled: true},
         *     {value: 'Child Three', label: 'Child Three'},
         *   ]
         * },
         * {
         *   label: 'Group two',
         *   id: 2,
         *   disabled: false,
         *   choices: [
         *     {value: 'Child Four', label: 'Child Four', disabled: true},
         *     {value: 'Child Five', label: 'Child Five'},
         *     {value: 'Child Six', label: 'Child Six', customProperties: {
         *       description: 'Custom description about child six',
         *       random: 'Another random custom property'
         *     }},
         *   ]
         * }], 'value', 'label', false);
         * ```
         */
        setChoices(choicesArrayOrFetcher = [], value = 'value', label = 'label', replaceChoices = false,callback) {
            if (!this.initialised) {
                throw new ReferenceError(`setChoices was called on a non-initialized instance of Choices`);
            }
            if (!this._isSelectElement) {
                throw new TypeError(`setChoices can't be used with INPUT based Choices`);
            }
            if (typeof value !== 'string' || !value) {
                throw new TypeError(`value parameter must be a name of 'value' field in passed objects`);
            }
            if (replaceChoices) {
                this.clearChoices();
            }
            if (typeof choicesArrayOrFetcher === 'function') {
                const fetcher = choicesArrayOrFetcher(this);
                if (typeof Promise === 'function' && fetcher instanceof Promise) {
                    return new Promise((resolve) => requestAnimationFrame(resolve))
                        .then(() => this._handleLoadingState(true))
                        .then(() => fetcher)
                        .then((data) => this.setChoices(data, value, label, replaceChoices))
                        .catch((err) => {
                        if (!this.config.silent) {
                            console.error(err);
                        }
                    })
                        .then(() => this._handleLoadingState(false))
                        .then(() => this);
                }
                if (!Array.isArray(fetcher)) {
                    throw new TypeError(`.setChoices first argument function must return either array of choices or Promise, got: ${typeof fetcher}`);
                }
                return this.setChoices(fetcher, value, label, false);
            }
            if (!Array.isArray(choicesArrayOrFetcher)) {
                throw new TypeError(`.setChoices must be called either with array of choices with a function resulting into Promise of array of choices`);
            }
            this.containerOuter.removeLoadingState();
            this._startLoading();
            choicesArrayOrFetcher.forEach((groupOrChoice) => {
                if (groupOrChoice.choices) {
                    this._addGroup({
                        id: groupOrChoice.id ? parseInt(`${groupOrChoice.id}`, 10) : null,
                        group: groupOrChoice,
                        valueKey: value,
                        labelKey: label,
                    });
                }
                else {
                    const choice = groupOrChoice;
                    this._addChoice({
                        value: choice[value],
                        label: choice[label],
                        isSelected: !!choice.selected,
                        isDisabled: !!choice.disabled,
                        placeholder: !!choice.placeholder,
                        customProperties: choice.customProperties,
                    });
                }
            });
            this._stopLoading();
            callback && callback.call(this);
            return this;
        }
        clearChoices(callback) {
            this._store.dispatch(clearChoices());
            callback && callback.call(this);
            return this;
        }
        clearStore(callback) {
            this._store.dispatch(clearAll());
            callback && callback.call(this);
            return this;
        }
        clearInput(callback) {
            const shouldSetInputWidth = !this._isSelectOneElement;
            this.input.clear(shouldSetInputWidth);
            if (!this._isTextElement && this._canSearch) {
                this._isSearching = false;
                this._store.dispatch(activateChoices(true));
            }
            callback && callback.call(this);
            return this;
        }
        _render(callback) {
            if (this._store.isLoading()) {
                return;
            }
            this._currentState = this._store.state;
            const stateChanged = this._currentState.choices !== this._prevState.choices ||
                this._currentState.groups !== this._prevState.groups ||
                this._currentState.items !== this._prevState.items;
            const shouldRenderChoices = this._isSelectElement;
            const shouldRenderItems = this._currentState.items !== this._prevState.items;
            if (!stateChanged) {
                return;
            }
            if (shouldRenderChoices) {
                this._renderChoices();
            }
            if (shouldRenderItems) {
                this._renderItems();
            }
            this._prevState = this._currentState;
            callback && callback.call(this);
        }
        _renderChoices() {
            const { activeGroups, activeChoices } = this._store;
            let choiceListFragment = document.createDocumentFragment();
            this.choiceList.clear();
            if (this.config.resetScrollPosition) {
                requestAnimationFrame(() => this.choiceList.scrollToTop());
            }
            if (activeGroups.length >= 1 && !this._isSearching) {
                const activePlaceholders = activeChoices.filter((activeChoice) => activeChoice.placeholder === true && activeChoice.groupId === -1);
                if (activePlaceholders.length >= 1) {
                    choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
                }
                choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
            }
            else if (activeChoices.length >= 1) {
                choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
            }
            if (choiceListFragment.childNodes &&
                choiceListFragment.childNodes.length > 0) {
                const { activeItems } = this._store;
                const canAddItem = this._canAddItem(activeItems, this.input.value);
                if (canAddItem.response) {
                    this.choiceList.append(choiceListFragment);
                    this._highlightChoice();
                }
                else {
                    const notice = this._getTemplate('notice', canAddItem.notice);
                    this.choiceList.append(notice);
                }
            }
            else {
                let dropdownItem;
                let notice;
                if (this._isSearching) {
                    notice =
                        typeof this.config.noResultsText === 'function'
                            ? this.config.noResultsText()
                            : this.config.noResultsText;
                    dropdownItem = this._getTemplate('notice', notice, 'no-results');
                }
                else {
                    notice =
                        typeof this.config.noChoicesText === 'function'
                            ? this.config.noChoicesText()
                            : this.config.noChoicesText;
                    dropdownItem = this._getTemplate('notice', notice, 'no-choices');
                }
                this.choiceList.append(dropdownItem);
            }
        }
        _renderItems() {
            const activeItems = this._store.activeItems || [];
            this.itemList.clear();
            const itemListFragment = this._createItemsFragment(activeItems);
            if (itemListFragment.childNodes) {
                this.itemList.append(itemListFragment);
            }
        }
        _createGroupsFragment(groups, choices, fragment = document.createDocumentFragment()) {
            const getGroupChoices = (group) => choices.filter((choice) => {
                if (this._isSelectOneElement) {
                    return choice.groupId === group.id;
                }
                return (choice.groupId === group.id &&
                    (this.config.renderSelectedChoices === 'always' || !choice.selected));
            });
            if (this.config.shouldSort) {
                groups.sort(this.config.sorter);
            }
            groups.forEach((group) => {
                const groupChoices = getGroupChoices(group);
                if (groupChoices.length >= 1) {
                    const dropdownGroup = this._getTemplate('choiceGroup', group);
                    fragment.appendChild(dropdownGroup);
                    this._createChoicesFragment(groupChoices, fragment, true);
                }
            });
            return fragment;
        }
        _createChoicesFragment(choices, fragment = document.createDocumentFragment(), withinGroup = false) {
            const { renderSelectedChoices, searchResultLimit, renderChoiceLimit } = this.config;
            const filter = this._isSearching ? sortByScore : this.config.sorter;
            const appendChoice = (choice) => {
                const shouldRender = renderSelectedChoices === 'auto'
                    ? this._isSelectOneElement || !choice.selected
                    : true;
                if (shouldRender) {
                    const dropdownItem = this._getTemplate('choice', choice, this.config.itemSelectText);
                    fragment.appendChild(dropdownItem);
                }
            };
            let rendererableChoices = choices;
            if (renderSelectedChoices === 'auto' && !this._isSelectOneElement) {
                rendererableChoices = choices.filter((choice) => !choice.selected);
            }
            const { placeholderChoices, normalChoices } = rendererableChoices.reduce((acc, choice) => {
                if (choice.placeholder) {
                    acc.placeholderChoices.push(choice);
                }
                else {
                    acc.normalChoices.push(choice);
                }
                return acc;
            }, {
                placeholderChoices: [],
                normalChoices: [],
            });
            if (this.config.shouldSort || this._isSearching) {
                normalChoices.sort(filter);
            }
            let choiceLimit = rendererableChoices.length;
            const sortedChoices = this._isSelectOneElement
                ? [...placeholderChoices, ...normalChoices]
                : normalChoices;
            if (this._isSearching) {
                choiceLimit = searchResultLimit;
            }
            else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
                choiceLimit = renderChoiceLimit;
            }
            for (let i = 0; i < choiceLimit; i += 1) {
                if (sortedChoices[i]) {
                    appendChoice(sortedChoices[i]);
                }
            }
            return fragment;
        }
        _createItemsFragment(items, fragment = document.createDocumentFragment()) {
            const { shouldSortItems, sorter, removeItemButton } = this.config;
            if (shouldSortItems && !this._isSelectOneElement) {
                items.sort(sorter);
            }
            if (this._isTextElement) {
                this.passedElement.value = items
                    .map(({ value }) => value)
                    .join(this.config.delimiter);
            }
            else {
                this.passedElement.options = items;
            }
            const addItemToFragment = (item) => {
                const listItem = this._getTemplate('item', item, removeItemButton);
                fragment.appendChild(listItem);
            };
            items.forEach(addItemToFragment);
            return fragment;
        }
        _triggerChange(value) {
            if (value === undefined || value === null) {
                return;
            }
            this.passedElement.triggerEvent(EVENTS.change, {
                value,
            });
        }
        _selectPlaceholderChoice(placeholderChoice) {
            this._addItem({
                value: placeholderChoice.value,
                label: placeholderChoice.label,
                choiceId: placeholderChoice.id,
                groupId: placeholderChoice.groupId,
                placeholder: placeholderChoice.placeholder,
            });
            this._triggerChange(placeholderChoice.value);
        }
        _handleButtonAction(activeItems, element) {
            if (!activeItems ||
                !element ||
                !this.config.removeItems ||
                !this.config.removeItemButton) {
                return;
            }
            const itemId = element.parentNode && element.parentNode.dataset.id;
            const itemToRemove = itemId && activeItems.find((item) => item.id === parseInt(itemId, 10));
            if (!itemToRemove) {
                return;
            }
            this._removeItem(itemToRemove);
            this._triggerChange(itemToRemove.value);
            if (this._isSelectOneElement && this._store.placeholderChoice) {
                this._selectPlaceholderChoice(this._store.placeholderChoice);
            }
        }
        _handleItemAction(activeItems, element, hasShiftKey = false) {
            if (!activeItems ||
                !element ||
                !this.config.removeItems ||
                this._isSelectOneElement) {
                return;
            }
            const passedId = element.dataset.id;
            activeItems.forEach((item) => {
                if (item.id === parseInt(`${passedId}`, 10) && !item.highlighted) {
                    this.highlightItem(item);
                }
                else if (!hasShiftKey && item.highlighted) {
                    this.unhighlightItem(item);
                }
            });
            this.input.focus();
        }
        _handleChoiceAction(activeItems, element) {
            if (!activeItems || !element) {
                return;
            }
            const { id } = element.dataset;
            const choice = id && this._store.getChoiceById(id);
            if (!choice) {
                return;
            }
            const passedKeyCode = activeItems[0] && activeItems[0].keyCode
                ? activeItems[0].keyCode
                : undefined;
            const hasActiveDropdown = this.dropdown.isActive;
            choice.keyCode = passedKeyCode;
            this.passedElement.triggerEvent(EVENTS.choice, {
                choice,
            });
            if (!choice.selected && !choice.disabled) {
                const canAddItem = this._canAddItem(activeItems, choice.value);
                if (canAddItem.response) {
                    this._addItem({
                        value: choice.value,
                        label: choice.label,
                        choiceId: choice.id,
                        groupId: choice.groupId,
                        customProperties: choice.customProperties,
                        placeholder: choice.placeholder,
                        keyCode: choice.keyCode,
                    });
                    this._triggerChange(choice.value);
                }
            }
            this.clearInput();
            if (hasActiveDropdown && this._isSelectOneElement) {
                this.hideDropdown(true);
                this.containerOuter.focus();
            }
        }
        _handleBackspace(activeItems) {
            if (!this.config.removeItems || !activeItems) {
                return;
            }
            const lastItem = activeItems[activeItems.length - 1];
            const hasHighlightedItems = activeItems.some((item) => item.highlighted);
            if (this.config.editItems && !hasHighlightedItems && lastItem) {
                this.input.value = lastItem.value;
                this.input.setWidth();
                this._removeItem(lastItem);
                this._triggerChange(lastItem.value);
            }
            else {
                if (!hasHighlightedItems) {
                    this.highlightItem(lastItem, false);
                }
                this.removeHighlightedItems(true);
            }
        }
        _startLoading() {
            this._store.dispatch(setIsLoading(true));
        }
        _stopLoading() {
            this._store.dispatch(setIsLoading(false));
        }
        _handleLoadingState(setLoading = true) {
            let placeholderItem = this.itemList.getChild(`.${this.config.classNames.placeholder}`);
            if (setLoading) {
                this.disable();
                this.containerOuter.addLoadingState();
                if (this._isSelectOneElement) {
                    if (!placeholderItem) {
                        placeholderItem = this._getTemplate('placeholder', this.config.loadingText);
                        if (placeholderItem) {
                            this.itemList.append(placeholderItem);
                        }
                    }
                    else {
                        placeholderItem.innerHTML = this.config.loadingText;
                    }
                }
                else {
                    this.input.placeholder = this.config.loadingText;
                }
            }
            else {
                this.enable();
                this.containerOuter.removeLoadingState();
                if (this._isSelectOneElement) {
                    if (placeholderItem) {
                        placeholderItem.innerHTML = this._placeholderValue || '';
                    }
                }
                else {
                    this.input.placeholder = this._placeholderValue || '';
                }
            }
        }
        _handleSearch(value) {
            if (!this.input.isFocussed) {
                return;
            }
            const { choices } = this._store;
            const { searchFloor, searchChoices } = this.config;
            const hasUnactiveChoices = choices.some((option) => !option.active);
            if (value !== null &&
                typeof value !== 'undefined' &&
                value.length >= searchFloor) {
                const resultCount = searchChoices ? this._searchChoices(value) : 0;
                this.passedElement.triggerEvent(EVENTS.search, {
                    value,
                    resultCount,
                });
            }
            else if (hasUnactiveChoices) {
                this._isSearching = false;
                this._store.dispatch(activateChoices(true));
            }
        }
        _canAddItem(activeItems, value) {
            let canAddItem = true;
            let notice = typeof this.config.addItemText === 'function'
                ? this.config.addItemText(value)
                : this.config.addItemText;
            if (!this._isSelectOneElement) {
                const isDuplicateValue = existsInArray(activeItems, value);
                if (this.config.maxItemCount > 0 &&
                    this.config.maxItemCount <= activeItems.length) {
                    canAddItem = false;
                    notice =
                        typeof this.config.maxItemText === 'function'
                            ? this.config.maxItemText(this.config.maxItemCount)
                            : this.config.maxItemText;
                }
                if (!this.config.duplicateItemsAllowed &&
                    isDuplicateValue &&
                    canAddItem) {
                    canAddItem = false;
                    notice =
                        typeof this.config.uniqueItemText === 'function'
                            ? this.config.uniqueItemText(value)
                            : this.config.uniqueItemText;
                }
                if (this._isTextElement &&
                    this.config.addItems &&
                    canAddItem &&
                    typeof this.config.addItemFilter === 'function' &&
                    !this.config.addItemFilter(value)) {
                    canAddItem = false;
                    notice =
                        typeof this.config.customAddItemText === 'function'
                            ? this.config.customAddItemText(value)
                            : this.config.customAddItemText;
                }
            }
            return {
                response: canAddItem,
                notice,
            };
        }
        _searchChoices(value) {
            const newValue = typeof value === 'string' ? value.trim() : value;
            const currentValue = typeof this._currentValue === 'string'
                ? this._currentValue.trim()
                : this._currentValue;
            if (newValue.length < 1 && newValue === `${currentValue} `) {
                return 0;
            }
            const haystack = this._store.searchableChoices;
            const needle = newValue;
            const options = Object.assign(this.config.fuseOptions, {
                keys: [...this.config.searchFields],
                includeMatches: true,
            });
            const fuse = new Fuse(haystack, options);
            const results = fuse.search(needle); 
            this._currentValue = newValue;
            this._highlightPosition = 0;
            this._isSearching = true;
            this._store.dispatch(filterChoices(results));
            return results.length;
        }
        _addEventListeners() {
            const { documentElement } = document;
            documentElement.addEventListener('touchend', this._onTouchEnd, true);
            this.containerOuter.element.addEventListener('keydown', this._onKeyDown, true);
            this.containerOuter.element.addEventListener('mousedown', this._onMouseDown, true);
            documentElement.addEventListener('click', this._onClick, { passive: true });
            documentElement.addEventListener('touchmove', this._onTouchMove, {
                passive: true,
            });
            this.dropdown.element.addEventListener('mouseover', this._onMouseOver, {
                passive: true,
            });
            if (this._isSelectOneElement) {
                this.containerOuter.element.addEventListener('focus', this._onFocus, {
                    passive: true,
                });
                this.containerOuter.element.addEventListener('blur', this._onBlur, {
                    passive: true,
                });
            }
            this.input.element.addEventListener('keyup', this._onKeyUp, {
                passive: true,
            });
            this.input.element.addEventListener('focus', this._onFocus, {
                passive: true,
            });
            this.input.element.addEventListener('blur', this._onBlur, {
                passive: true,
            });
            if (this.input.element.form) {
                this.input.element.form.addEventListener('reset', this._onFormReset, {
                    passive: true,
                });
            }
            this.input.addEventListeners();
        }
        _removeEventListeners() {
            const { documentElement } = document;
            documentElement.removeEventListener('touchend', this._onTouchEnd, true);
            this.containerOuter.element.removeEventListener('keydown', this._onKeyDown, true);
            this.containerOuter.element.removeEventListener('mousedown', this._onMouseDown, true);
            documentElement.removeEventListener('click', this._onClick);
            documentElement.removeEventListener('touchmove', this._onTouchMove);
            this.dropdown.element.removeEventListener('mouseover', this._onMouseOver);
            if (this._isSelectOneElement) {
                this.containerOuter.element.removeEventListener('focus', this._onFocus);
                this.containerOuter.element.removeEventListener('blur', this._onBlur);
            }
            this.input.element.removeEventListener('keyup', this._onKeyUp);
            this.input.element.removeEventListener('focus', this._onFocus);
            this.input.element.removeEventListener('blur', this._onBlur);
            if (this.input.element.form) {
                this.input.element.form.removeEventListener('reset', this._onFormReset);
            }
            this.input.removeEventListeners();
        }
        _onKeyDown(event) {
            const { keyCode } = event;
            const { activeItems } = this._store;
            const hasFocusedInput = this.input.isFocussed;
            const hasActiveDropdown = this.dropdown.isActive;
            const hasItems = this.itemList.hasChildren();
            const keyString = String.fromCharCode(keyCode);
            const wasAlphaNumericChar = /[a-zA-Z0-9-_ ]/.test(keyString);
            const { BACK_KEY, DELETE_KEY, ENTER_KEY, A_KEY, ESC_KEY, UP_KEY, DOWN_KEY, PAGE_UP_KEY, PAGE_DOWN_KEY, } = KEY_CODES;
            if (!this._isTextElement && !hasActiveDropdown && wasAlphaNumericChar) {
                this.showDropdown();
                if (!this.input.isFocussed) {
                    /*
                      We update the input value with the pressed key as
                      the input was not focussed at the time of key press
                      therefore does not have the value of the key.
                    */
                    this.input.value += keyString.toLowerCase();
                }
            }
            switch (keyCode) {
                case A_KEY:
                    return this._onSelectKey(event, hasItems);
                case ENTER_KEY:
                    return this._onEnterKey(event, activeItems, hasActiveDropdown);
                case ESC_KEY:
                    return this._onEscapeKey(hasActiveDropdown);
                case UP_KEY:
                case PAGE_UP_KEY:
                case DOWN_KEY:
                case PAGE_DOWN_KEY:
                    return this._onDirectionKey(event, hasActiveDropdown);
                case DELETE_KEY:
                case BACK_KEY:
                    return this._onDeleteKey(event, activeItems, hasFocusedInput);
            }
        }
        _onKeyUp({ target, keyCode, }) {
            const { value } = this.input;
            const { activeItems } = this._store;
            const canAddItem = this._canAddItem(activeItems, value);
            const { BACK_KEY: backKey, DELETE_KEY: deleteKey } = KEY_CODES;
            if (this._isTextElement) {
                const canShowDropdownNotice = canAddItem.notice && value;
                if (canShowDropdownNotice) {
                    const dropdownItem = this._getTemplate('notice', canAddItem.notice);
                    this.dropdown.element.innerHTML = dropdownItem.outerHTML;
                    this.showDropdown(true);
                }
                else {
                    this.hideDropdown(true);
                }
            }
            else {
                const wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey;
                const userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
                const canReactivateChoices = !this._isTextElement && this._isSearching;
                const canSearch = this._canSearch && canAddItem.response;
                if (userHasRemovedValue && canReactivateChoices) {
                    this._isSearching = false;
                    this._store.dispatch(activateChoices(true));
                }
                else if (canSearch) {
                    this._handleSearch(this.input.rawValue);
                }
            }
            this._canSearch = this.config.searchEnabled;
        }
        _onSelectKey(event, hasItems) {
            const { ctrlKey, metaKey } = event;
            const hasCtrlDownKeyPressed = ctrlKey || metaKey;
            if (hasCtrlDownKeyPressed && hasItems) {
                this._canSearch = false;
                const shouldHightlightAll = this.config.removeItems &&
                    !this.input.value &&
                    this.input.element === document.activeElement;
                if (shouldHightlightAll) {
                    this.highlightAll();
                }
            }
        }
        _onEnterKey(event, activeItems, hasActiveDropdown) {
            const { target } = event;
            const { ENTER_KEY: enterKey } = KEY_CODES;
            const targetWasButton = target && target.hasAttribute('data-button');
            if (this._isTextElement && target && target.value) {
                const { value } = this.input;
                const canAddItem = this._canAddItem(activeItems, value);
                if (canAddItem.response) {
                    this.hideDropdown(true);
                    this._addItem({ value });
                    this._triggerChange(value);
                    this.clearInput();
                }
            }
            if (targetWasButton) {
                this._handleButtonAction(activeItems, target);
                axPreventDefault(event);
            }
            if (hasActiveDropdown) {
                const highlightedChoice = this.dropdown.getChild(`.${this.config.classNames.highlightedState}`);
                if (highlightedChoice) {
                    if (activeItems[0]) {
                        activeItems[0].keyCode = enterKey; 
                    }
                    this._handleChoiceAction(activeItems, highlightedChoice);
                }
                axPreventDefault(event);
            }
            else if (this._isSelectOneElement) {
                this.showDropdown();
                axPreventDefault(event);
            }
        }
        _onEscapeKey(hasActiveDropdown) {
            if (hasActiveDropdown) {
                this.hideDropdown(true);
                this.containerOuter.focus();
            }
        }
        _onDirectionKey(event, hasActiveDropdown) {
            const { keyCode, metaKey } = event;
            const { DOWN_KEY: downKey, PAGE_UP_KEY: pageUpKey, PAGE_DOWN_KEY: pageDownKey, } = KEY_CODES;
            if (hasActiveDropdown || this._isSelectOneElement) {
                this.showDropdown();
                this._canSearch = false;
                const directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
                const skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
                const selectableChoiceIdentifier = '[data-choice-selectable]';
                let nextEl;
                if (skipKey) {
                    if (directionInt > 0) {
                        nextEl = this.dropdown.element.querySelector(`${selectableChoiceIdentifier}:last-of-type`);
                    }
                    else {
                        nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                    }
                }
                else {
                    const currentEl = this.dropdown.element.querySelector(`.${this.config.classNames.highlightedState}`);
                    if (currentEl) {
                        nextEl = getAdjacentEl(currentEl, selectableChoiceIdentifier, directionInt);
                    }
                    else {
                        nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                    }
                }
                if (nextEl) {
                    if (!isScrolledIntoView(nextEl, this.choiceList.element, directionInt)) {
                        this.choiceList.scrollToChildElement(nextEl, directionInt);
                    }
                    this._highlightChoice(nextEl);
                }
                axPreventDefault(event);
            }
        }
        _onDeleteKey(event, activeItems, hasFocusedInput) {
            const { target } = event;
            if (!this._isSelectOneElement &&
                !target.value &&
                hasFocusedInput) {
                this._handleBackspace(activeItems);
                axPreventDefault(event);
            }
        }
        _onTouchMove() {
            if (this._wasTap) {
                this._wasTap = false;
            }
        }
        _onTouchEnd(event) {
            const { target } = event || event.touches[0];
            const touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
            if (touchWasWithinContainer) {
                const containerWasExactTarget = target === this.containerOuter.element ||
                    target === this.containerInner.element;
                if (containerWasExactTarget) {
                    if (this._isTextElement) {
                        this.input.focus();
                    }
                    else if (this._isSelectMultipleElement) {
                        this.showDropdown();
                    }
                }
                event.stopPropagation();
            }
            this._wasTap = true;
        }
        /**
         * Handles mousedown event in capture mode for containetOuter.element
         */
        _onMouseDown(event) {
            const { target } = event;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (IS_IE11 && this.choiceList.element.contains(target)) {
                const firstChoice = this.choiceList.element
                    .firstElementChild;
                const isOnScrollbar = this._direction === 'ltr'
                    ? event.offsetX >= firstChoice.offsetWidth
                    : event.offsetX < firstChoice.offsetLeft;
                this._isScrollingOnIe = isOnScrollbar;
            }
            if (target === this.input.element) {
                return;
            }
            const item = target.closest('[data-button],[data-item],[data-choice]');
            if (item instanceof HTMLElement) {
                const hasShiftKey = event.shiftKey;
                const { activeItems } = this._store;
                const { dataset } = item;
                if ('button' in dataset) {
                    this._handleButtonAction(activeItems, item);
                }
                else if ('item' in dataset) {
                    this._handleItemAction(activeItems, item, hasShiftKey);
                }
                else if ('choice' in dataset) {
                    this._handleChoiceAction(activeItems, item);
                }
            }
            axPreventDefault(event);
        }
        /**
         * Handles mouseover event over this.dropdown
         * @param {MouseEvent} event
         */
        _onMouseOver({ target }) {
            if (target instanceof HTMLElement && 'choice' in target.dataset) {
                this._highlightChoice(target);
            }
        }
        _onClick({ target }) {
            const clickWasWithinContainer = this.containerOuter.element.contains(target);
            if (clickWasWithinContainer) {
                if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
                    if (this._isTextElement) {
                        if (document.activeElement !== this.input.element) {
                            this.input.focus();
                        }
                    }
                    else {
                        this.showDropdown();
                        this.containerOuter.focus();
                    }
                }
                else if (this._isSelectOneElement &&
                    target !== this.input.element &&
                    !this.dropdown.element.contains(target)) {
                    this.hideDropdown();
                }
            }
            else {
                const hasHighlightedItems = this._store.highlightedActiveItems.length > 0;
                if (hasHighlightedItems) {
                    this.unhighlightAll();
                }
                this.containerOuter.removeFocusState();
                this.hideDropdown(true);
            }
        }
        _onFocus({ target }) {
            const focusWasWithinContainer = target && this.containerOuter.element.contains(target);
            if (!focusWasWithinContainer) {
                return;
            }
            const focusActions = {
                [TEXT_TYPE]: () => {
                    if (target === this.input.element) {
                        this.containerOuter.addFocusState();
                    }
                },
                [SELECT_ONE_TYPE]: () => {
                    this.containerOuter.addFocusState();
                    if (target === this.input.element) {
                        this.showDropdown(true);
                    }
                },
                [SELECT_MULTIPLE_TYPE]: () => {
                    if (target === this.input.element) {
                        this.showDropdown(true);
                        this.containerOuter.addFocusState();
                    }
                },
            };
            focusActions[this.passedElement.element.type]();
        }
        _onBlur({ target }) {
            const blurWasWithinContainer = target && this.containerOuter.element.contains(target);
            if (blurWasWithinContainer && !this._isScrollingOnIe) {
                const { activeItems } = this._store;
                const hasHighlightedItems = activeItems.some((item) => item.highlighted);
                const blurActions = {
                    [TEXT_TYPE]: () => {
                        if (target === this.input.element) {
                            this.containerOuter.removeFocusState();
                            if (hasHighlightedItems) {
                                this.unhighlightAll();
                            }
                            this.hideDropdown(true);
                        }
                    },
                    [SELECT_ONE_TYPE]: () => {
                        this.containerOuter.removeFocusState();
                        if (target === this.input.element ||
                            (target === this.containerOuter.element && !this._canSearch)) {
                            this.hideDropdown(true);
                        }
                    },
                    [SELECT_MULTIPLE_TYPE]: () => {
                        if (target === this.input.element) {
                            this.containerOuter.removeFocusState();
                            this.hideDropdown(true);
                            if (hasHighlightedItems) {
                                this.unhighlightAll();
                            }
                        }
                    },
                };
                blurActions[this.passedElement.element.type]();
            }
            else {
                this._isScrollingOnIe = false;
                this.input.element.focus();
            }
        }
        _onFormReset() {
            this._store.dispatch(resetTo(this._initialState));
        }
        _highlightChoice(el = null) {
            const choices = Array.from(this.dropdown.element.querySelectorAll('[data-choice-selectable]'));
            if (!choices.length) {
                return;
            }
            let passedEl = el;
            const highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(`.${this.config.classNames.highlightedState}`));
            highlightedChoices.forEach((choice) => {
                choice.classList.remove(this.config.classNames.highlightedState);
                choice.setAttribute('aria-selected', 'false');
            });
            if (passedEl) {
                this._highlightPosition = choices.indexOf(passedEl);
            }
            else {
                if (choices.length > this._highlightPosition) {
                    passedEl = choices[this._highlightPosition];
                }
                else {
                    passedEl = choices[choices.length - 1];
                }
                if (!passedEl) {
                    passedEl = choices[0];
                }
            }
            passedEl.classList.add(this.config.classNames.highlightedState);
            passedEl.setAttribute('aria-selected', 'true');
            this.passedElement.triggerEvent(EVENTS.highlightChoice, { el: passedEl });
            if (this.dropdown.isActive) {
                this.input.setActiveDescendant(passedEl.id);
                this.containerOuter.setActiveDescendant(passedEl.id);
            }
        }
        _addItem({ value, label = null, choiceId = -1, groupId = -1, customProperties = {}, placeholder = false, keyCode = -1, }) {
            let passedValue = typeof value === 'string' ? value.trim() : value;
            const { items } = this._store;
            const passedLabel = label || passedValue;
            const passedOptionId = choiceId || -1;
            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
            const id = items ? items.length + 1 : 1;
            if (this.config.prependValue) {
                passedValue = this.config.prependValue + passedValue.toString();
            }
            if (this.config.appendValue) {
                passedValue += this.config.appendValue.toString();
            }
            this._store.dispatch(addItem({
                value: passedValue,
                label: passedLabel,
                id,
                choiceId: passedOptionId,
                groupId,
                customProperties,
                placeholder,
                keyCode,
            }));
            if (this._isSelectOneElement) {
                this.removeActiveItems(id);
            }
            this.passedElement.triggerEvent(EVENTS.addItem, {
                id,
                value: passedValue,
                label: passedLabel,
                customProperties,
                groupValue: group && group.value ? group.value : null,
                keyCode,
            });
        }
        _removeItem(item) {
            const { id, value, label, customProperties, choiceId, groupId } = item;
            const group = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;
            if (!id || !choiceId) {
                return;
            }
            this._store.dispatch(removeItem(id, choiceId));
            this.passedElement.triggerEvent(EVENTS.removeItem, {
                id,
                value,
                label,
                customProperties,
                groupValue: group && group.value ? group.value : null,
            });
        }
        _addChoice({ value, label = null, isSelected = false, isDisabled = false, groupId = -1, customProperties = {}, placeholder = false, keyCode = -1, }) {
            if (typeof value === 'undefined' || value === null) {
                return;
            }
            const { choices } = this._store;
            const choiceLabel = label || value;
            const choiceId = choices ? choices.length + 1 : 1;
            const choiceElementId = `${this._baseId}-${this._idNames.itemChoice}-${choiceId}`;
            this._store.dispatch(addChoice({
                id: choiceId,
                groupId,
                elementId: choiceElementId,
                value,
                label: choiceLabel,
                disabled: isDisabled,
                customProperties,
                placeholder,
                keyCode,
            }));
            if (isSelected) {
                this._addItem({
                    value,
                    label: choiceLabel,
                    choiceId,
                    customProperties,
                    placeholder,
                    keyCode,
                });
            }
        }
        _addGroup({ group, id, valueKey = 'value', labelKey = 'label' }) {
            const groupChoices = axTypeIs('Object', group)
                ? group.choices
                : Array.from(group.getElementsByTagName('OPTION'));
            const groupId = id || Math.floor(new Date().valueOf() * Math.random());
            const isDisabled = group.disabled ? group.disabled : false;
            if (groupChoices) {
                this._store.dispatch(addGroup({
                    value: group.label,
                    id: groupId,
                    active: true,
                    disabled: isDisabled,
                }));
                const addGroupChoices = (choice) => {
                    const isOptDisabled = choice.disabled || (choice.parentNode && choice.parentNode.disabled);
                    this._addChoice({
                        value: choice[valueKey],
                        label: axTypeIs('Object', choice) ? choice[labelKey] : choice.innerHTML,
                        isSelected: choice.selected,
                        isDisabled: isOptDisabled,
                        groupId,
                        customProperties: choice.customProperties,
                        placeholder: choice.placeholder,
                    });
                };
                groupChoices.forEach(addGroupChoices);
            }
            else {
                this._store.dispatch(addGroup({
                    value: group.label,
                    id: group.id,
                    active: false,
                    disabled: group.disabled,
                }));
            }
        }
        _getTemplate(template, ...args) {
            return this._templates[template].call(this, this.config, ...args);
        }
        _createTemplates() {
            const { callbackOnCreateTemplates } = this.config;
            let userTemplates = {};
            if (callbackOnCreateTemplates &&
                typeof callbackOnCreateTemplates === 'function') {
                userTemplates = callbackOnCreateTemplates.call(this, strToEl);
            }
            this._templates = axMerge(templates, userTemplates,{arrAppend:true,attrAppend:true,clone:true});
        }
        _createElements() {
            this.containerOuter = new Container({
                element: this._getTemplate('containerOuter', this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
                position: this.config.position,
            });
            this.containerInner = new Container({
                element: this._getTemplate('containerInner'),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
                position: this.config.position,
            });
            this.input = new Input({
                element: this._getTemplate('input', this._placeholderValue),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
                preventPaste: !this.config.paste,
            });
            this.choiceList = new List({
                element: this._getTemplate('choiceList', this._isSelectOneElement),
            });
            this.itemList = new List({
                element: this._getTemplate('itemList', this._isSelectOneElement),
            });
            this.dropdown = new Dropdown({
                element: this._getTemplate('dropdown'),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
            });
        }
        _createStructure() {
            this.passedElement.conceal();
            this.containerInner.wrap(this.passedElement.element);
            this.containerOuter.wrap(this.containerInner.element);
            if (this._isSelectOneElement) {
                this.input.placeholder = this.config.searchPlaceholderValue || '';
            }
            else if (this._placeholderValue) {
                this.input.placeholder = this._placeholderValue;
                this.input.setWidth();
            }
            this.containerOuter.element.appendChild(this.containerInner.element);
            this.containerOuter.element.appendChild(this.dropdown.element);
            this.containerInner.element.appendChild(this.itemList.element);
            if (!this._isTextElement) {
                this.dropdown.element.appendChild(this.choiceList.element);
            }
            if (!this._isSelectOneElement) {
                this.containerInner.element.appendChild(this.input.element);
            }
            else if (this.config.searchEnabled) {
                this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
            }
            if (this._isSelectElement) {
                this._highlightPosition = 0;
                this._isSearching = false;
                this._startLoading();
                if (this._presetGroups.length) {
                    this._addPredefinedGroups(this._presetGroups);
                }
                else {
                    this._addPredefinedChoices(this._presetChoices);
                }
                this._stopLoading();
            }
                            if(this.config.width){
                                this.containerOuter.element.style.width = this.config.width;
                            }else{
                                if(this.origElem.style && this.origElem.style.width){
                                    this.containerOuter.element.style.width = this.origElem.style.width;
                                }
                            }
            if (this._isTextElement) {
                this._addPredefinedItems(this._presetItems);
            }
            if (!this._isSelectOneElement) {
                this.containerInner.element.appendChild(this.input.element);
            } else
                if (this.config.searchEnabled) {
                    this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
                }
        }
        _addPredefinedGroups(groups) {
            const placeholderChoice = this.passedElement
                .placeholderOption;
            if (placeholderChoice &&
                placeholderChoice.parentNode &&
                placeholderChoice.parentNode.tagName === 'SELECT') {
                this._addChoice({
                    value: placeholderChoice.value,
                    label: placeholderChoice.innerHTML,
                    isSelected: placeholderChoice.selected,
                    isDisabled: placeholderChoice.disabled,
                    placeholder: true,
                });
            }
            groups.forEach((group) => this._addGroup({
                group,
                id: group.id || null,
            }));
        }
        _addPredefinedChoices(choices) {
            if (this.config.shouldSort) {
                choices.sort(this.config.sorter);
            }
            const hasSelectedChoice = choices.some((choice) => choice.selected);
            const firstEnabledChoiceIndex = choices.findIndex((choice) => choice.disabled === undefined || !choice.disabled);
            choices.forEach((choice, index) => {
                const { value = '', label, customProperties, placeholder } = choice;
                if (this._isSelectElement) {
                    if (choice.choices) {
                        this._addGroup({
                            group: choice,
                            id: choice.id || null,
                        });
                    }
                    else {
                        /**
                         * If there is a selected choice already or the choice is not the first in
                         * the array, add each choice normally.
                         *
                         * Otherwise we pre-select the first enabled choice in the array ("select-one" only)
                         */
                        const shouldPreselect = this._isSelectOneElement &&
                            !hasSelectedChoice &&
                            index === firstEnabledChoiceIndex;
                        const isSelected = shouldPreselect ? true : choice.selected;
                        const isDisabled = choice.disabled;
                        this._addChoice({
                            value,
                            label,
                            isSelected: !!isSelected,
                            isDisabled: !!isDisabled,
                            placeholder: !!placeholder,
                            customProperties,
                        });
                    }
                }
                else {
                    this._addChoice({
                        value,
                        label,
                        isSelected: !!choice.selected,
                        isDisabled: !!choice.disabled,
                        placeholder: !!choice.placeholder,
                        customProperties,
                    });
                }
            });
        }
        _addPredefinedItems(items) {
            items.forEach((item) => {
                if (typeof item === 'object' && item.value) {
                    this._addItem({
                        value: item.value,
                        label: item.label,
                        choiceId: item.id,
                        customProperties: item.customProperties,
                        placeholder: item.placeholder,
                    });
                }
                if (typeof item === 'string') {
                    this._addItem({
                        value: item,
                    });
                }
            });
        }
        _setChoiceOrItem(item) {
            const itemType = axType(item).toLowerCase(); 
            const handleType = {
                object: () => {
                    if (!item.value) {
                        return;
                    }
                    if (!this._isTextElement) {
                        this._addChoice({
                            value: item.value,
                            label: item.label,
                            isSelected: true,
                            isDisabled: false,
                            customProperties: item.customProperties,
                            placeholder: item.placeholder,
                        });
                    }
                    else {
                        this._addItem({
                            value: item.value,
                            label: item.label,
                            choiceId: item.id,
                            customProperties: item.customProperties,
                            placeholder: item.placeholder,
                        });
                    }
                },
                string: () => {
                    if (!this._isTextElement) {
                        this._addChoice({
                            value: item,
                            label: item,
                            isSelected: true,
                            isDisabled: false,
                        });
                    }
                    else {
                        this._addItem({
                            value: item,
                        });
                    }
                },
            };
            handleType[itemType]();
        }
        _findAndSelectChoiceByValue(value) {
            const { choices } = this._store;
            const foundChoice = choices.find((choice) => this.config.valueComparer(choice.value, value));
            if (foundChoice && !foundChoice.selected) {
                this._addItem({
                    value: foundChoice.value,
                    label: foundChoice.label,
                    choiceId: foundChoice.id,
                    groupId: foundChoice.groupId,
                    customProperties: foundChoice.customProperties,
                    placeholder: foundChoice.placeholder,
                    keyCode: foundChoice.keyCode,
                });
            }
        }
        _generatePlaceholderValue() {
            if (this._isSelectElement &&
                this.passedElement.placeholderOption) {
                const { placeholderOption } = this.passedElement;
                return placeholderOption ? placeholderOption.text : null;
            }
            const { placeholder, placeholderValue } = this.config;
            const { element: { dataset }, } = this.passedElement;
            if (placeholder) {
                if (placeholderValue) {
                    return placeholderValue;
                }
                if (dataset.placeholder) {
                    return dataset.placeholder;
                }
            }
            return null;
        }
    }
    return Choices;
}));
/*!
 * 插件：查看更多；使用方法：new axDropdown('#id',{参数})
 */
class axDropdown {
    constructor(elem, options) {
        this.options = axExtend({
            content: '',
            arrow: true,
            padding: false,
            size: 'sm',
            width: '',
            placement: 'bottom',
            trigger: 'click',
            break: true,
            node: 'a',
            ellipsis: true,
            theme: '',
        }, options, elem);
        let _this = this;
        this.button = axIdToDom(elem);
        this.content = '';
        let strToDom = function (str) {
            let arr = typeof str == 'string' ? JSON.parse(str) : str,
                textDom = axAddElem('div');
            arr.forEach((item, index) => {
                let outer = '';
                if (_this.options.node == 'a') {
                    outer = axAddElem(_this.options.node, { class: 'ax-info-block', href: item.link ? item.link : '##', target: item.target ? item.target : '_blank' }, '<div class="ax-row"><div class="ax-col"></div></div>');
                } else {
                    outer = axAddElem(_this.options.node, { class: 'ax-info-block' }, '<div class="ax-row"><div class="ax-col"></div></div>');
                }
                if (item.className) {
                    outer.classList.add(item.className);
                }
                if (_this.options.ellipsis) {
                    if (_this.options.node != 'a' && item.link) {
                        outer.querySelector('.ax-col').appendChild(axAddElem('a', { class: 'ax-ell', href: item.link, target: item.target ? item.target : '_blank' }, item.name))
                    } else {
                        outer.querySelector('.ax-col').appendChild(axAddElem('span', { class: 'ax-ell' }, item.name))
                    }
                } else {
                    outer.querySelector('.ax-col').textContent = item.name;
                }
                if (item.icon) {
                    outer.querySelector('.ax-col').insertAdjacentElement('beforebegin', axAddElem('span', { class: 'ax-icon ax-iconfont ' + item.icon }));
                } else if (item.head) {
                    outer.querySelector('.ax-col').insertAdjacentElement('beforebegin', axAddElem('span', { class: 'ax-head',style: 'background-image:url('+item.head+');' }));
                }
                if (item.suffix) {
                    outer.querySelector('.ax-col').insertAdjacentElement('afterend', axAddElem('span', { class: 'ax-arrow' }, item.suffix));
                }
                textDom.appendChild(outer);
                if (_this.options.break && arr.length != index + 1) {
                    outer.insertAdjacentHTML('afterend', '<div class="ax-break-line"></div>');
                }
            })
            return textDom;
        }
        if (axTypeIs('Array',this.options.content)) {
            this.content = strToDom(this.options.content);
        } else if (axTypeIs('String',this.options.content)) {
            this.content = this.options.content;
        }
        this.init();
    }
    init() {
        let _this = this;
        this.popup = new axPopup(this.button, {
            padding: _this.options.padding,
            arrow: _this.options.arrow,
            in: 'slideDown',
            out: 'slideUp',
            size: _this.options.size,
            width: _this.options.width,
            trigger: _this.options.trigger,
            placement: _this.options.placement,
            theme: _this.options.theme,
            content: _this.content,
            footerShow: false,
            close: false,
        })
        if(axTypeIs('Array',this.options.content)){
            this.popup.body.innerHTML = this.content.innerHTML;
            this.popup.wrapperHeight = axArrHeight(this.popup.wrapper).height;
        }
        return this;
    }
}
(() => {
    document.querySelectorAll('[axDropdown]').forEach(element => {
        new axDropdown(element);
    });
})();
/*!
* 插件：表单数量步进增减；使用方法：new axAmount('#id',{参数})
*/
const axAmounts = [];
class axAmount {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            value: '',
            min: '',
            max: '',
            step: 1,
            precision: 0,
            rule: '',
            disabled: false,
            increase: true,
            decrease: true,
            cookie: '',
        }, options, this.targetDom);
        let _this = this;
        this.handlers = {};
        this.increase = this.targetDom.querySelector('[increase]');
        this.decrease = this.targetDom.querySelector('[decrease]');
        this.input = this.targetDom.querySelector('input');
        !!this.targetDom.getAttribute('axAmount') ? this.referName = this.targetDom.getAttribute('axAmount') : this.referName = '';
        this.init();
    }
    init() {
        let _this = this;
        switch (this.options.rule) {
            case 'currency':
                this.options.min = 0.00; this.options.max = null; this.options.step = 0.01; this.options.precision = 2;
                break;
            case 'quantity':
                this.options.min = 1; this.options.max = 999; this.options.step = 1; this.options.precision = 0;
                break;
            case 'percent':
                this.options.min = 0; this.options.max = 100; this.options.step = 1; this.options.precision = 0;
                break;
            case 'month':
                this.options.min = 1; this.options.max = 12; this.options.step = 1; this.options.precision = 0;
                break;
            case 'day':
                this.options.min = 1; this.options.max = 31; this.options.step = 1; this.options.precision = 0;
                break;
            case 'hour':
                this.options.min = 0; this.options.max = 24; this.options.step = 1; this.options.precision = 0;
                break;
            case 'minute':
                this.options.min = 0; this.options.max = 59; this.options.step = 1; this.options.precision = 0;
                break;
            case 'second':
                this.options.min = 0; this.options.max = 59; this.options.step = 1; this.options.precision = 0;
                break;
            default:
                null;
        }
        if (this.options.cookie) {
            this.options.value = axCookie.get(this.options.cookie);
        }
        if (this.options.value) {
            if (this.options.min && this.options.value < this.options.min) {
                this.options.value = this.options.min;
            } else if (this.options.max && this.options.value > this.options.max) {
                this.options.value = this.options.max;
            }
            this.input.value = this.options.value;
        }
        if (this.options.min && this.options.min > Number(_this.input.value)) {
            this.input.value = this.options.min;
        }
        if (this.options.max && this.options.max < Number(_this.input.value)) {
            this.input.value = this.options.max;
        }
        if (this.options.disabled) {
            this.input.setAttribute('disabled', 'true');
            this.increase.setAttribute('diabled', 'true');
            this.decrease.setAttribute('diabled', 'true');
        }
        if (!this.options.increase) {
            this.increase.setAttribute('diabled', 'true');
        }
        if (!this.options.decrease) {
            this.decrease.setAttribute('diabled', 'true');
        }
        let activeIn = true,
            activeDe = true;
        this.eventIncrease = function () {
            if (!activeDe) {
                _this.options.decreae = true;
                _this.decrease.removeAttribute('disabled');
            }
            let val = Number(_this.input.value),
                old = Number(_this.input.value);
            if (_this.options.max === '') {
                val = val + _this.options.step;
            } else if (_this.options.max !== '' && val < _this.options.max) {
                val = val + _this.options.step;
            }
            if (_this.options.max !== '' && ((val + _this.options.step) > _this.options.max)) {
                _this.options.increae = false;
                _this.increase.setAttribute('disabled', 'true');
                activeIn = false;
                'maxed' in _this.handlers ? _this.emit('maxed', '') : null;
            }
            _this.input.value = val.toFixed(_this.options.precision);
            if (_this.input.value > old) {
                'changed' in _this.handlers ? _this.emit('changed', old, _this.input.value) : null;
            }
            if (_this.options.cookie) {
                axCookie.set(_this.options.cookie, Number(_this.input.value));
            }
        }
        this.eventDecrease = function () {
            if (!activeIn) {
                _this.options.increae = true;
                _this.increase.removeAttribute('disabled');
            }
            let val = Number(_this.input.value),
                old = Number(_this.input.value);
            if (_this.options.min === '') {
                val = val - _this.options.step;
            } else if (_this.options.min !== '' && val > _this.options.min) {
                val = val - _this.options.step;
            }
            if (_this.options.min !== '' && ((val - _this.options.step) < _this.options.min)) {
                _this.options.decreae = false;
                _this.decrease.setAttribute('disabled', 'true');
                activeDe = false;
                'mined' in _this.handlers ? _this.emit('mined', '') : null;
            }
            _this.input.value = val.toFixed(_this.options.precision);
            if (_this.input.value < old) {
                'changed' in _this.handlers ? _this.emit('changed', old, _this.input.value) : null;
            }
            if (_this.options.cookie) {
                axCookie.set(_this.options.cookie, Number(_this.input.value));
            }
        }
        this.eventKey = function (e) {
            if (e.keyCode == '38' || e.keyCode == '39') {
                _this.eventIncrease();
            } else if (e.keyCode == '37' || e.keyCode == '40') {
                _this.eventDecrease();
            }
        }
        if (this.options.disabled || this.input.hasAttribute('disabled')) {
            this.increase.removeEventListener('click', this.eventIncrease, false);
            this.decrease.removeEventListener('click', this.eventDecrease, false);
        } else {
            if (!this.options.increase || this.increase.hasAttribute('disabled')) {
                this.increase.removeEventListener('click', this.eventIncrease, false);
            } else {
                this.increase.addEventListener('click', this.eventIncrease, false);
                this.input.addEventListener('keydown', this.eventKey, false);
            }
            if (!this.options.decrease || this.decrease.hasAttribute('disabled')) {
                this.decrease.removeEventListener('click', this.eventdecrease, false);
            } else {
                this.decrease.addEventListener('click', this.eventDecrease, false);
                this.input.addEventListener('keydown', this.eventKey, false);
            }
        }
        if (this.referName) {
            if (axIsEmpty(axAmounts)) {
                axAmounts.push({ name: this.referName, instance: this });
            } else {
                if (!axAmounts.some(item => (item.name == this.referName))) {
                    axAmounts.push({ name: this.referName, instance: this });
                }
                /* for (let i = 0; i < axAmounts.length; i++) {
                    if (axAmounts[i].name == this.referName) {
                        axAmounts[i].instance = this;
                        break;
                    } else {
                        axAmounts.push({ name: this.referName, instance: this });
                    }
                } */
            }
        }
    }
    update(setting, callback) {
        let _this = this;
        this.options = axExtend(this.options, setting);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        this.input.removeAttribute('disabled');
        this.increase.removeAttribute('disabled');
        this.decrease.removeAttribute('disabled');
        this.input.removeEventListener('keydown', this.eventKey, false);
        this.increase.removeEventListener('click', this.eventIncrease, false);
        this.decrease.removeEventListener('click', this.eventDecrease, false);
        callback && callback.call(this);
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
document.querySelectorAll('[axAmount]').forEach(element => {
    new axAmount(element);
});
/*!
* 插件：页面社交分享；使用方法：new axShare('#id',{参数})
*/
class axShare {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            source: '',
            title: '',
            des: '',
            url: window.location.href,
            image: '',
            key: '',
            origin: window.location.origin,
            qrTitle: '<p>在微信里点击“发现”，再点击“扫一扫，”<br />便可将本文分享至朋友圈。</p>',
            qrSize: 180,
            newPage: true,
            dialogText: '确定分享本页面？',
            onShare: '',
        }, options, this.targetDom);
        let _this = this;
        this.handlers = {};
        if (!this.options.source) {
            this.options.source = document.querySelector('meta[name="site"]') || document.title;
        }
        if (!this.options.title) {
            this.options.title = document.querySelector('meta[name="title"]') || document.title;
        }
        if (!this.options.des) {
            this.options.des = document.querySelector('meta[name="description"]') || '';
        }
        if (!this.options.image) {
            this.options.image = (document.images[0] || 0).src || '';
        }
        this.init();
    }
    init() {
        this.shareUrl = {
            qzone: 'http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + this.options.url + '&title=' + this.options.title + '&desc=' + this.options.des + '&summary=' + this.options.summary + '&site=' + this.options.source + '&pics=' + this.options.image,
            youdao: 'http://note.youdao.com/memory/?title=' + this.options.title + '&pic=' + this.options.image + '&summary=' + this.options.des + '&url=' + this.options.url,
            qq: 'http://connect.qq.com/widget/shareqq/index.html?url=' + this.options.url + '&title=' + this.options.title + '&source=' + this.options.source + '&desc=' + this.options.des + '&pics=' + this.options.image + '&summary=' + this.options.summary,
            weibo: 'https://service.weibo.com/share/share.php?url=' + this.options.url + '&title=' + this.options.title + '&pic=' + this.options.image + '&appkey=' + this.options.key,
            daoban: 'http://shuo.douban.com/!service/share?href=' + this.options.url + '&name=' + this.options.title + '&text=' + this.options.des + '&image=' + this.options.image + '&starid=0&aid=0&style=11',
            linkedin: 'http://www.linkedin.com/shareArticle?mini=true&ro=true&title=' + this.options.title + '&url=' + this.options.url + '&summary=' + this.options.summary + '&source=' + this.options.source + '&armin=armin',
            facebook: 'https://www.facebook.com/sharer/sharer.php?u=' + this.options.url,
            twitter: 'https://twitter.com/intent/tweet?text=' + this.options.title + '&url=' + this.options.url + '&via=' + this.options.origin,
            google: 'https://plus.google.com/share?url=' + this.options.url,
            pinterest: 'https://www.pinterest.com/pin/create/button/?url=' + this.options.url + '&description=' + this.options.des + '&media=' + this.options.image,
            tumblr: 'https://www.tumblr.com/widgets/share/tool?shareSource=legacy&canonicalUrl=&url=' + this.options.url + '&title=' + this.options.title,
        }
        for (let k in this.shareUrl) {
            this.changeHref(k);
        }
        if (this.targetDom.querySelector('[share="wechat"]')) {
            if(typeof QRCode == 'undefined'){
                console.error('Please import the QRCode plugin first!');
                return false;
            }else{
                this.createQrcode()
            }
        }
    }
    changeHref(name) {
        let _this = this,
            a = this.targetDom.querySelector('[share=' + name + ']');
        if (a) {
            if (a.hasAttribute('confirm')) {
                a.addEventListener('click', function(e){
                    axPreventDefault(e);
                    new axDialog({
                        content: _this.options.dialogText,
                        footerType: 'right',
                        confirm: {
                            callback: function() {
                                if (_this.options.newPage) {
                                    window.open(_this.shareUrl[name]);
                                    this.hide();
                                } else {
                                    window.location.href = _this.shareUrl[name];
                                }
                                _this.options.onShare && _this.options.onShare.call(_this, name);
                            }
                        }
                    }).show();
                }, false);
            } else {
                if (this.options.newPage) {
                    a.setAttribute('target', '_blank');
                } else {
                    a.removeAttribute('target')
                }
                a.setAttribute('href', this.shareUrl[name]);
                a.addEventListener('click', (e) => {
                    _this.options.onShare && _this.options.onShare.call(_this, name);
                }, false);
            }
        }
    }
    createQrcode() {
        let wechat = this.targetDom.querySelector('[share="wechat"]')
        if (wechat.length === 0) {
            return false;
        }
        let qr = axAddElem('div', { class: 'ax-qrcode' });
        let qrBody = axAddElem('div', { class: 'ax-qrcode-body' });
        let qrTitle = axAddElem('div', { class: 'ax-qrcode-title' }, this.options.qrTitle);
        new QRCode(qrBody, { text: this.options.url, width: this.options.qrSize, height: this.options.qrSize });
        qr.appendChild(qrBody);
        qr.appendChild(qrTitle);
        new axPopup(wechat, {
            content: qr,
            padding: true,
            placement: 'bottom',
            close: false,
            footerShow: false,
        });
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axShare]').forEach(element => {
        new axShare(element);
    });
})();
/*!
* 插件：自动完成插件；使用方法：new axComplete('#id',{参数})
*/
class axComplete {
    constructor(elem, options) {
        this.options = axExtend({
            list: '',
            keys: ['name'],
            threshold: 0.6,
            isCaseSensitive: false,
            hasMatches: true,
            minLength: 1,
            findAll: false,
            template: '',
            className: '',
            break: true,
            tips: 'inside',
            highlight: true,
            rel: '',
            fill: 'name',
            idStart: 1,
        }, options, elem);
        /* data:[{id:1,name:'张三',value:'张三',age:''},
          {id:2,name:'李四',value:'李四',age:''},
          {id:3,name:'王五',value:'王五',age:''},] 
          keys:['name','age']
          */
        this.input = axIdToDom(elem);
        this.handlers = {};
        this.rel = this.options.rel ? axIdToDom(this.options.rel) : '';
        this.outerDom = axAddElem('div', this.options.className ? { class: this.options.className } : { class: 'ax-complete' });
        this.popup = this.createPopup();
        this.popup.content.appendChild(this.outerDom);
        this.innerDom = axAddElem('div', { class: 'ax-complete-list' });
        this.outerDom.appendChild(this.innerDom);
        this.tipsDom = axAddElem('div', { class: 'ax-complete-tips' });
        if (!this.options.tips) {
            this.tipsDom.remove();
        } else if (this.options.tips == 'inline') {
            this.input.insertAdjacentElement('afterend', this.tipsDom);
        } else if (this.options.tips.substr(0, 1) == '#') {
            axIdToDom(this.options.tips).appendChild(this.tipsDom);
        } else {
            this.outerDom.insertAdjacentElement('afterbegin', this.tipsDom);
        }
        this.data = [];
        this.init();
    }
    init() {
        let _this = this;
        this.getData();
        if (axIsEmpty(this.data)) {
            console.error('There is no valid data!')
            return false;
        }
        this.fuseOpt = { includeScore: true };
        this.fuseOpt.threshold = this.options.threshold;
        this.fuseOpt.includeMatches = this.options.hasMatches;
        this.fuseOpt.minMatchCharLength = this.options.minLength;
        this.fuseOpt.findAllMatches = this.options.findAll;
        if (axIsEmpty(this.options.keys)) {
            this.fuseOpt.keys = ['name'];
        } else {
            this.fuseOpt.keys = this.options.keys;
        }
        this.initList();
        this.fuse = new Fuse(this.data, this.fuseOpt);
        this.input.addEventListener('input', function () {
            _this.results = _this.fuse.search(this.value.trim());
            _this.innerDom.innerHTML = _this.renderDom();
            if (_this.options.tips) {
                _this.tipsDom.innerHTML = `共有${_this.results.length}个结果符合要求`
            }
            if (_this.options.highlight) {
                _this.results.forEach((i, index) => {
                    let matchItem = _this.innerDom.querySelectorAll('[role="item"]')[index],
                        matchName = matchItem.querySelector('[role="name"]').innerHTML;
                    i.matches[0].indices.forEach(element => {
                        let separate = matchName.substring(element[0], element[1] + 1),
                            matchArray = matchName.split(separate),
                            newString = matchArray.join('<i class="ax-mark">' + separate + '</i>');
                        matchItem.querySelector('[role="name"]').innerHTML = newString;
                    });
                    matchItem.onclick = function () {
                        if (_this.options.fill && Object.keys(i.item).indexOf(_this.options.fill) > -1) {
                            _this.input.value = i.item[_this.options.fill];
                            'selected' in _this.handlers ? _this.emit('selected', i.item) : null;
                        } else {
                            _this.input.value = i.item.name;
                            'selected' in _this.handlers ? _this.emit('selected', i.item) : null;
                        }
                        _this.popup.hide();
                    }
                });
            }
            if (!this.value) {
                _this.tipsDom.innerHTML = '';
                axDebounce(_this.initList());
            }
        }, false);
    }
    getData() {
        if (typeof this.options.list == 'string') {
            if (this.options.list.substr(0, 1) == '#') {
                this.data = axListToArr(this.options.list, this.options.idStart);
            } else {
                let splitArr = this.options.list.split(','),
                    newArr = [];
                splitArr.forEach((item, index) => {
                    let obj = {};
                    obj.id = this.options.idStart + index;
                    obj.name = item;
                    obj.value = item;
                    newArr.push(obj);
                });
                this.data = newArr;
            }
        } else if (this.options.list instanceof Array) {
            if (typeof this.options.list[0] == 'object') {
                this.options.list.forEach((item, index) => {
                    !item.id ? item.id = this.options.idStart + index : null;
                    !item.value ? item.value = item.name : null;
                });
                this.data = this.options.list;
            } else if (typeof this.options.list[0] == 'string') {
                let newArr = [];
                this.options.list.forEach((item, index) => {
                    let obj = {};
                    obj.id = this.options.idStart + index;
                    obj.name = item;
                    obj.value = item;
                    newArr.push(obj);
                });
                this.data = newArr;
            }
        }
        return this.data;
    }
    createPopup() {
        return new axPopup(this.input, {
            content: this.outerDom,
            trigger: 'input',
            padding: false,
            placement: 'bottom-start',
            close: false,
            footerShow: false,
        });
    }
    renderDom() {
        let template = '';
        if (!axIsEmpty(this.results)) {
            this.results.forEach((elem, index) => {
                template += axTplEngine(this.createTemplate(), elem);
                if (this.options.break && index + 1 < this.results.length) {
                    template += `<div class="ax-break-line"></div>`;
                }
            });
            this.innerDom.innerHTML = template;
        } else {
            this.innerDom.innerHTML = '';
        }
        return this.innerDom.innerHTML;
    }
    initList() {
        let _this = this;
        this.innerDom.innerHTML = this.initDom();
        if (this.options.rel) {
            this.rel.onclick = function () {
                if (!_this.popup.targetDom.classList.contains('ax-show')) {
                    _this.popup.show();
                } else {
                    _this.popup.hide();
                }
            }
        }
        this.innerDom.querySelectorAll('[role="item"]').forEach((item, index) => {
            item.onclick = function () {
                if (_this.options.fill && Object.keys(_this.data[index]).indexOf(_this.options.fill) > -1) {
                    _this.input.value = _this.data[index][_this.options.fill];
                } else {
                    _this.input.value = _this.data[index].name;
                }
                _this.popup.hide();
            }
        });
    }
    initDom() {
        let initData = [];
        this.data.forEach(i => {
            let newItem = {};
            newItem.item = i;
            initData.push(newItem);
        });
        let template = '';
        if (!axIsEmpty(this.data)) {
            initData.forEach((elem, index) => {
                template += axTplEngine(this.createTemplate(), elem);
                if (this.options.break && index + 1 < initData.length) {
                    template += `<div class="ax-break-line"></div>`;
                }
            });
            this.innerDom.innerHTML = template;
        } else {
            this.innerDom.innerHTML = '';
        }
        return this.innerDom.innerHTML;
    }
    createTemplate() {
        if (this.options.template) {
            return this.options.template;
        } else {
            return `<a href="###" class="ax-info-block ax-hover" role="item">
                <div class="ax-row">
                  <div class="ax-col"><span class="ax-ell" role="name"><# this.item.name #></span></div>
                </div>
              </a>
      `;
        }
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
document.querySelectorAll('[axComplete]').forEach(element => {
    new axComplete(element);
});
/*!
 * jeDate v6.5.0 from https://github.com/singod/jeDate | AXUI做了深度修改
 */
const axDate = (() => {
    var jet = {}, regymdzz = "YYYY|MM|DD|hh|mm|ss|zz";
    var $Q = function (selector, content) {
        content = content || document;
        return selector.nodeType ? selector : content.querySelector(selector);
    };
    var jeDate = function (elem, options) {
        var opts = typeof (options) === "function" ? options() : options;
        return new jeDatePick(elem, opts);
    };
    jeDate.extend = jet.extend = function () {
        var options, name, src, copy, deep = false, target = arguments[0], i = 1, length = arguments.length;
        if (typeof (target) === "boolean") deep = target, target = arguments[1] || {}, i = 2;
        if (typeof (target) !== "object" && typeof (target) !== "function") target = {};
        if (length === i) target = this, --i;
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name], copy = options[name];
                    if (target === copy) continue;
                    if (copy !== undefined) target[name] = copy;
                }
            }
        }
        return target;
    };
    jeDate.nowDate = function (val, format) {
        format = format || 'YYYY-MM-DD hh:mm:ss';
        if (!isNaN(val)) val = { DD: val };
        return jet.parse(jet.getDateTime(val), format);
    };
    jeDate.convert = function (obj) {
        obj.format = obj.format || 'YYYY-MM-DD hh:mm:ss';
        obj.addval = obj.addval || [];
        var mats = jet.reMatch(obj.format), objVal = {};
        jet.each(jet.reMatch(obj.val), function (i, cval) {
            objVal[mats[i]] = parseInt(cval);
        });
        var result = new DateTime(obj.addval, objVal), redate = {
            YYYY: result.GetYear(), MM: result.GetMonth(), DD: result.GetDate(),
            hh: result.GetHours(), mm: result.GetMinutes(), ss: result.GetSeconds()
        };
        return redate;
    };
    jeDate.valText = function (elem, value) {
        return jet.valText(elem, value);
    }
    jeDate.timeStampDate = function (date, format) {
        format = format || 'YYYY-MM-DD hh:mm:ss';
        var dateTest = (/^(-)?\d{1,10}$/.test(date) || /^(-)?\d{1,13}$/.test(date));
        if (/^[1-9]*[1-9][0-9]*$/.test(date) && dateTest) {
            var vdate = parseInt(date);
            if (/^(-)?\d{1,10}$/.test(vdate)) {
                vdate = vdate * 1000;
            } else if (/^(-)?\d{1,13}$/.test(vdate)) {
                vdate = vdate * 1000;
            } else if (/^(-)?\d{1,14}$/.test(vdate)) {
                vdate = vdate * 100;
            } else {
                alert("时间戳格式不正确");
                return;
            }
            var setdate = new Date(vdate);
            return jet.parse({
                YYYY: setdate.getFullYear(), MM: jet.digit(setdate.getMonth() + 1), DD: jet.digit(setdate.getDate()),
                hh: jet.digit(setdate.getHours()), mm: jet.digit(setdate.getMinutes()), ss: jet.digit(setdate.getSeconds())
            }, format);
        } else {
            var arrs = jet.reMatch(date),
                newdate = new Date(arrs[0], arrs[1] - 1, arrs[2], arrs[3] || 0, arrs[4] || 0, arrs[5] || 0),
                timeStr = Math.round(newdate.getTime() / 1000);
            return timeStr;
        }
    };
    jeDate.getLunar = function (obj) {
        var lunars = jeLunar(obj.YYYY, parseInt(obj.MM) - 1, obj.DD);
        return {
            nM: lunars.lnongMonth,              
            nD: lunars.lnongDate,               
            cY: parseInt(lunars.solarYear),     
            cM: parseInt(lunars.solarMonth),    
            cD: parseInt(lunars.solarDate),     
            cW: lunars.inWeekDays,              
            nW: lunars.solarWeekDay             
        };
    };
    jeDate.parse = jet.parse = function (ymdhms, format) {
        return format.replace(new RegExp(regymdzz, "g"), function (str, index) {
            return str == "zz" ? "00" : jet.digit(ymdhms[str]);
        });
    }
    function DateTime(arr, valObj) {
        var that = this, newdate = new Date(), narr = ["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds"];
        var vb = jet.extend({ YYYY: null, MM: null, DD: null, hh: newdate.getHours(), mm: newdate.getMinutes(), ss: newdate.getSeconds() }, valObj);
        var ND = valObj == undefined ? newdate : new Date(vb.YYYY, vb.MM, vb.DD, vb.hh, vb.mm, vb.ss);
        if ((arr || []).length > 0) jet.each(arr, function (i, par) {
            ND["set" + narr[i]](narr[i] == "Month" ? parseInt(par) - 1 : parseInt(par));
        });
        that.reDate = function () {
            return new DateTime();
        };
        that.GetValue = function () {
            return ND;
        };
        that.GetYear = function () {
            return ND.getFullYear();
        };
        that.GetMonth = function () {
            return ND.getMonth() + 1;
        };
        that.GetDate = function () {
            return ND.getDate();
        };
        that.GetHours = function () {
            return ND.getHours();
        };
        that.GetMinutes = function () {
            return ND.getMinutes();
        };
        that.GetSeconds = function () {
            return ND.getSeconds();
        };
    };
    jet.extend(jet, {
        isType: function (obj, type) {
            var firstUper = function (str) {
                str = str.toLowerCase();
                return str.replace(/\b(\w)|\s(\w)/g, function (m) {
                    return m.toUpperCase();
                });
            }
            return Object.prototype.toString.call(obj) == "[object " + firstUper(type) + "]";
        },
        each: function (obj, callback, args) {
            var name, i = 0, length = obj.length, iselem = (length === undefined || obj === "function");
            if (iselem) {
                for (name in obj) { if (callback.call(obj[name], name, obj[name]) === false) { break } }
            } else {
                for (; i < length;) { if (callback.call(obj[i], i, obj[i++]) === false) { break } }
            }
            return obj;
        },
        on: function (elm, type, fn) {
            if (elm.addEventListener) {
                elm.addEventListener(type, fn, false);
                return true;
            } else if (elm.attachEvent) {
                return elm.attachEvent("on" + type, fn);
            } else {
                elm["on" + type] = fn;
            }
        },
        isObj: function (obj) {
            for (var i in obj) { return true; }
            return false;
        },
        trim: function (str) { return str.replace(/(^\s*)|(\s*$)/g, ""); },
        reMatch: function (str) {
            var smarr = [], maStr = "", parti = /(^\w{4}|\w{2}\B)/g;
            if (jet.isNum(str)) {
                maStr = str.replace(parti, "$1-");
            } else {
                maStr = /^[A-Za-z]+$/.test(str) ? str.replace(parti, "$1-") : str;
            }
            jet.each(maStr.match(/\w+|d+/g), function (i, val) {
                smarr.push(jet.isNum(val) ? parseInt(val) : val);
            });
            return smarr;
        },
        equals: function (arrA, arrB) {
            if (!arrB) return false;
            if (arrA.length != arrB.length) return false;
            for (var i = 0, l = arrA.length; i < l; i++) {
                if (arrA[i] instanceof Array && arrB[i] instanceof Array) {
                    if (!arrA[i].equals(arrB[i])) return false;
                } else if (arrA[i] != arrB[i]) {
                    return false;
                }
            }
            return true;
        },
        docScroll: function (type) {
            type = type ? "scrollLeft" : "scrollTop";
            return document.body[type] | document.documentElement[type];
        },
        docArea: function (type) {
            return document.documentElement[type ? "clientWidth" : "clientHeight"];
        },
        digit: function (num) {
            return num < 10 ? "0" + (num | 0) : num;
        },
        isNum: function (value) {
            return /^[+-]?\d*\.?\d*$/.test(value) ? true : false;
        },
        getDaysNum: function (y, m) {
            var num = 31, isLeap = (y % 100 !== 0 && y % 4 === 0) || (y % 400 === 0);
            switch (parseInt(m)) {
                case 2: num = isLeap ? 29 : 28; break;
                case 4: case 6: case 9: case 11: num = 30; break;
            }
            return num;
        },
        getYM: function (y, m, n) {
            var nd = new Date(y, m - 1);
            nd.setMonth(m - 1 + n);
            return {
                y: nd.getFullYear(),
                m: nd.getMonth() + 1
            };
        },
        prevMonth: function (y, m, n) {
            return jet.getYM(y, m, 0 - (n || 1));
        },
        nextMonth: function (y, m, n) {
            return jet.getYM(y, m, n || 1);
        },
        setCss: function (elem, obj) {
            for (var x in obj) elem.style[x] = obj[x];
        },
        html: function (elem, html) {
            return typeof html === "undefined" ? elem && elem.nodeType === 1 ? elem.innerHTML : undefined : typeof html !== "undefined" && html == true ? elem && elem.nodeType === 1 ? elem.outerHTML : undefined : elem.innerHTML = html;
        },
        text: function (elem, value) {
            var innText = document.all ? "innerText" : "textContent";
            return typeof value === "undefined" ? elem && elem.nodeType === 1 ? elem[innText] : undefined : elem[innText] = value;
        },
        val: function (elem, value) {
            if (typeof value === "undefined") {
                return elem && elem.nodeType === 1 && typeof elem.value !== "undefined" ? elem.value : undefined;
            }
            value = value == null ? "" : value + "";
            elem.value = value;
        },
        attr: function (elem, value) {
            return elem.getAttribute(value);
        },
        hasClass: function (obj, cls) {
            return obj.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
        },
        stopPropagation: function (ev) {
            (ev && ev.stopPropagation) ? ev.stopPropagation() : window.event.cancelBubble = true;
        },
        template: function (str, data) {
            var strCell = !/[^\w\-\.:]/.test(str) ? document.getElementById(str).innerHTML : str;
            var keys = function (obj) {
                var arr = [];
                for (arr[arr.length] in obj);
                return arr;
            }, dataVar = function (obj) {
                var vars = '';
                for (var key in obj) {
                    vars += 'var ' + key + '= $D["' + key + '"];';
                }
                return vars;
            }, compile = function (source, data) {
                var code = "var $out='" + source.replace(/[\r\n]/g, '').replace(/^(.+?)\{\%|\%\}(.+?)\{\%|\%\}(.+?)$/g, function (val) {
                    return val.replace(/(['"])/g, '\\\$1');
                }).replace(/\{\%\s*=\s*(.+?)\%\}/g, "';$out+=$1;$out+='").replace(/\{\%(.+?)\%\}/g, "';$1;$out+='") + "';return new String($out);";
                var vars = dataVar(data), Render = new Function('$D', vars + code);
                return new Render(data) + '';
            };
            return compile(strCell, data);
        },
        isValDiv: function (elem) {
            return /textarea|input/.test(elem.tagName.toLocaleLowerCase());
        },
        valText: function (elem, value) {
            var cell = $Q(elem), type = jet.isValDiv(cell) ? "val" : "text";
            if (value != undefined) {
                jet[type](cell, value);
            } else {
                return jet[type](cell);
            }
        },
        isBool: function (obj) { return (obj == undefined || obj == true ? true : false); },
        getDateTime: function (obj) {
            var result = new DateTime(), objVal = jet.extend({ YYYY: null, MM: null, DD: null, hh: 0, mm: 0, ss: 0 }, obj),
                matArr = { YYYY: "FullYear", MM: "Month", DD: "Date", hh: "Hours", mm: "Minutes", ss: "Seconds" };
            jet.each(["ss", "mm", "hh", "DD", "MM", "YYYY"], function (i, mat) {
                if (!jet.isNum(parseInt(objVal[mat]))) return null;
                var reVal = result.GetValue();
                if (parseInt(objVal[mat]) || parseInt(objVal[mat]) == 0) {
                    reVal["set" + matArr[mat]](result["Get" + matArr[mat]]() + (mat == "MM" ? -1 : 0) + parseInt(objVal[mat]));
                }
            });
            var redate = {
                YYYY: result.GetYear(), MM: result.GetMonth(), DD: result.GetDate(),
                hh: result.GetHours(), mm: result.GetMinutes(), ss: result.GetSeconds()
            };
            return redate;
        }
    });
    function jeDatePick(elem, options) {
        /* var config = {
            language: {
                name: "cn",
                month: ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"],
                weeks: ["日", "一", "二", "三", "四", "五", "六"],
                times: ["小时", "分钟", "秒数"],
                timetxt: ["时间选择", "开始时间", "结束时间"],
                backtxt: "返回日期",
                clear: "清空",
                today: "现在",
                yes: "确定"
            },
            format: "YYYY-MM-DD hh:mm:ss",               
            minDate: "1900-01-01 00:00:00",              
            maxDate: "2099-12-31 23:59:59",              
            isShow: true,                                
            multiPane: true,                             
            onClose: true,                               
            range: false,                                
            trigger: "click",                            
            position: [],                                
            valiDate: [],                                
            isinitVal: false,                            
            initDate: {},                                
            isTime: true,                                
            isClear: true,                               
            isToday: true,                               
            isYes: true,                                 
            festival: false,                             
            fixed: true,                                 
            zIndex: 2099,                                
            method: {},                                 
            theme: {},                                   
            shortcut: [],                                
            donefun: null,                                
            before: null,                                
            succeed: null                                
        }; */
        var config = axExtend({
            language: {
                name: "cn",
                month: ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"],
                weeks: ["日", "一", "二", "三", "四", "五", "六"],
                times: ["小时", "分钟", "秒数"],
                timetxt: ["时间选择", "开始时间", "结束时间"],
                backtxt: "返回日期",
                clear: "清空",
                close: "关闭",
                today: "现在",
                yes: "确定"
            },
            format: "YYYY-MM-DD hh:mm:ss",               
            minDate: "1900-01-01 00:00:00",              
            maxDate: "2099-12-31 23:59:59",              
            mode: 'popup',                                
            isShow: true,                                
            multiPane: true,                             
            onClose: true,                               
            range: false,                                
            trigger: "click",                            
            position: [],                                
            valiDate: [],                                
            isinitVal: false,                            
            initDate: {},                                
            rel: '',
            isTime: true,                                
            isClear: false,                               
            clearFun: function () { },                       
            isClose: true,                               
            closeFun: function () { },                       
            isToday: true,                               
            isYes: true,                                 
            festival: false,                             
            fixed: true,                                 
            zIndex: 2099,                                
            nowClose: false,                               
            method: {},                                 
            theme: {},                                   
            shortcut: [],                                
            donefun: null,                                
            before: null,                                
            succeed: null                                
        }, options, elem);
        this.$opts = jet.extend(config, options || {});
        this.valCell = $Q(elem);
        this.format = this.$opts.format;
        this.valCell != null ? this.init() : alert(elem + "  ID\u6216\u7C7B\u540D\u4E0D\u5B58\u5728!");
        jet.extend(this, this.$opts.method);
        delete this.$opts.method;
    }
    var searandom = function () {
        var str = "", arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
        for (var i = 0; i < 8; i++) str += arr[Math.round(Math.random() * (arr.length - 1))];
        return str;
    };
    var ymdzArr = jet.reMatch(regymdzz), elx = "#ax-date";
    jet.extend(jeDatePick.prototype, {
        init: function () {
            var that = this, opts = that.$opts,
                trigges = opts.trigger, ndate = opts.initDate || [], inVal, range = opts.range,
                isShow = jet.isBool(opts.isShow),
                isinitVal = (opts.isinitVal == undefined || opts.isinitVal == false) ? false : true;
            that.shortIndex = ''
            that.shortMenu = axAddElem('div', { class: 'ax-date-menu' });
            that.setDatas();
            opts.before && opts.before(that.valCell);
            if (isinitVal && trigges && isShow) {
                if (ndate[1]) {
                    var addval = jet.getDateTime(ndate[0]);
                    inVal = [{
                        YYYY: addval.YYYY, MM: jet.digit(addval.MM), DD: jet.digit(addval.DD),
                        hh: jet.digit(addval.hh), mm: jet.digit(addval.mm), ss: jet.digit(addval.ss)
                    }];
                } else {
                    inVal = that.getValue(jet.isObj(ndate[0]) ? ndate[0] : {});
                }
                if (!range) that.setValue([inVal[0]], opts.format, true);
            }
            var getCurrValue = function () {
                var mats = jet.reMatch(that.format), isEmpty = that.getValue() != "", curVal = [],
                    parmat = that.dlen == 7 ? "hh:mm:ss" : "YYYY-MM" + (that.dlen <= 2 ? "" : "-DD");
                var result = that.valCell.value;
                if (!result) {
                    that.selectValue = [jet.parse(jet.getDateTime({}), parmat)];
                } else {
                    result = result.substr(0, 11);
                    var nowTime = [jet.parse(jet.getDateTime({}), parmat)];
                    nowTime = nowTime[0];
                    var time1 = new Date(result).setHours('0');
                    var time2 = new Date(nowTime).setHours('0');
                    var nDays = (parseInt((time1 - time2) / 1000 / 3600 / 24));
                    var redate = {
                        DD: nDays
                    };
                    that.selectValue = [jet.parse(jet.getDateTime(redate), parmat)];
                }
                if (isEmpty && isShow) {
                    var getVal = that.getValue().split(range);
                    jet.each(new Array(range ? 2 : 1), function (a) {
                        curVal[a] = {};
                        jet.each(jet.reMatch(getVal[a]), function (i, val) {
                            curVal[a][mats[i]] = parseInt(val);
                        });
                    });
                    if (range) that.selectValue = getVal;
                } else {
                    var parr = that.getValue({})[0], nmVal = jet.nextMonth(parr.YYYY, parr.MM || jet.getDateTime({}).MM),
                        narr = (that.dlen > 2 && that.dlen <= 6) ? { YYYY: nmVal.y, MM: nmVal.m } : {};
                    curVal = [parr];
                }
                that.selectDate = curVal;
                return curVal;
            }, ymarr = [];
            that.minDate = ""; that.maxDate = "";
            if (!isShow || !trigges) ymarr = getCurrValue();
            if (!isShow || !trigges) {
                that.minDate = jet.isType(opts.minDate, "function") ? opts.minDate(that) : opts.minDate;
                that.maxDate = jet.isType(opts.maxDate, "function") ? opts.maxDate(that) : opts.maxDate;
                that.storeData(ymarr[0], ymarr[1]);
                that.renderDate();
                opts.succeed && opts.succeed(that.dateCell);
            } else {
                if (trigges) {
                    if (document.querySelectorAll(elx).length > 0) return;
                    var gvarr = getCurrValue();
                    that.minDate = jet.isType(opts.minDate, "function") ? opts.minDate(that) : opts.minDate;
                    that.maxDate = jet.isType(opts.maxDate, "function") ? opts.maxDate(that) : opts.maxDate;
                    that.storeData(gvarr[0], gvarr[1]);
                    that.renderDate();
                    if (opts.mode == 'inline') {
                        that.valCell.insertAdjacentElement('afterend', that.dateCell);
                        that.valCell.setAttribute('readonly', '');
                    } else if (opts.mode == 'dialog') {
                        that.dialog = new axDialog({
                            size: '',
                            padding: false,
                            footerShow: false,
                            content: that.dateCell,
                        });
                        that.valCell.addEventListener('click', function () {
                            that.dialog.show();
                        }, false);
                    } else {
                        that.popup = new axPopup(that.valCell, {
                            size: '',
                            padding: false,
                            rel: opts.rel,
                            placement: 'bottom-start',
                            close: false,
                            footerShow: false,
                            content: that.dateCell,
                        });
                    }
                    /* jet.on(that.valCell, trigges, function () {
                    }); */
                }
            }
        },
        setDatas: function () {
            var that = this, opts = that.$opts, range = opts.range, shortArr = [], isShow = jet.isBool(opts.isShow), multi = opts.multiPane;
            that.$data = jet.extend({ year: false, month: false, day: true, time: false, timebtn: false }, {
                shortcut: [], lang: opts.language, yaerlist: [], monthlist: [[], []], ymlist: [[], []], daylist: [[], []],
                clear: opts.isClear, close: opts.isClose, today: range ? false : opts.isToday, yes: opts.isYes, pane: multi ? 1 : 2
            });
            if (opts.shortcut.length > 0) {
                jet.each(opts.shortcut, function (i, short) {
                    var tarr = [], shval = jet.isType(short.val, "function") ? short.val() : short.val;
                    if (jet.isType(shval, "object")) {
                        for (var s in shval) tarr.push(s + ':' + shval[s]);
                        shortArr.push(jet.extend({}, { name: short.name, val: "{" + tarr.join('#') + "}" }));
                    }
                });
                that.$data.shortcut = shortArr;
            }
            that.dlen = (function () {
                var mats = jet.reMatch(that.format), marr = [];
                jet.each(ymdzArr, function (i, val) {
                    jet.each(mats, function (m, mval) {
                        if (val == mval) marr.push(mval);
                    });
                });
                var matlen = marr.length, lens = (marr[0] == "hh") && matlen <= 3 ? 7 : matlen;
                return lens;
            })();
            that.$data.dlen = that.dlen;
            that.timeInspect = false;
            if (that.dlen == 1) {
                jet.extend(that.$data, { year: true, day: false });
            } else if (that.dlen == 2) {
                jet.extend(that.$data, { month: true, day: false });
            } else if (that.dlen > 3 && that.dlen <= 6) {
                that.$data.timebtn = true;
            } else if (that.dlen == 7) {
                jet.extend(that.$data, { day: false, time: true });
            }
            if (!isShow) {
                that.$data.clear = false;
                that.$data.yes = false;
            }
        },
        renderDate: function () {
            var that = this, opts = that.$opts, isShow = jet.isBool(opts.isShow),
                elxID = elx + searandom(); 
            if (that.dateCell == undefined) {
                that.dateCell = document.createElement("div");
                that.dateCell.id = elxID.replace(/\#/g, "");
                that.dateCell.className = elx.replace(/\#/g, "") + " " + (opts.festival ? " ax-with-calendar" : "");
                that.wrapper = axAddElem('div', { class: 'ax-date-wrapper' });
                that.dateCell.appendChild(that.wrapper);
            }
            jet.html(that.wrapper, jet.template(that.dateTemplate(), that.$data));
            if (jet.isObj(opts.theme)) {
                var styleDiv = document.createElement("style"), stCell = ".ax-date" + searandom(), t = opts.theme,
                    BG = "background-color:" + t.bgcolor, WC = "color:" + (t.color == undefined ? "#FFFFFF" : t.color),
                    OTH = (t.pnColor == undefined ? "" : "color:" + t.pnColor + ";");
                that.dateCell.className = that.dateCell.className + " " + stCell.replace(/^./g, ""); styleDiv.setAttribute("type", "text/css");
                styleDiv.innerHTML = stCell + " .ax-date-menu p:hover{" + BG + ";" + WC + ";}" + stCell + " .ax-date-header em{" + WC + ";}" +
                    stCell + " .ax-date-body .ytable td.ax-selected span," + stCell + " .ax-date-body .ax-mtable td.ax-selected span," +
                    stCell + " .ax-date-body .ytable td.ax-selected span:hover," + stCell + " .ax-date-body .ax-mtable td.ax-selected span:hover{" + BG + ";border:1px " + t.bgcolor + " solid;" + WC + ";}" + stCell + " .ax-date-body .ax-dtable td.ax-selected," + stCell + " .ax-date-body .ax-dtable td.ax-selected:hover," +
                    stCell + " .ax-date-body .ax-dtable td.ax-selected .lunar," + stCell + " .ax-date-header," + stCell + " .ax-date-time .ax-date-header," +
                    stCell + " .ax-date-time .ax-time-list ul li.ax-selected," + stCell + " .ax-date-time .ax-time-list ul li.ax-selected:hover," +
                    stCell + " .ax-date-time .ax-time-list ul li.ax-disabled.ax-selected," + stCell + " .ax-date-footbtn .timecon," + stCell + " .ax-date-footbtn .btnscon span{" + BG + ";" + WC + ";}" +
                    stCell + " .ax-date-body .ax-dtable td.ax-other," + stCell + " .ax-date-body .ax-dtable td.ax-other .ax-unit," + stCell + " .ax-date-body .ax-dtable td.ax-other .lunar{" + OTH + "}" + stCell + " .ax-date-body .ax-dtable td.contain," + stCell + " .ax-date-body .ax-dtable td.contain:hover{background-" + OTH + "}";
                that.dateCell.appendChild(styleDiv);
            }
            that.compileBindNode(that.dateCell);
            if (document.querySelectorAll(elxID).length > 0) document.body.removeChild($Q(elxID));
            !isShow ? that.valCell.appendChild(that.dateCell) : null;
            that.methodEventBind();
            if (that.dlen == 7 || (that.dlen > 3 && that.dlen <= 6)) that.locateScroll();
            if (opts.festival && opts.language.name == "cn") {
                that.showFestival();
            }
            if (isShow) {
                that.dateOrien(that.dateCell, that.valCell);
                that.blankArea();
            }
            if (opts.shortcut.length > 0) {
                that.shortMenu.innerHTML = '';
                for (var s = 0; s < opts.shortcut.length; s++) {
                    that.shortMenu.innerHTML += '<a href="###">' + opts.shortcut[s].name + '</a>';
                }
                that.wrapper.insertAdjacentElement('afterbegin', that.shortMenu);
                that.shortMenu.querySelectorAll('a').forEach((item, index) => {
                    item.onclick = function () {
                        that.shortIndex = index;
                        that.shortClick(JSON.stringify(opts.shortcut[index].val));
                    }
                });
                that.shortIndex !== '' ? that.shortMenu.querySelectorAll('a')[that.shortIndex].classList.add('ax-selected') : null;
            }
        },
        setValue: function (fnStr, matStr, bool) {
            var that = this, valCell = that.valCell, strVal;
            matStr = matStr || that.format;
            if ((typeof fnStr == 'string') && fnStr != '') {
                var sprange = fnStr.split(that.$opts.range), inArr = [];
                jet.each(sprange, function (i, sval) {
                    var reVal = jet.reMatch(sval), inObj = {};
                    jet.each(jet.reMatch(matStr), function (r, val) {
                        inObj[val] = reVal[r];
                    });
                    inArr.push(inObj);
                });
                strVal = inArr;
            } else {
                strVal = fnStr;
            }
            var vals = that.parseValue(strVal, matStr);
            if (bool != false) jet.valText(valCell, vals);
            return vals;
        },
        getValue: function (valobj) {
            var that = this, valCell = that.valCell,
                opts = that.$opts, reObj, result = new DateTime().reDate(),
                dateY = result.GetYear(), dateM = result.GetMonth(), dateD = result.GetDate(),
                timeh = result.GetHours(), timem = result.GetMinutes(), times = result.GetSeconds();
            if (valobj == undefined && jet.isBool(opts.isShow)) {
                reObj = jet.valText(valCell);
            } else {
                var isValShow = jet.isBool(opts.isShow) ? (jet.valText(valCell) == "") : !jet.isBool(opts.isShow),
                    objarr = jet.extend({ YYYY: null, MM: null, DD: null }, valobj || {}),
                    ranMat = [], newArr = new Array(2), unObj = function (obj) {
                        return [(objarr[obj] == undefined || objarr[obj] == null), objarr[obj]];
                    }, defObj = [{ YYYY: dateY, MM: dateM, DD: dateD, hh: timeh, mm: timem, ss: times, zz: '' },
                    { YYYY: dateY, MM: dateM, DD: dateD, hh: timeh, mm: timem, ss: times, zz: '' }];
                if (isValShow) {
                    jet.each(newArr, function (i) {
                        var inObj = {};
                        jet.each(ymdzArr, function (r, val) {
                            inObj[val] = parseInt(unObj(val)[0] ? defObj[i][val] : unObj(val)[1]);
                        });
                        ranMat.push(jet.extend(defObj[i], inObj));
                    });
                } else {
                    var isunRange = opts.range != false, initVal = that.getValue(),
                        spVal = initVal.split(opts.range), reMat = jet.reMatch(that.format);
                    jet.each(newArr, function (i) {
                        var inObj = {}, reVal = isunRange ? jet.reMatch(spVal[i]) : jet.reMatch(initVal);
                        jet.each(reMat, function (r, val) {
                            inObj[val] = reVal[r];
                        });
                        var exVal = jet.extend(inObj, valobj || {});
                        ranMat.push(jet.extend(defObj[i], exVal));
                    });
                }
                reObj = ranMat;
            }
            return reObj;
        },
        storeData: function (curr, next) {
            next = next || {};
            var that = this, opts = that.$opts, multi = opts.multiPane, valCell = that.valCell,
                days = new Date().getDate(), isnext = jet.isObj(next),
                RES = { yearlist: [], monthlist: [[], []], daylist: [], daytit: [], timelist: [] }, seltime,
                cday = curr.DD == null ? days : curr.DD, nday = next.DD == null ? days : next.DD,
                timeA = { hh: curr.hh, mm: curr.mm, ss: curr.ss }, timeB = { hh: next.hh || 0, mm: next.mm || 0, ss: next.ss || 0 };
            RES.yearlist.push(that.eachYear(parseInt(curr.YYYY), 1));
            if (multi == false) {
                var yearNext = isnext ? next.YYYY : curr.YYYY;
                RES.yearlist.push(that.eachYear(parseInt(yearNext), 2));
            }
            RES.monthlist[0] = that.eachMonth(curr.YYYY, 0);
            if (multi == false) {
                RES.monthlist[1] = that.eachMonth(curr.YYYY + 1, 1);
            }
            RES.daylist.push(that.eachDays(curr.YYYY, curr.MM, cday, 0));
            RES.daytit.push({ YYYY: curr.YYYY, MM: curr.MM });
            if (multi == false) {
                var dayNext = jet.nextMonth(curr.YYYY, curr.MM);
                RES.daylist.push(that.eachDays(dayNext.y, dayNext.m, nday, 1));
                RES.daytit.push({ YYYY: dayNext.y, MM: dayNext.m });
            }
            that.selectTime = [timeA, timeB];
            RES.timelist.push(that.eachTime(timeA, 1));
            if (multi == false) {
                seltime = that.dlen == 7 && opts.range && !isnext ? timeA : timeB;
                if (that.dlen == 7 && opts.range && jet.valText(valCell) == "") {
                    that.selectTime[1] = jet.extend(timeB, timeA);
                }
                RES.timelist.push(that.eachTime(seltime, 2));
            }
            jet.extend(that.$data, RES);
        },
        dateTemplate: function () {
            var that = this, opts = that.$opts, multi = opts.multiPane, YMDStr = "", hmsStr = "", lang = opts.language,
                ytxt = lang.name == "cn" ? "年" : "", mtxt = lang.name == "cn" ? "月" : "";
            var aowArr = (function () {
                var butArr = [], ismu = multi ? "11" : "23";
                if (that.dlen == 1) {
                    butArr = ['{%=yearlist[i][0].y-' + ismu + '%}', '{%=yearlist[i][yearlist[i].length-1].y%}'];
                } else if (that.dlen == 2) {
                    butArr = multi ? ['{%=yearlist[0][0].y-1%}', '{%=yearlist[0][0].y+1%}'] : ['{%=yearlist[i][0].y-' + ismu + '%}', '{%=yearlist[i][yearlist[i].length-1].y%}'];
                } else if (that.dlen > 2 && that.dlen <= 6) {
                    butArr = ['{%=yearlist[0][0].y-1%}', '{%=yearlist[0][0].y+1%}'];
                }
                return butArr;
            })();
            var lyPrev = '<a href="###" class="ax-yprev ax-iconfont ax-icon-left-double" @on="yearBtn(lprev,' + aowArr[0] + ')"></a>',
                ryNext = '<a href="###" class="ax-ynext ax-iconfont ax-icon-right-double" @on="yearBtn(rnext,' + aowArr[1] + ')"></a>',
                mPrev = '{% if(dlen>2){ %}<a href="###" class="ax-mprev ax-iconfont ax-icon-left" @on="monthBtn(mprev,{%=daytit[i].YYYY%}-{%=daytit[i].MM%})"></a>{% } %}',
                mNext = '{% if(dlen>2){ %}<a href="###" class="ax-mnext ax-iconfont ax-icon-right" @on="monthBtn(mnext,{%=daytit[i].YYYY%}-{%=daytit[i].MM%})"></a>{% } %}';
            var yaerHtml = '<table class="ax-ytable year{%= i==0 ? "left":"right"%}" style="display:{%=year ? "table":"none"%};"><tbody><tr>' +
                '{% for(var y=0;y<=11;y++){ %}<td class="{%=yearlist[i][y].style%}" @on="yearClick({%=yearlist[i][y].y%})"><span>{%=yearlist[i][y].y%}' + ytxt + '</span></td>{% if((y+1)%3==0){ %} </tr>{% } %} {% } %} </tbody></table>';
            var monthHtml = '<table class="ax-mtable month{%= i==0 ? "left":"right"%}" style="display:{%=month ? "table":"none"%};"><tbody><tr>' +
                '{% for(var m=0;m<=11;m++){ %}<td class="{%=monthlist[i][m].style%}" ym="{%=monthlist[i][m].y%}-{%=monthlist[i][m].m%}" @on="monthClick({%=monthlist[i][m].y%}-{%=monthlist[i][m].m%})"><span>{%=monthlist[i][m].m%}' + mtxt + '</span></td>{% if((m+1)%3==0){ %} </tr>{% } %} {% } %} </tbody></table>';
            var daysHtml = '<table class="ax-dtable days{%= i==0 ? "left":"right"%}" style="display:{%=day ? "table":"none"%};"><thead><tr>' +
                '{% for(var w=0;w<lang.weeks.length;w++){ %} <th><i>{%=lang.weeks[w]%}</i></th> {% } %}</tr></thead><tbody>' +
                '<tr>{% for(var d=0;d<=41;d++){ %}<td class="{%=daylist[i][d].style%}" ymd="{%=daylist[i][d].ymd%}" @on="daysClick({%=daylist[i][d].ymd%})">{%=daylist[i][d].day%}</td>{% if((d+1)%7==0){ %} </tr>{% } %} {% } %} </tbody></table>';
            var hmsHtml = '<div class="ax-date-time">{% for(var h=0;h<timelist.length;h++){ %}<div class="ax-date-panel"><div class="ax-date-header">{%= timelist.length == 1 ? lang.timetxt[0]:lang.timetxt[h+1]%}</div><div class="ax-date-body">' +
                '<div class="ax-time-title"><div class="ax-time-item">{%=lang.times[0]%}</div><div class="ax-time-item">{%=lang.times[1]%}</div><div class="ax-time-item">{%=lang.times[2]%}</div></div>' +
                '<div class="ax-time-list">{% for(var t=0;t<3;t++){ %}<div class="ax-time-item"><ul>{% for(var s=0;s<timelist[h][t].length;s++){ %}<li class="{%=timelist[h][t][s].style%}" @on="hmsClick({%= h %},{%= h>0?3+t:t %})"><span>{%= timelist[h][t][s].hms < 10 ? "0" + timelist[h][t][s].hms :timelist[h][t][s].hms %}</span></li>{% } %}</ul></div>{% } %}</div></div>' + '</div>{% } %}</div>';
            var shortHtml = opts.shortcut.length > 0 ? "{% for(var s=0;s<shortcut.length;s++){ %}<a href='###' @on=shortClick({%= shortcut[s].val %})>{%=shortcut[s].name%}</a>{% } %}" : '';
            var ymtitHtml = (function () {
                var ymtitStr = "";
                if (that.dlen == 1) {
                    ymtitStr = '<a href="###" class="ax-ym">{%=yearlist[i][0].y%}' + ytxt + ' ~ {%=yearlist[i][yearlist[i].length-1].y%}' + ytxt + '</a>';
                } else if (that.dlen == 2) {
                    ymtitStr = '<a href="###" class="ax-ym" @on="yearShow({%=yearlist[0][i].y%})">{%=yearlist[0][i].y%}' + ytxt + '</a>';
                } else if (that.dlen > 2 && that.dlen <= 6) {
                    ymtitStr = '<a href="###" class="ax-ym" @on="monthShow({%=daytit[i].MM%})">{%=daytit[i].MM%}' + mtxt + '</a>' +
                        '<a href="###" class="ax-ym" @on="yearShow({%=daytit[i].YYYY%})">{%=daytit[i].YYYY%}' + ytxt + '</a>';
                }
                return ymtitStr;
            })();
            var ymButton = (function () {
                var titStrBut = "";
                if (that.dlen == 1) {
                    titStrBut = multi ? [lyPrev + ryNext] : [lyPrev, ryNext];
                } else if (that.dlen == 2) {
                    titStrBut = multi ? [lyPrev + ryNext] : [lyPrev, ryNext];
                } else if (that.dlen > 2 && that.dlen <= 6) {
                    titStrBut = multi ? [lyPrev + mPrev + mNext + ryNext] : [lyPrev + mPrev, mNext + ryNext];
                } else if (that.dlen == 7) {
                    titStrBut = "";
                }
                return titStrBut;
            })();
            if (that.dlen == 1) {
                YMDStr = yaerHtml;
            } else if (that.dlen == 2) {
                YMDStr = yaerHtml + monthHtml;
            } else if (that.dlen == 3) {
                YMDStr = yaerHtml + monthHtml + daysHtml;
            } else if (that.dlen > 3 && that.dlen <= 6) {
                YMDStr = yaerHtml + monthHtml + daysHtml;
                hmsStr = hmsHtml;
            } else if (that.dlen == 7) {
                hmsStr = hmsHtml;
            }
            var paneHtml = '{% for(var i=0;i<pane;i++){ %}<div class="ax-date-panel">' +
                '<div class="ax-date-header">{% if(i==0){ %}' + ymButton[0] + '{% }else{ %}' + ymButton[1] + '{% } %}' + ymtitHtml + '</div>' +
                '<div class="ax-date-body{%= i==1?" bordge":"" %}">' + YMDStr + '</div>' +
                '</div>{% } %}';
            opts.mode == 'inline' ? (opts.isClose = false, that.dateCell.setAttribute('data-mode', 'inline')) : null;
            let closeBtn = '';
            if (!opts.isShow || opts.mode == 'inline') {
                opts.isClose = false;
            }
            if (opts.isClear) {
                closeBtn = '<a href="###" class="ax-btn ax-text clear" @on="clearBtn">' + opts.language.clear + '</a>';
            } else if (opts.isClose) {
                closeBtn = '<a href="###" class="ax-btn ax-text clear" @on="closeBtn">' + opts.language.close + '</a>';
            } else {
                closeBtn = '';
            }
            if (opts.multiPane) {
                var btnStr = '<div class="ax-date-footer" line>{% if(timebtn){%}<a href="###" class="ax-btn ax-text timecon" @on="timeBtn">{%=lang.timetxt[0]%}</a>{% } %}' + closeBtn + '{% if(today){ %}<a href="###" class="ax-btn ax-text today" @on="nowBtn">{%=lang.today%}</a>{% } %}{% if(yes){ %}<a href="###" class="ax-btn ax-text setok" @on="sureBtn">{%=lang.yes%}</a>{% } %}</div></div>';
            } else {
                var btnStr = '<div class="ax-date-footer"><div class="ax-footer-left">{% if(timebtn){%}<a href="###" class="ax-btn ax-text timecon" @on="timeBtn">{%=lang.timetxt[0]%}</a>{% } %}</div><div class="ax-footer-right">' + closeBtn + '{% if(today){ %}<a href="###" class="ax-btn ax-text today" @on="nowBtn">{%=lang.today%}</a>{% } %}{% if(yes){ %}<a href="###" class="ax-btn setok" @on="sureBtn">{%=lang.yes%}</a>{% } %}</div></div>';
            }
            return '<div class="ax-date-main"><div class="ax-date-ymd">' + paneHtml + '</div>' + hmsStr + btnStr + '</div>';    
        },
        compileBindNode: function (dom) {
            var self = this, aton = "@on";
            var acquireAttr = function (atVal) {
                var args = /\(.*\)/.exec(atVal);
                if (args) { 
                    args = args[0];
                    atVal = atVal.replace(args, "");
                    args = args.replace(/[\(\)\'\"]/g, '').split(",");
                } else args = [];
                return [atVal, args];
            };
            jet.each(dom.childNodes, function (i, node) {
                if (node.nodeType === 1) {
                    if (!self.$opts.festival) node.removeAttribute("ymd");
                    self.compileBindNode(node);
                    var geton = node.getAttribute(aton);
                    if (geton != null) {
                        var onarr = acquireAttr(geton);
                        jet.on(node, "click", function () {
                            self[onarr[0]] && self[onarr[0]].apply(node, onarr[1]);
                        });
                        node.removeAttribute(aton);
                    }
                }
            });
        },
        methodEventBind: function () {
            var that = this, opts = that.$opts, multi = opts.multiPane, DTS = that.$data,
                result = new DateTime().reDate(), dateY = result.GetYear(), dateM = result.GetMonth(), dateD = result.GetDate(),
                range = opts.range, elCell = that.dateCell;
            jet.extend(that, {
                yearBtn: function (type, val) {
                    var yarr = val.split("#"), pval = jet.reMatch(yarr[0]), tmval = that.selectTime;
                    exarr = [jet.extend({ YYYY: parseInt(val), MM: dateM, DD: dateD }, tmval[0]), {}];
                    var dateVal = that.parseValue([exarr[0]], that.format);
                    that.storeData(exarr[0], exarr[1]);
                    that.renderDate();
                    opts.toggle && opts.toggle({ elem: that.valCell, val: dateVal, date: exarr[0] });
                },
                yearShow: function (val) {
                    DTS.year = true;
                    DTS.month = false;
                    if (that.dlen > 2 && that.dlen <= 6) {
                        DTS.day = false;
                    }
                    that.renderDate();
                },
                monthBtn: function (type, val) {
                    var ymarr = jet.reMatch(val), tmval = that.selectTime, exarr = [], PrevYM, NextYM,
                        year = parseInt(ymarr[0]), month = parseInt(ymarr[1]);
                    if (range) {
                        if (type == "mprev") {
                            PrevYM = jet.prevMonth(year, month);
                            NextYM = jet.nextMonth(PrevYM.y, PrevYM.m);
                        } else {
                            NextYM = jet.nextMonth(year, month);
                            PrevYM = jet.prevMonth(NextYM.y, NextYM.m);
                        }
                        exarr = [jet.extend({ YYYY: PrevYM.y, MM: PrevYM.m, DD: dateD }, tmval[0]), { YYYY: NextYM.y, MM: NextYM.m, DD: dateD }];
                    } else {
                        var PNYM = (type == "mprev") ? jet.prevMonth(year, month) : jet.nextMonth(year, month);
                        exarr = [jet.extend({ YYYY: PNYM.y, MM: PNYM.m, DD: dateD }, tmval[0]), {}];
                    }
                    var dateVal = that.parseValue([exarr[0]], that.format);
                    that.storeData(exarr[0], exarr[1]);
                    that.renderDate();
                    opts.toggle && opts.toggle({ elem: that.valCell, val: dateVal, date: exarr[0] });
                },
                monthShow: function (val) {
                    DTS.year = false;
                    DTS.month = true;
                    if (that.dlen > 2 && that.dlen <= 6) {
                        DTS.day = false;
                    }
                    that.renderDate();
                },
                shortClick: function (val) {
                    var reval = val.replace(/\#/g, ','), evobj = eval("(" + reval + ")"),
                        gval = jet.getDateTime(evobj), tmval = that.selectTime;
                    that.selectValue = [jet.parse(gval, "YYYY-MM-DD")];
                    that.selectDate = [{ YYYY: gval.YYYY, MM: gval.MM, DD: gval.DD }];
                    that.selectTime = [{ hh: gval.hh, mm: gval.mm, ss: gval.ss }]
                    tmval = that.selectTime;
                    if (opts.onClose) {
                        var nYM = jet.nextMonth(gval.YYYY, gval.MM),
                            ymarr = [{ YYYY: gval.YYYY, MM: gval.MM, DD: gval.DD }, { YYYY: nYM.y, MM: nYM.m, DD: null }];
                        that.storeData(jet.extend(ymarr[0], tmval[0]), jet.extend(ymarr[1], tmval[1]));
                        that.renderDate();
                    } else {
                        that.setValue(gval, that.format);
                        that.closeDate();
                    }
                    that.lastClick = 'panel';
                },
                yearClick: function (val) {
                    if (jet.hasClass(this, "ax-disabled")) return;
                    var yearVal = "", lens = that.dlen;
                    if (range && lens == 1) {
                        var ylen = that.selectValue.length;
                        that.selectDate = (ylen == 2) ? [{ YYYY: parseInt(val), MM: dateM }] :
                            [{ YYYY: that.selectDate[0].YYYY, MM: that.selectDate[0].MM }, { YYYY: parseInt(val), MM: dateM }];
                        that.selectValue = (ylen == 2) ? [val + "-" + jet.digit(dateM)] : [that.selectValue[0], val + "-" + jet.digit(dateM)];
                        if (that.selectValue.length == 2) {
                            var svalarr = [that.selectValue[0], that.selectValue[1]], newArr = [{}, {}];
                            svalarr.sort(function (a, b) { return a > b ? 1 : -1; });
                            that.selectValue = svalarr;
                            jet.each(svalarr, function (i, strval) {
                                jet.each(jet.reMatch(strval), function (s, dval) {
                                    newArr[i][ymdzArr[s]] = dval;
                                });
                            });
                            that.selectDate = newArr;
                        }
                    } else if (lens > 1 && lens <= 6) {
                        yearVal = parseInt(val);
                    } else {
                        that.selectValue = [val + "-" + jet.digit(dateM)];
                        that.selectDate = [{ YYYY: parseInt(val), MM: dateM }];
                    }
                    DTS.year = (lens == 1) ? true : false;
                    DTS.month = (lens < 3) ? true : false;
                    DTS.day = (lens > 2 && lens <= 6) ? true : false;
                    var electVal = (lens > 1 && lens <= 6) ? yearVal : parseInt(that.selectDate[0].YYYY);
                    that.storeData(jet.extend({ YYYY: electVal, MM: dateM, DD: dateD }, that.selectTime[0]), {});
                    that.renderDate();
                    that.lastClick = 'panel';
                },
                monthClick: function (val) {
                    if (jet.hasClass(this, "ax-disabled")) return;
                    var ymval = jet.reMatch(val), newArr = [{}, {}], mlen = that.selectValue.length;
                    if (range) {
                        that.selectDate = (mlen == 2) ? [{ YYYY: ymval[0], MM: ymval[1] }] :
                            [{ YYYY: that.selectDate[0].YYYY, MM: that.selectDate[0].MM }, { YYYY: parseInt(val), MM: ymval[1] }];
                        that.selectValue = (mlen == 2) ? [val] : [that.selectValue[0], val];
                        if (that.selectValue.length == 2) {
                            var svalarr = [that.selectValue[0], that.selectValue[1]];
                            svalarr.sort(function (a, b) { return a > b ? 1 : -1; });
                            that.selectValue = svalarr;
                            jet.each(svalarr, function (i, strval) {
                                jet.each(jet.reMatch(strval), function (s, dval) {
                                    newArr[i][ymdzArr[s]] = dval;
                                });
                            });
                            that.selectDate = newArr;
                        }
                    } else {
                        that.selectValue = [val];
                        that.selectDate = [{ YYYY: ymval[0], MM: ymval[1] }];
                    }
                    if (that.dlen > 2) {
                        DTS.year = false;
                        DTS.month = false;
                    }
                    DTS.day = (that.dlen > 2 && that.dlen <= 6) ? true : false;
                    that.storeData(jet.extend({
                        YYYY: parseInt(that.selectDate[0].YYYY),
                        MM: parseInt(that.selectDate[0].MM),
                        DD: dateD
                    }, that.selectTime[0]), {});
                    that.renderDate();
                    that.lastClick = 'panel';
                },
                daysClick: function (val) {
                    if (jet.hasClass(this, "ax-disabled")) return;
                    var tmval = that.selectTime, matVal = jet.reMatch(val),
                        slen = that.selectValue.length, dateVal = "",
                        newArr = [{}, {}], nYM, ymarr;
                    if (range) {
                        if (slen == 1) {
                            var svalarr = [that.selectValue[0], val];
                            svalarr.sort(function (a, b) { return a > b ? 1 : -1; });
                            that.selectValue = svalarr;
                            jet.each(svalarr, function (i, strval) {
                                jet.each(jet.reMatch(strval), function (s, dval) {
                                    newArr[i][ymdzArr[s]] = dval;
                                });
                            });
                            that.selectDate = newArr;
                        } else {
                            that.selectValue = [val];
                            newArr = [{ YYYY: matVal[0], MM: matVal[1], DD: matVal[2] }];
                            that.selectDate = [{ YYYY: matVal[0], MM: matVal[1], DD: matVal[2] }, {}];
                        }
                        nYM = jet.nextMonth(newArr[0].YYYY, newArr[0].MM);
                        ymarr = [{ YYYY: newArr[0].YYYY, MM: newArr[0].MM, DD: newArr[0].DD }, { YYYY: nYM.y, MM: nYM.m, DD: null }];
                        that.storeData(jet.extend(ymarr[0], tmval[0]), jet.extend(ymarr[1], tmval[1]));
                        that.renderDate();
                    } else {
                        that.selectValue = [val];
                        that.selectDate = [{ YYYY: matVal[0], MM: matVal[1], DD: matVal[2] }, { YYYY: matVal[0], MM: matVal[1], DD: matVal[2] }];
                        jet.each(new Array(range == false ? 1 : 2), function (a) {
                            jet.each(matVal, function (i, val) {
                                newArr[a][ymdzArr[i]] = val;
                            });
                            jet.extend(newArr[a], tmval[a]);
                        });
                        if (opts.onClose) {
                            that.storeData(jet.extend(newArr[0], tmval[0]), jet.extend(newArr[1], tmval[1]));
                            that.renderDate();
                        } else {
                            dateVal = that.setValue(newArr, that.format);
                            that.closeDate();
                            opts.donefun && opts.donefun.call(that, { elem: that.valCell, val: dateVal, date: newArr });
                        }
                    }
                    that.lastClick = 'panel';
                },
                hmsClick: function (idx, num) {
                    var pidx = parseInt(num), vals = parseInt(jet.text(this)),
                        paridx = parseInt(idx), act = "ax-selected", mhms = ["hh", "mm", "ss"],
                        ulCell = $Q(".ax-date-time", that.dateCell).querySelectorAll("ul")[pidx],
                        tlen = that.$data.timelist[0].length;
                    if (jet.hasClass(this, "ax-disabled")) return;
                    jet.each(ulCell.childNodes, function (i, node) {
                        var reg = new RegExp("(^|\\s+)" + act + "(\\s+|$)", "g");
                        node.className = reg.test(node.className) ? node.className.replace(reg, '') : node.className;
                    });
                    that.selectTime[paridx][paridx == 1 ? mhms[pidx - tlen] : mhms[pidx]] = vals;
                    this.className = this.className + act;
                    if (that.dlen == 7 && idx == 0 && range && !multi) {
                        var nVal = that.getValue({}), nYM = jet.nextMonth(nVal[0].YYYY, nVal[0].MM), st = that.selectTime;
                        that.storeData(
                            { YYYY: nVal[0].YYYY, MM: nVal[0].MM, DD: null, hh: st[0].hh, mm: st[0].mm, ss: st[0].ss },
                            { YYYY: nYM.y, MM: nYM.m, DD: null, hh: st[1].hh, mm: st[1].mm, ss: st[1].ss }
                        );
                        that.renderDate();
                    }
                    that.lastClick = 'panel';
                },
                timeBtn: function () {
                    var timeCell = $Q(".ax-date-time", elCell), disNo = timeCell.style.display == "none";
                    jet.text(this, disNo ? opts.language.backtxt : opts.language.timetxt[0]);
                    jet.setCss(timeCell, { display: disNo ? "" : "none" });
                    that.lastClick = 'panel';
                    timeCell.querySelectorAll('ul').forEach(item =>{
                        axPreventScroll(item);
                    });
                },
                clearBtn: function () {
                    jet.valText(that.valCell, "");
                    that.selectDate = [jet.parse(jet.getDateTime({}), "YYYY-MM-DD hh:mm:ss")];
                    if (opts.isShow) {
                        that.closeDate();
                    }
                    opts.clearfun && opts.clearfun.call(that);
                },
                closeBtn: function () {
                    if (opts.isShow) {
                        that.closeDate();
                    }
                    opts.closefun && opts.closefun.call(that);
                },
                nowBtn: function () {
                    var newArr = jet.getDateTime({}), nYM = jet.nextMonth(newArr.YYYY, newArr.MM), dateVal;
                    that.selectDate = [newArr];
                    that.storeData(newArr, { YYYY: nYM.y, MM: nYM.m, DD: null, hh: 0, mm: 0, ss: 0 });
                    that.renderDate();
                    if (opts.nowClose) {
                        dateVal = opts.isShow ? that.setValue([newArr], that.format, true) : jet.parse(newArr, that.format);
                        that.closeDate();
                    } else {
                        if (opts.mode == 'inline') {
                            that.setValue([newArr], that.format, true);
                        }
                    }
                    that.nowVal = that.selectDate;
                    that.lastClick = 'now';
                    /*  if (opts.onClose && range || !opts.isShow) {
                         that.storeData(newArr, { YYYY: nYM.y, MM: nYM.m, DD: null, hh: 0, mm: 0, ss: 0 });
                         that.renderDate();
                     } else {
                         that.storeData(newArr, { YYYY: nYM.y, MM: nYM.m, DD: null, hh: 0, mm: 0, ss: 0 });
                         that.renderDate();
                     } */
                    /*if (opts.onClose && range || !opts.isShow) {
                     that.storeData(newArr, { YYYY: nYM.y, MM: nYM.m, DD: null, hh: 0, mm: 0, ss: 0 });
                    that.renderDate(); 
                     } else {
                    that.closeDate();
                    }*/
                    opts.donefun && opts.donefun.call(that, { elem: that.valCell, val: dateVal, date: newArr });
                },
                sureBtn: function () {
                    var newArr = that.selectValue.length > 1 ? [{}, {}] : [{}], dateVal = "", tmval = that.selectTime;
                    var equal = function (o) {
                        var h = o.hh == undefined ? 0 : o.hh, m = o.mm == undefined ? 0 : o.mm, s = o.ss == undefined ? 0 : o.ss;
                        return parseInt(jet.digit(h) + "" + jet.digit(m) + "" + jet.digit(s));
                    };
                    if (range) {
                        if (that.selectValue.length > 1) {
                            var sortarr = that.selectValue;
                            sortarr.sort(function (a, b) { return a > b ? 1 : -1; });
                            jet.each(sortarr, function (i, arr) {
                                jet.each(jet.reMatch(arr), function (a, val) {
                                    newArr[i][ymdzArr[a]] = val;
                                });
                                jet.extend(newArr[i], tmval[i]);
                            });
                        } else if (that.dlen == 7 && tmval.length > 1) {
                            newArr = tmval;
                        }
                        var sameTime = equal(tmval[0]) >= equal(tmval[1]), selVal = that.selectValue, sameDate = "";
                        if (selVal[1] != undefined) sameDate = selVal[0].replace(/\-/g, "") == selVal[1].replace(/\-/g, "");
                        if (selVal.length == 1 && that.dlen < 7) {
                            that.tips(opts.language.name == "cn" ? "未选结束日期" : "Please select the end date"); return;
                        } else if ((that.dlen == 7 && sameTime) || (sameDate && sameTime)) {
                            that.tips(opts.language.name == "cn" ? "结束时间必须大于开始时间" : "The end time must be greater than the start time"); return;
                        }
                    } else {
                        jet.each(new Array(range == false ? 1 : 2), function (i) {
                            if (that.dlen != 7) jet.each(jet.reMatch(that.selectValue[0]), function (a, val) {
                                newArr[i][ymdzArr[a]] = val;
                            });
                            jet.extend(newArr[i], tmval[i]);
                        });
                    }
                    if (that.lastClick == 'now') {
                        dateVal = that.setValue(that.nowVal, that.format, opts.isShow ? true : false);
                    } else {
                        dateVal = that.setValue(newArr, that.format, opts.isShow ? true : false);
                    }
                    that.closeDate();
                    opts.donefun && opts.donefun.call(that, { elem: that.valCell, val: dateVal, date: newArr });
                },
                blankArea: function () {
                    /* jet.on(document, "mouseup", function (ev) {
                        jet.stopPropagation(ev);
                        opts.mode !== 'inline' && that.closeDate();
                    });
                    jet.on($Q(elx), "mouseup", function (ev) {
                        jet.stopPropagation(ev);
                    }); */
                }
            });
        },
        eachYear: function (val, type) {
            var that = this, opts = that.$opts, yNum = parseInt(val), yarr = [], seCls = '', selYear = that.selectDate, i,
                mins = jet.reMatch(that.minDate), maxs = jet.reMatch(that.maxDate);
            i = type == 1 ? yNum : that.yindex;
            that.yindex = type == 1 ? 12 + yNum : 12 + that.yindex;
            var endDate = selYear[1] == undefined ? "" : selYear[1].YYYY;
            for (; i < that.yindex; i++) {
                if (opts.range && i == selYear[0].YYYY) {
                    seCls = "ax-selected ax-start";
                } else if (opts.range && i == endDate) {
                    seCls = "ax-selected ax-end";
                } else if (i == selYear[0].YYYY || i == endDate) {
                    seCls = "ax-selected";
                } else if (i > selYear[0].YYYY && i < endDate) {
                    seCls = "ax-contain";
                } else if (i < mins[0] || i > maxs[0]) {
                    seCls = "ax-disabled";
                } else {
                    seCls = "";
                }
                yarr.push({ style: seCls, y: i });
            }
            return yarr;
        },
        eachMonth: function (val, type) {
            var that = this, opts = that.$opts, marr = [],
                selMonth = that.selectDate, seCls = '', monthArr = opts.language.month,
                mins = jet.reMatch(that.minDate), maxs = jet.reMatch(that.maxDate),
                minym = parseInt(mins[0] + "" + jet.digit(mins[1])),
                maxym = parseInt(maxs[0] + "" + jet.digit(maxs[1])),
                currStart = parseInt(selMonth[0].YYYY + "" + jet.digit(selMonth[0].MM)),
                currEnd = selMonth[1] ? parseInt(selMonth[1].YYYY + "" + jet.digit(selMonth[1].MM)) : 0;
            jet.each(monthArr, function (i, months) {
                var ival = parseInt(val + "" + jet.digit(months));
                if (opts.range && ival == currStart) {
                    seCls = "ax-selected ax-start";
                } else if (opts.range && ival == currEnd) {
                    seCls = "ax-selected ax-end";
                } else if (ival == currStart || ival == currEnd) {
                    seCls = "ax-selected";
                } else if (ival > currStart && ival < currEnd) {
                    seCls = "ax-contain";
                } else if (ival < minym || ival > maxym) {
                    seCls = "ax-disabled";
                } else {
                    seCls = "";
                }
                marr.push({ style: seCls, y: val, m: months });
            });
            return marr;
        },
        eachDays: function (yd, md, ds, idx) {
            var that = this, count = 0, daysArr = [], opts = that.$opts,
                firstWeek = new Date(yd, md - 1, 1).getDay() || 7,
                daysNum = jet.getDaysNum(yd, md), sDate = that.selectDate,
                prevM = jet.prevMonth(yd, md),
                prevDaysNum = jet.getDaysNum(yd, prevM.m), nextM = jet.nextMonth(yd, md),
                lang = opts.language, endval = opts.valiDate || [],
                minArr = jet.reMatch(that.minDate), minNum = parseInt(minArr[0] + "" + jet.digit(minArr[1]) + "" + jet.digit(minArr[2])),
                maxArr = jet.reMatch(that.maxDate), maxNum = parseInt(maxArr[0] + "" + jet.digit(maxArr[1]) + "" + jet.digit(maxArr[2]));
            var startDate = sDate[0] ? parseInt(sDate[0].YYYY + "" + jet.digit(sDate[0].MM) + "" + jet.digit(sDate[0].DD)) : "";
            var endDate = sDate[1] ? parseInt(sDate[1].YYYY + "" + jet.digit(sDate[1].MM) + "" + jet.digit(sDate[1].DD)) : "";
            var setMark = function (my, mm, md) {
                var Marks = opts.marks, contains = function (arr, obj) {
                    var clen = arr.length;
                    while (clen--) { if (arr[clen] === obj) return true; }
                    return false;
                }, isArr = jet.isType(Marks, "array");
                return isArr && Marks.length > 0 && contains(Marks, my + "-" + jet.digit(mm) + "-" + jet.digit(md)) ? '<i class="marks"></i>' : "";
            };
            var isfestival = function (y, m, d) {
                var festivalStr = '';
                if (opts.festival == true && lang.name == "cn") {
                    var lunar = jeLunar(y, m - 1, d), feslunar = (lunar.solarFestival || lunar.lunarFestival),
                        lunartext = (feslunar && lunar.jieqi) != "" ? feslunar : (lunar.jieqi || lunar.showInLunar);
                    festivalStr = '<div class="ax-with-lunar"><div class="ax-solar">' + d + '</div><div class="ax-lunar">' + lunartext + '</div></div>';
                } else {
                    festivalStr = '<span class="ax-unit">' + d + '</span>';
                }
                return festivalStr;
            };
            var dateLimit = function (Y, M, D, isMonth) {
                var thatNum = parseInt(Y + "" + jet.digit(M) + "" + jet.digit(D));
                if (isMonth) {
                    if (thatNum >= minNum && thatNum <= maxNum) return true;
                } else {
                    if (minNum > thatNum || maxNum < thatNum) return true;
                }
            };
            var regExpDate = function (date, cls) {
                var inArray = function (search, array) {
                    for (var i in array) if (array[i] == search) return true;
                    return false;
                };
                if (endval.length > 0 && endval[0] != "") {
                    if (/\%/g.test(endval[0])) {
                        var reval = endval[0].replace(/\%/g, "").split(","), enArr = [];
                        jet.each(reval, function (r, rel) {
                            enArr.push(jet.digit(parseInt(rel)));
                        });
                        var isfind = inArray(jet.digit(date), enArr) == false;
                        cls = jet.isBool(endval[1]) ? (isfind ? " ax-disabled" : cls) : (isfind ? cls : " ax-disabled");
                    } else {
                        var valreg = that.dateRegExp(endval[0]), regday = valreg.test(jet.digit(date));
                        cls = jet.isBool(endval[1]) ? (regday ? " ax-disabled" : cls) : (regday ? cls : " ax-disabled");
                    }
                }
                return cls;
            };
            for (var p = prevDaysNum - firstWeek + 1; p <= prevDaysNum; p++, count++) {
                var pmark = setMark(prevM.y, prevM.m, p), pcls = dateLimit(prevM.y, prevM.m, p, false) ? "ax-disabled" : "ax-other";
                pcls = regExpDate(p, pcls);
                daysArr.push({ style: pcls, ymd: prevM.y + '-' + jet.digit(prevM.m) + '-' + jet.digit(p), day: (isfestival(prevM.y, prevM.m, p) + pmark) });
            }
            for (var b = 1; b <= daysNum; b++, count++) {
                var bmark = setMark(yd, md, b), bcls = "";
                var dateval = parseInt(yd + "" + jet.digit(md) + "" + jet.digit(b)),
                    parsdate = dateval > startDate, rangdate = dateval < endDate;
                if (dateLimit(yd, md, b, true)) {
                    if (opts.range && dateval == startDate) {
                        bcls = " ax-selected ax-start";
                    } else if (opts.range && dateval == endDate) {
                        bcls = " ax-selected ax-end";
                    } else if (dateval == startDate || dateval == endDate) {
                        bcls = " ax-selected";
                    } else if (parsdate && rangdate) {
                        bcls = " ax-contain";
                    } else {
                        bcls = "";
                    }
                } else {
                    bcls = " ax-disabled";
                }
                bcls = regExpDate(b, bcls);
                daysArr.push({ style: "ax-current" + bcls, ymd: yd + '-' + jet.digit(md) + '-' + jet.digit(b), day: (isfestival(yd, md, b) + bmark) });
            }
            for (var n = 1, nlen = 42 - count; n <= nlen; n++) {
                var nmark = setMark(nextM.y, nextM.m, n);
                var ncls = dateLimit(nextM.y, nextM.m, n, false) ? "ax-disabled" : "ax-other";
                ncls = regExpDate(n, ncls);
                daysArr.push({ style: ncls, ymd: nextM.y + '-' + jet.digit(nextM.m) + '-' + jet.digit(n), day: (isfestival(nextM.y, nextM.m, n) + nmark) });
            }
            return daysArr;
        },
        eachTime: function (hmsArr, type) {
            var that = this, opts = that.$opts, range = opts.range, multi = opts.multiPane, minVal = [], maxVal = [],
                mhms = ["hh", "mm", "ss"], timeArr = [], hmsCls = '', format = that.format,
                ntVal = jet.trim(that.minDate).replace(/\s+/g, " "),
                xtVal = jet.trim(that.maxDate).replace(/\s+/g, " "),
                nVal = ntVal.split(" "), xVal = xtVal.split(" ");
            if (that.dlen > 3 && /\:/.test(nVal) && /\:/.test(xVal)) {
                minVal = jet.reMatch(/\s/.test(ntVal) && that.dlen > 3 ? nVal[1] : ntVal);
                maxVal = jet.reMatch(/\s/.test(xtVal) && that.dlen > 3 ? xVal[1] : xtVal);
            }
            jet.each([24, 60, 60], function (s, lens) {
                timeArr[s] = [];
                var unhmsVal = minVal[s] == undefined || minVal[s] == 0 ? hmsArr[mhms[s]] : minVal[s],
                    currVal = that.getValue() == "" ? unhmsVal : hmsArr[mhms[s]];
                if (that.dlen > 3 && /\:/.test(nVal) && type == 1) {
                    that.selectTime[0][mhms[s]] = currVal;
                }
                for (var h = 0; h < lens; h++) {
                    var exists = new RegExp(mhms[s], "g").test(format);
                    if (h == currVal) {
                        hmsCls = exists ? "ax-selected" : "ax-disabled";
                    } else if (!exists || !range && multi && (h < minVal[s] || h > maxVal[s])) {
                        hmsCls = "ax-disabled";
                    } else if (!multi) {
                        hmsCls = type == 1 && h < minVal[s] || type == 2 && h > maxVal[s] ? "ax-disabled" : "";
                    } else {
                        hmsCls = "";
                    }
                    timeArr[s].push({ style: hmsCls, hms: h });
                }
            });
            return timeArr;
        },
        closeDate: function () {
            /* var elem = $Q(elx), tipelem = $Q("#jedatetipscon");
            elem && document.body.removeChild(elem);
            tipelem && document.body.removeChild(tipelem); */
            if (this.$opts.mode == 'popup') {
                this.popup.hide();
            } else if (this.$opts.mode == 'dialog') {
                this.dialog.hide();
            }
        },
        parseValue: function (fnObj, matStr) {
            var that = this, valArr = [], opts = that.$opts, range = opts.range;
            jet.each(fnObj, function (i, val) {
                valArr.push(jet.parse(val, matStr));
            });
            return range == false ? valArr[0] : valArr.join(range);
        },
        dateRegExp: function (valArr) {
            var enval = valArr.split(",") || [], regs = "";
            var doExp = function (val) {
                var arr, tmpEval, regs = /#?\{(.*?)\}/;
                val = val + "";
                while ((arr = regs.exec(val)) != null) {
                    arr.lastIndex = arr.index + arr[1].length + arr[0].length - arr[1].length - 1;
                    tmpEval = parseInt(eval(arr[1]));
                    if (tmpEval < 0) tmpEval = "9700" + -tmpEval;
                    val = val.substring(0, arr.index) + tmpEval + val.substring(arr.lastIndex + 1);
                }
                return val;
            };
            if (enval && enval.length > 0) {
                for (var i = 0; i < enval.length; i++) {
                    regs += doExp(enval[i]);
                    if (i != enval.length - 1) regs += "|";
                }
                regs = regs ? new RegExp("(?:" + regs + ")") : null;
            } else {
                regs = null;
            }
            return regs;
        },
        showFestival: function () {
            var that = this, opts = that.$opts;
            jet.each(that.dateCell.querySelectorAll(".ax-dtable td"), function (i, node) {
                var tval = jet.reMatch(jet.attr(node, "ymd")), tipDiv = document.createElement("div");
                node.removeAttribute("ymd");
                new axHover(node, {
                    enter: function () {
                        var lunar = new jeLunar(tval[0], tval[1] - 1, tval[2]);
                        if ($Q("#jedatetipscon")) return;
                        tipDiv.id = tipDiv.className = "jedatetipscon";
                        var tiphtml = '<p>' + lunar.solarYear + '\u5E74' + lunar.solarMonth + '\u6708' + lunar.solarDate + '\u65E5 ' + lunar.inWeekDays + '</p><p>\u519C\u5386：' + lunar.shengxiao + '\u5E74 ' + lunar.lnongMonth + '\u6708' + lunar.lnongDate + '</p><p>' + lunar.ganzhiYear + '\u5E74 ' + lunar.ganzhiMonth + '\u6708 ' + lunar.ganzhiDate + '\u65E5</p>';
                        var Fesjieri = (lunar.solarFestival || lunar.lunarFestival) != "" ? '<p class="red">' + ("\u8282\u65E5：" + lunar.solarFestival + lunar.lunarFestival) + '</p>' : "";
                        var Fesjieqi = lunar.jieqi != "" ? '<p>' + (lunar.jieqi != "" ? "\u8282\u6C14：" + lunar.jieqi : "") + '</p>' : "";
                        var tiptext = (lunar.solarFestival || lunar.lunarFestival || lunar.jieqi) != "" ? (Fesjieri + Fesjieqi) : "";
                        jet.html(tipDiv, tiphtml + tiptext);
                        that.lunarPopup = new axPopup(node, {
                            size: '',
                            close: false,
                            placement: 'bottom-start',
                            footerShow: false,
                            content: tipDiv,
                        }).show();
                    },
                    leave: function () {
                        that.lunarPopup ? that.lunarPopup.targetDom.remove() : null;
                    },
                })
            });
            if (that.dateCell.nodeType === 1 && !jet.hasClass(that.dateCell, "grid")) that.dateCell.className = that.dateCell.className + " grid";
        },
        lunarOrien: function (obj, self, pos) {
            var tops, leris, ortop, orleri, rect = self.getBoundingClientRect(), boxW = obj.offsetWidth, boxH = obj.offsetHeight;
            leris = rect.right + boxW / 1.5 >= jet.docArea(true) ? rect.right - boxW : rect.left + (pos ? 0 : jet.docScroll(true));
            tops = rect.bottom + boxH / 1 <= jet.docArea() ? rect.bottom - 1 : rect.top > boxH / 1.5 ? rect.top - boxH - 1 : jet.docArea() - boxH;
            if (leris + boxW > jet.docArea(true)) leris = rect.left - (boxW - rect.width);
            ortop = Math.max(tops + (pos ? 0 : jet.docScroll()) + 1, 1) + "px", orleri = leris + "px";
            return { top: ortop, left: orleri }
        },
        dateOrien: function (elbox, valCls, pos) {
            var that = this, tops, leris, ortop, orleri,
                rect = that.$opts.fixed ? valCls.getBoundingClientRect() : elbox.getBoundingClientRect(),
                leris = rect.left, tops = rect.bottom;
            if (that.$opts.fixed) {
                var boxW = elbox.offsetWidth, boxH = elbox.offsetHeight;
                if (leris + boxW > jet.docArea(true)) {
                    leris = leris - (boxW - rect.width);
                }
                if (tops + boxH > jet.docArea()) {
                    tops = rect.top > boxH ? rect.top - boxH - 2 : jet.docArea() - boxH - 1;
                }
                ortop = Math.max(tops + (pos ? 0 : jet.docScroll()) + 1, 1) + "px"; orleri = leris + "px";
            } else {
                ortop = "50%"; orleri = "50%";
                elbox.style.cssText = "marginTop:" + -(rect.height / 2) + ";marginLeft:" + -(rect.width / 2);
            }
        },
        tips: function (text, time) {
            /* var that = this, tipCls = $Q(".ax-date-tips", that.dateCell), tipTime;
            jet.html(tipCls, text || ""); jet.setCss(tipCls, { display: "block" });
            clearTimeout(tipTime);
            tipTime = setTimeout(function () {
                jet.html(tipCls, ""); jet.setCss(tipCls, { display: "none" });
            }, (time || 2.5) * 1000); */
            new axMessage({
                content: text,
                iconShow: true,
                result: 'error',
            });
        },
        locateScroll: function () {
            var that = this, ulCell = $Q(".ax-date-time", that.dateCell).querySelectorAll("ul");
            jet.each(ulCell, function (i, cell) {
                var hmsCls = cell.querySelector(".ax-selected");
                cell.scrollTop = hmsCls ? (hmsCls.offsetTop) : 0;
            });
            if (that.dlen != 7) jet.setCss($Q(".ax-date-time", that.dateCell), { display: 'none' });
        }
    });
    function jeLunar(ly, lm, ld) {
        var lunarInfo = [19416, 19168, 42352, 21717, 53856, 55632, 91476, 22176, 39632, 21970, 19168, 42422, 42192, 53840, 119381, 46400, 54944, 44450, 38320, 84343, 18800, 42160, 46261, 27216, 27968, 109396, 11104, 38256, 21234, 18800, 25958, 54432, 59984, 28309, 23248, 11104, 100067, 37600, 116951, 51536, 54432, 120998, 46416, 22176, 107956, 9680, 37584, 53938, 43344, 46423, 27808, 46416, 86869, 19872, 42448, 83315, 21200, 43432, 59728, 27296, 44710, 43856, 19296, 43748, 42352, 21088, 62051, 55632, 23383, 22176, 38608, 19925, 19152, 42192, 54484, 53840, 54616, 46400, 46496, 103846, 38320, 18864, 43380, 42160, 45690, 27216, 27968, 44870, 43872, 38256, 19189, 18800, 25776, 29859, 59984, 27480, 21952, 43872, 38613, 37600, 51552, 55636, 54432, 55888, 30034, 22176, 43959, 9680, 37584, 51893, 43344, 46240, 47780, 44368, 21977, 19360, 42416, 86390, 21168, 43312, 31060, 27296, 44368, 23378, 19296, 42726, 42208, 53856, 60005, 54576, 23200, 30371, 38608, 19415, 19152, 42192, 118966, 53840, 54560, 56645, 46496, 22224, 21938, 18864, 42359, 42160, 43600, 111189, 27936, 44448],
            sTermInfo = [0, 21208, 43467, 63836, 85337, 107014, 128867, 150921, 173149, 195551, 218072, 240693, 263343, 285989, 308563, 331033, 353350, 375494, 397447, 419210, 440795, 462224, 483532, 504758];
        var Gan = "甲乙丙丁戊己庚辛壬癸", Zhi = "子丑寅卯辰巳午未申酉戌亥", Animals = "鼠牛虎兔龙蛇马羊猴鸡狗猪";
        var solarTerm = ["小寒", "大寒", "立春", "雨水", "惊蛰", "春分", "清明", "谷雨", "立夏", "小满",
            "芒种", "夏至", "小暑", "大暑", "立秋", "处暑", "白露", "秋分", "寒露", "霜降", "立冬", "小雪", "大雪", "冬至"];
        var nStr1 = "日一二三四五六七八九十", nStr2 = "初十廿卅", nStr3 = ["正", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "腊"],
            sFtv1 = {
                "0101": "*1元旦节", "0202": "湿地日",
                "0214": "情人节", "0308": "妇女节",
                "0312": "植树节", "0315": "消费者权益日",
                "0401": "愚人节", "0422": "地球日",
                "0501": "*1劳动节", "0504": "青年节",
                "0512": "护士节", "0518": "博物馆日",
                "0520": "母亲节", "0601": "儿童节",
                "0623": "奥林匹克日", "0630": "父亲节",
                "0701": "建党节", "0801": "建军节",
                "0903": "抗战胜利日", "0910": "教师节",
                "1001": "*3国庆节", "1201": "艾滋病日",
                "1224": "平安夜", "1225": "圣诞节"
            },
            sFtv2 = {
                "0100": "除夕", "0101": "*2春节",
                "0115": "元宵节", "0505": "*1端午节",
                "0707": "七夕节", "0715": "中元节",
                "0815": "*1中秋节", "0909": "*1重阳节",
                "1015": "下元节", "1208": "腊八节",
                "1223": "小年"
            };
        function flunar(Y) {
            var sTerm = function (j, i) {
                var h = new Date((31556925974.7 * (j - 1900) + sTermInfo[i] * 60000) + Date.UTC(1900, 0, 6, 2, 5));
                return (h.getUTCDate());
            },
                d = function (k) {
                    var h, j = 348;
                    for (h = 32768; h > 8; h >>= 1) j += (lunarInfo[k - 1900] & h) ? 1 : 0;
                    return (j + b(k));
                },
                ymdCyl = function (h) {
                    return (Gan.charAt(h % 10) + Zhi.charAt(h % 12));
                },
                b = function (h) {
                    var islp = (g(h)) ? ((lunarInfo[h - 1900] & 65536) ? 30 : 29) : (0);
                    return islp;
                },
                g = function (h) {
                    return (lunarInfo[h - 1900] & 15)
                },
                e = function (i, h) {
                    return ((lunarInfo[i - 1900] & (65536 >> h)) ? 30 : 29);
                },
                newymd = function (m) {
                    var k, j = 0, h = 0, l = new Date(1900, 0, 31), n = (m - l) / 86400000;
                    this.dayCyl = n + 40;
                    this.monCyl = 14;
                    for (k = 1900; k < 2050 && n > 0; k++) {
                        h = d(k); n -= h;
                        this.monCyl += 12;
                    }
                    if (n < 0) {
                        n += h; k--;
                        this.monCyl -= 12;
                    }
                    this.year = k;
                    this.yearCyl = k - 1864;
                    j = g(k);
                    this.isLeap = false;
                    for (k = 1; k < 13 && n > 0; k++) {
                        if (j > 0 && k == (j + 1) && this.isLeap == false) {
                            --k;
                            this.isLeap = true;
                            h = b(this.year);
                        } else {
                            h = e(this.year, k);
                        }
                        if (this.isLeap == true && k == (j + 1)) {
                            this.isLeap = false;
                        }
                        n -= h;
                        if (this.isLeap == false) this.monCyl++;
                    }
                    if (n == 0 && j > 0 && k == j + 1) {
                        if (this.isLeap) {
                            this.isLeap = false;
                        } else {
                            this.isLeap = true;
                            --k;
                            --this.monCyl;
                        }
                    }
                    if (n < 0) {
                        n += h; --k;
                        --this.monCyl;
                    }
                    this.month = k;
                    this.day = n + 1;
                },
                digit = function (num) {
                    return num < 10 ? "0" + (num | 0) : num;
                },
                reymd = function (i, j) {
                    var h = i;
                    return j.replace(/dd?d?d?|MM?M?M?|yy?y?y?/g, function (k) {
                        switch (k) {
                            case "yyyy":
                                var l = "000" + h.getFullYear();
                                return l.substring(l.length - 4);
                            case "dd": return digit(h.getDate());
                            case "d": return h.getDate().toString();
                            case "MM": return digit((h.getMonth() + 1));
                            case "M": return h.getMonth() + 1;
                        }
                    });
                },
                lunarMD = function (i, h) {
                    var j;
                    switch (i, h) {
                        case 10: j = "初十"; break;
                        case 20: j = "二十"; break;
                        case 30: j = "三十"; break;
                        default:
                            j = nStr2.charAt(Math.floor(h / 10));
                            j += nStr1.charAt(h % 10);
                    }
                    return j;
                };
            this.isToday = false;
            this.isRestDay = false;
            this.solarYear = reymd(Y, "yyyy");
            this.solarMonth = reymd(Y, "M");
            this.solarDate = reymd(Y, "d");
            this.solarWeekDay = Y.getDay();
            this.inWeekDays = "星期" + nStr1.charAt(this.solarWeekDay);
            var X = new newymd(Y);
            this.lunarYear = X.year;
            this.shengxiao = Animals.charAt((this.lunarYear - 4) % 12);
            this.lunarMonth = X.month;
            this.lunarIsLeapMonth = X.isLeap;
            this.lnongMonth = this.lunarIsLeapMonth ? "闰" + nStr3[X.month - 1] : nStr3[X.month - 1];
            this.lunarDate = X.day;
            this.showInLunar = this.lnongDate = lunarMD(this.lunarMonth, this.lunarDate);
            if (this.lunarDate == 1) {
                this.showInLunar = this.lnongMonth + "月";
            }
            this.ganzhiYear = ymdCyl(X.yearCyl);
            this.ganzhiMonth = ymdCyl(X.monCyl);
            this.ganzhiDate = ymdCyl(X.dayCyl++);
            this.jieqi = "";
            this.restDays = 0;
            if (sTerm(this.solarYear, (this.solarMonth - 1) * 2) == reymd(Y, "d")) {
                this.showInLunar = this.jieqi = solarTerm[(this.solarMonth - 1) * 2];
            }
            if (sTerm(this.solarYear, (this.solarMonth - 1) * 2 + 1) == reymd(Y, "d")) {
                this.showInLunar = this.jieqi = solarTerm[(this.solarMonth - 1) * 2 + 1];
            }
            if (this.showInLunar == "清明") {
                this.showInLunar = "清明节";
                this.restDays = 1;
            }
            this.solarFestival = sFtv1[reymd(Y, "MM") + reymd(Y, "dd")];
            if (typeof this.solarFestival == "undefined") {
                this.solarFestival = "";
            } else {
                if (/\*(\d)/.test(this.solarFestival)) {
                    this.restDays = parseInt(RegExp.$1);
                    this.solarFestival = this.solarFestival.replace(/\*\d/, "");
                }
            }
            this.showInLunar = (this.solarFestival == "") ? this.showInLunar : this.solarFestival;
            this.lunarFestival = sFtv2[this.lunarIsLeapMonth ? "00" : digit(this.lunarMonth) + digit(this.lunarDate)];
            if (typeof this.lunarFestival == "undefined") {
                this.lunarFestival = "";
            } else {
                if (/\*(\d)/.test(this.lunarFestival)) {
                    this.restDays = (this.restDays > parseInt(RegExp.$1)) ? this.restDays : parseInt(RegExp.$1);
                    this.lunarFestival = this.lunarFestival.replace(/\*\d/, "");
                }
            }
            if (this.lunarMonth == 12 && this.lunarDate == e(this.lunarYear, 12)) {
                this.lunarFestival = sFtv2["0100"];
                this.restDays = 1;
            }
            this.showInLunar = (this.lunarFestival == "") ? this.showInLunar : this.lunarFestival;
        }
        return new flunar(new Date(ly, lm, ld));
    }
    return jeDate;
})();
document.querySelectorAll('[axDate]').forEach(element => {
    new axDate(element);
});
/*!
* 插件：轮滑选择；改造自ion.rangeSlider | https://github.com/IonDen/ion.rangeSlider；使用方法：new axRange('#id',{参数})
*/
const axRanges = [];
class axRange {
    constructor(targetDom, options) {
        if ((typeof targetDom) === 'string') {
            this.targetDom = document.querySelector(targetDom);
        } else {
            this.targetDom = targetDom;
        }
        if (!(this instanceof axRange)) return new axRange(targetDom, options);
        let _this = this;
        this.calcCount = 0;
        this.updateTm = 0;
        this.oldFrom = 0;
        this.oldTo = 0;
        this.oldMinInterval = null;
        this.rafId = null;
        this.dragging = false;
        this.forceRedraw = false;
        this.noDiapason = false;
        this.hasTabIndex = true;
        this.isKey = false;
        this.isUpdate = false;
        this.isStart = true;
        this.isFinish = false;
        this.isActive = false;
        this.isResize = false;
        this.isClick = false;
        this.target = "base";
        this.cache = {
            win: window,
            body: document.body,
            targetDom: this.targetDom,
            cont: null,
            rs: null,
            min: null,
            max: null,
            from: null,
            to: null,
            single: null,
            bar: null,
            line: null,
            s_single: null,
            s_from: null,
            s_to: null,
            shad_single: null,
            shad_from: null,
            shad_to: null,
            edge: null,
            grid: null,
            grid_labels: []
        };
        this.coords = {
            x_gap: 0,
            x_pointer: 0,
            w_rs: 0,
            w_rs_old: 0,
            w_handle: 0,
            p_gap: 0,
            p_gap_left: 0,
            p_gap_right: 0,
            p_step: 0,
            p_pointer: 0,
            p_handle: 0,
            p_single_fake: 0,
            p_single_real: 0,
            p_from_fake: 0,
            p_from_real: 0,
            p_to_fake: 0,
            p_to_real: 0,
            p_bar_x: 0,
            p_bar_w: 0,
            grid_gap: 0,
            big_num: 0,
            big: [],
            big_w: [],
            big_p: [],
            big_x: []
        };
        this.labels = {
            w_min: 0,
            w_max: 0,
            w_from: 0,
            w_to: 0,
            w_single: 0,
            p_min: 0,
            p_max: 0,
            p_from_fake: 0,
            p_from_left: 0,
            p_to_fake: 0,
            p_to_left: 0,
            p_single_fake: 0,
            p_single_left: 0
        };
        if (this.targetDom.nodeName !== "INPUT") {
            console && console.warn && console.warn("Base targetDom should be <input>!", input);
        }
        this.config = {
            className: "",
            type: "single",
            min: 0,
            max: 100,
            from: null,
            to: null,
            step: 1,
            minInterval: 0,
            maxInterval: 0,
            dragInterval: false,
            values: [],
            pValues: [],
            fromStick: false,
            fromMin: null,
            fromMax: null,
            fromShadow: false,
            toStick: false,
            toMin: null,
            toMax: null,
            toShadow: false,
            prettifyEnabled: false,
            prettifySeparator: " ",
            prettify: null,
            forceEdges: false,
            keyboard: true,
            grid: false,
            gridMargin: true,
            gridNum: 4,
            gridSnap: false,
            hideLabelTrack: false,
            hideLabelSlider: false,
            prefix: "",
            postfix: "",
            maxPostfix: "",
            decorateBoth: true,
            valuesSeparator: " — ",
            inputValuesSeparator: ";",
            disabled: false,
            block: false,
            scope: null,
            onStart: null,
            onChange: null,
            onFinish: null,
            onUpdate: null
        }
        let val = this.targetDom.value;
        if (val !== undefined && val !== "") {
            if (options && options.inputValuesSeparator) {
                val = val.split(options.inputValuesSeparator);
            } else {
                val = val.split(";");
            }
            if (val[0] && val[0] == +val[0]) {
                val[0] = +val[0];
            }
            if (val[1] && val[1] == +val[1]) {
                val[1] = +val[1];
            }
            if (options && options.values && options.values.length) {
                this.config.from = val[0] && options.values.indexOf(val[0]);
                this.config.to = val[1] && options.values.indexOf(val[1]);
            } else {
                this.config.from = val[0] && +val[0];
                this.config.to = val[1] && +val[1];
            }
        }
        this.options = axExtend(this.config, options, this.targetDom);
        this.targetDom ? this.referName = this.targetDom.getAttribute('axRange') : this.referName = '';
        this.handlers = {};
        this.update_check = {};
        this.result = {
            input: this.cache.targetDom,
            slider: null,
            min: this.options.min,
            max: this.options.max,
            from: this.options.from,
            from_percent: 0,
            from_value: null,
            to: this.options.to,
            to_percent: 0,
            to_value: null
        };
        const base_html =
            '<div class="ax-range-label">' +
            '<span class="ax-range-line" tabindex="0"></span>' +
            '<span class="ax-range-min">0</span><span class="ax-range-max">1</span>' +
            '<span class="ax-range-from">0</span><span class="ax-range-to">0</span><span class="ax-range-single">0</span>' +
            '</div>' +
            '<div class="ax-range-grid">1</div>';
        const single_html =
            '<div class="ax-range-bar ax-range-bar-single"></div>' +
            '<div class="ax-range-shadow ax-shadow-single"></div>' +
            '<span class="ax-range-handle ax-single"><i></i><i></i><i></i></span>';
        const double_html =
            '<div class="ax-range-bar"></div>' +
            '<div class="ax-range-shadow ax-shadow-from"></div>' +
            '<div class="ax-range-shadow ax-shadow-to"></div>' +
            '<span class="ax-range-handle ax-from"><i></i><i></i><i></i></span>' +
            '<span class="ax-range-handle ax-to"><i></i><i></i><i></i></span>';
        const disable_html =
            '<div class="ax-disabled-mask"></div>';
        this.ready = function (update) {
            this.noDiapason = false;
            this.coords.p_step = convertToPercent(this.options.step, true);
            this.target = "base";
            this.toggleInput();
            append();
            setMinMax();
            if (update) {
                this.forceRedraw = true;
                calc(true);
                callOnUpdate();
            } else {
                this.forceRedraw = true;
                calc(true);
                callOnStart();
            }
            updateScene();
        };
        const append = function () {
            const container_html = '<div class="ax-range ' + _this.options.className + '"></div>';
            _this.cache.targetDom.insertAdjacentHTML('beforebegin', container_html);
            _this.cache.targetDom.setAttribute("readonly", "true");
            _this.cache.cont = _this.cache.targetDom.previousElementSibling;
            _this.result.slider = _this.cache.cont;
            _this.cache.cont.innerHTML = base_html;
            _this.cache.label = _this.cache.cont.querySelector(".ax-range-label");
            _this.cache.min = _this.cache.cont.querySelector(".ax-range-min");
            _this.cache.max = _this.cache.cont.querySelector(".ax-range-max");
            _this.cache.from = _this.cache.cont.querySelector(".ax-range-from");
            _this.cache.to = _this.cache.cont.querySelector(".ax-range-to");
            _this.cache.single = _this.cache.cont.querySelector(".ax-range-single");
            _this.cache.line = _this.cache.cont.querySelector(".ax-range-line");
            _this.cache.grid = _this.cache.cont.querySelector(".ax-range-grid");
            if (_this.options.type === "single") {
                _this.cache.cont.insertAdjacentHTML('beforeend', single_html);
                _this.cache.bar = _this.cache.cont.querySelector(".ax-range-bar");
                _this.cache.edge = _this.cache.cont.querySelector(".ax-range-bar-single");
                _this.cache.s_single = _this.cache.cont.querySelector(".ax-single");
                _this.cache.from.style.visibility = "hidden";
                _this.cache.to.style.visibility = "hidden";
                _this.cache.shad_single = _this.cache.cont.querySelector(".ax-shadow-single");
            } else {
                _this.cache.cont.insertAdjacentHTML('beforeend', double_html);
                _this.cache.bar = _this.cache.cont.querySelector(".ax-range-bar");
                _this.cache.s_from = _this.cache.cont.querySelector(".ax-from");
                _this.cache.s_to = _this.cache.cont.querySelector(".ax-to");
                _this.cache.shad_from = _this.cache.cont.querySelector(".ax-shadow-from");
                _this.cache.shad_to = _this.cache.cont.querySelector(".ax-shadow-to");
                setTopHandler();
            }
            if (_this.options.hideLabelSlider) {
                _this.cache.from.style.display = "none";
                _this.cache.to.style.display = "none";
                _this.cache.single.style.display = "none";
            }
            appendGrid();
            if (_this.options.disabled) {
                appendDisableMask();
                _this.cache.targetDom.disabled = true;
            } else {
                _this.cache.targetDom.disabled = false;
                removeDisableMask();
                bindEvents();
            }
            if (!_this.options.disabled) {
                if (_this.options.block) {
                    appendDisableMask();
                } else {
                    removeDisableMask();
                }
            }
            if (_this.options.dragInterval) {
                _this.cache.bar.style.cursor = "ew-resize";
            }
        };
        const setTopHandler = function () {
            const min = _this.options.min,
                max = _this.options.max,
                from = _this.options.from,
                to = _this.options.to;
            if (from > min && to === max) {
                _this.cache.s_from.classList.add("ax-last");
            } else if (to < max) {
                _this.cache.s_to.classList.add("ax-last");
            }
        };
        /**
         * Determine which handles was clicked last and which handler should have hover effect
         *
         * @param _this.target {String}
         */
        const changeLevel = function (target) {
            switch (_this.target) {
                case "single":
                    _this.coords.p_gap = toFixed(_this.coords.p_pointer - _this.coords.p_single_fake);
                    _this.cache.s_single.classList.add("ax-hover");
                    break;
                case "from":
                    _this.coords.p_gap = toFixed(_this.coords.p_pointer - _this.coords.p_from_fake);
                    _this.cache.s_from.classList.add("ax-hover", "ax-last");
                    _this.cache.s_to.classList.remove("ax-last");
                    break;
                case "to":
                    _this.coords.p_gap = toFixed(_this.coords.p_pointer - _this.coords.p_to_fake);
                    _this.cache.s_to.classList.add("ax-hover", "ax-last");
                    _this.cache.s_from.classList.remove("ax-last");
                    break;
                case "both":
                    _this.coords.p_gap_left = toFixed(_this.coords.p_pointer - _this.coords.p_from_fake);
                    _this.coords.p_gap_right = toFixed(_this.coords.p_to_fake - _this.coords.p_pointer);
                    _this.cache.s_to.classList.remove("ax-last");
                    _this.cache.s_from.classList.remove("ax-last");
                    break;
            }
        };
        /**
         * Then slider is disabled -> append extra layer with opacity
         */
        const appendDisableMask = function () {
            _this.cache.cont.insertAdjacentHTML('beforeend', disable_html);
            _this.cache.cont.classList.add("ax-disabled");
        };
        /**
         * Then slider is not disabled -> remove disable mask
         */
        const removeDisableMask = function () {
            _this.cache.cont.classList.remove(".ax-disabled-mask");
            _this.cache.cont.classList.remove("ax-disabled");
        };
        this.remove = function () {
            this.cache.cont.remove();
            this.cache.cont = null;
            this.cache.win.removeEventListener("keydown", key.bind(this, 'keyboard'));
            this.cache.body.removeEventListener("touchmove", pointerMove.bind(this));
            this.cache.body.removeEventListener("mousemove", pointerMove.bind(this));
            this.cache.win.removeEventListener("touchend", pointerUp.bind(this));
            this.cache.win.removeEventListener("mouseup", pointerUp.bind(this));
            this.cache.grid_labels = [];
            this.coords.big = [];
            this.coords.big_w = [];
            this.coords.big_p = [];
            this.coords.big_x = [];
            cancelAnimationFrame(this.rafId);
        };
        const bindEvents = function () {
            if (_this.noDiapason) {
                return;
            }
            _this.cache.body.addEventListener('touchmove', pointerMove.bind(this));
            _this.cache.body.addEventListener('mousemove', pointerMove.bind(this));
            _this.cache.win.addEventListener('touchend', pointerUp.bind(this));
            _this.cache.win.addEventListener('mouseup', pointerUp.bind(this));
            _this.cache.line.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
            _this.cache.line.addEventListener('mousedown', pointerClick.bind(this, 'click'));
            _this.cache.line.addEventListener('focus', pointerFocus.bind(this));
            if (_this.options.dragInterval && _this.options.type === "double") {
                _this.cache.bar.addEventListener('touchstart', pointerDown.bind(this, 'both'), { passive: true });
                _this.cache.bar.addEventListener('mousedown', pointerDown.bind(this, 'both'));
            } else {
                _this.cache.bar.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.bar.addEventListener('mousedown', pointerClick.bind(this, 'click'));
            }
            if (_this.options.type === "single") {
                _this.cache.single.addEventListener('touchstart', pointerDown.bind(this, 'single'), { passive: true });
                _this.cache.s_single.addEventListener('touchstart', pointerDown.bind(this, 'single'), { passive: true });
                _this.cache.shad_single.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.single.addEventListener('mousedown', pointerDown.bind(this, 'single'));
                _this.cache.s_single.addEventListener('mousedown', pointerDown.bind(this, 'single'));
                _this.cache.edge.addEventListener('mousedown', pointerClick.bind(this, 'click'));
                _this.cache.shad_single.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
            } else {
                _this.cache.single.addEventListener('touchstart', pointerDown.bind(this, null), { passive: true });
                _this.cache.single.addEventListener('mousedown', pointerDown.bind(this, null));
                _this.cache.from.addEventListener('touchstart', pointerDown.bind(this, 'from'), { passive: true });
                _this.cache.s_from.addEventListener('touchstart', pointerDown.bind(this, 'from'), { passive: true });
                _this.cache.to.addEventListener('touchstart', pointerDown.bind(this, 'to'), { passive: true });
                _this.cache.s_to.addEventListener('touchstart', pointerDown.bind(this, 'to'), { passive: true });
                _this.cache.shad_from.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.shad_to.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.from.addEventListener('mousedown', pointerDown.bind(this, 'from'));
                _this.cache.s_from.addEventListener('mousedown', pointerDown.bind(this, 'from'));
                _this.cache.to.addEventListener('mousedown', pointerDown.bind(this, 'to'));
                _this.cache.s_to.addEventListener('mousedown', pointerDown.bind(this, 'to'));
                _this.cache.shad_from.addEventListener('mousedown', pointerClick.bind(this, 'click'));
                _this.cache.shad_to.addEventListener('mousedown', pointerClick.bind(this, 'click'));
            }
            if (_this.options.keyboard) {
                _this.cache.line.addEventListener('keydown', key.bind(this, 'keyboard'));
            }
        };
        /**
         * Focus with tabIndex
         *
         * @param e {Object} event object
         */
        const pointerFocus = function (e) {
            if (!_this.target) {
                let x, $handle;
                if (_this.options.type === "single") {
                    $handle = _this.cache.single;
                } else {
                    $handle = _this.cache.from;
                }
                x = $handle.getBoundingClientRect().left;
                x += ($handle.getBoundingClientRect().width / 2) - 1;
                pointerClick("single", { preventDefault: function () { }, pageX: x });
            } else {
                _this.cache.line.focus();
            }
        };
        const pointerMove = function (e) {
            if (!_this.dragging) {
                return;
            }
            const x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX; 
            _this.coords.x_pointer = x - _this.coords.x_gap;
            calc();
        };
        const pointerUp = function (e) {
            if (_this.isActive) {
                _this.isActive = false;
            } else {
                return;
            }
            const hoverState = _this.cache.cont.querySelector(".ax-hover");
            if (hoverState) {
                hoverState.classList.remove("ax-hover");
            }
            _this.forceRedraw = true;
            updateScene();
            restoreOriginalMinInterval();
            if (_this.cache.cont.contains(e.target) || _this.dragging) {
                callOnFinish();
            }
            _this.dragging = false;
        };
        const pointerDown = function (destination, e) {
            axPreventDefault(e);
            const x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX; 
            if (e.button === 2) {
                return;
            }
            if (destination === "both") {
                setTempMinInterval();
            }
            if (!destination) {
                destination = _this.target || "from";
            }
            _this.target = destination;
            _this.isActive = true;
            _this.dragging = true;
            _this.coords.x_gap = _this.cache.label.getBoundingClientRect().left;
            _this.coords.x_pointer = x - _this.coords.x_gap;
            calcPointerPercent();
            changeLevel(destination);
            _this.cache.line.dispatchEvent(new Event("focus"));
            updateScene();
        };
        const pointerClick = function (destination, e) {
            axPreventDefault(e);
            const x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX; 
            if (e.button === 2) {
                return;
            }
            _this.target = destination;
            _this.isClick = true;
            _this.coords.x_gap = _this.cache.label.getBoundingClientRect().left;
            _this.coords.x_pointer = +(x - _this.coords.x_gap).toFixed();
            _this.forceRedraw = true;
            calc();
            _this.cache.line.dispatchEvent(new Event("focus"));
        };
        const key = function (destination, e) {
            if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                return;
            }
            switch (e.which) {
                case 83: 
                case 65: 
                case 40: 
                case 37: 
                axPreventDefault(e);
                    moveByKey(false);
                    break;
                case 87: 
                case 68: 
                case 38: 
                case 39: 
                axPreventDefault(e);
                    moveByKey(true);
                    break;
            }
        };
        const moveByKey = function (right) {
            let p = _this.coords.p_pointer;
            const p_step = _this.options.step / ((_this.options.max - _this.options.min) / 100);
            right ? p += p_step : p -= p_step;
            _this.coords.x_pointer = toFixed(_this.coords.w_rs / 100 * p);
            _this.isKey = true;
            calc();
        };
        const setMinMax = function () {
            if (!_this.options) {
                return;
            }
            if (_this.options.hideLabelTrack) {
                _this.cache.min.style.display = "none";
                _this.cache.max.style.display = "none";
                return;
            }
            if (_this.options.values.length) {
                _this.cache.min.innerHTML = decorate(_this.options.pValues[_this.options.min]);
                _this.cache.max.innerHTML = decorate(_this.options.pValues[_this.options.max]);
            } else {
                const min_pretty = _prettify(_this.options.min);
                const max_pretty = _prettify(_this.options.max);
                _this.result.min_pretty = min_pretty;
                _this.result.max_pretty = max_pretty;
                _this.cache.min.innerHTML = decorate(min_pretty, _this.options.min);
                _this.cache.max.innerHTML = decorate(max_pretty, _this.options.max);
            }
            _this.labels.w_min = _this.cache.min.offsetWidth;
            _this.labels.w_max = _this.cache.max.offsetWidth;
        };
        /**
         * Then _this.dragging interval, prevent interval collapsing
         * using min_interval option
         */
        const setTempMinInterval = function () {
            const interval = _this.result.to - _this.result.from;
            if (_this.oldMinInterval === null) {
                _this.oldMinInterval = _this.options.minInterval;
            }
            _this.options.minInterval = interval;
        };
        const restoreOriginalMinInterval = function () {
            if (_this.oldMinInterval !== null) {
                _this.options.minInterval = _this.oldMinInterval;
                _this.oldMinInterval = null;
            }
        };
        /**
         * All calculations and measures start here
         *
         * @param update {boolean=}
         */
        const calc = function (update) {
            if (!_this.options) {
                return;
            }
            _this.calcCount++;
            if (_this.calcCount === 10 || update) {
                _this.calcCount = 0;
                _this.coords.w_rs = _this.cache.label.offsetWidth;
                calcHandlePercent();
            }
            if (!_this.coords.w_rs) {
                return;
            }
            calcPointerPercent();
            let handle_x = getHandleX();
            if (_this.target === "both") {
                _this.coords.p_gap = 0;
                handle_x = getHandleX();
            }
            if (_this.target === "click") {
                _this.coords.p_gap = _this.coords.p_handle / 2;
                handle_x = getHandleX();
                if (_this.options.dragInterval) {
                    _this.target = "both_one";
                } else {
                    _this.target = chooseHandle(handle_x);
                }
            }
            switch (_this.target) {
                case "base":
                    const w = (_this.options.max - _this.options.min) / 100,
                        f = (_this.result.from - _this.options.min) / w,
                        t = (_this.result.to - _this.options.min) / w;
                    _this.coords.p_single_real = toFixed(f);
                    _this.coords.p_from_real = toFixed(f);
                    _this.coords.p_to_real = toFixed(t);
                    _this.coords.p_single_real = checkDiapason(_this.coords.p_single_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_single_fake = convertToFakePercent(_this.coords.p_single_real);
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    _this.target = null;
                    break;
                case "single":
                    if (_this.options.fromStick) {
                        break;
                    }
                    _this.coords.p_single_real = convertToRealPercent(handle_x);
                    _this.coords.p_single_real = calcWithStep(_this.coords.p_single_real);
                    _this.coords.p_single_real = checkDiapason(_this.coords.p_single_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_single_fake = convertToFakePercent(_this.coords.p_single_real);
                    break;
                case "from":
                    if (_this.options.fromStick) {
                        break;
                    }
                    _this.coords.p_from_real = convertToRealPercent(handle_x);
                    _this.coords.p_from_real = calcWithStep(_this.coords.p_from_real);
                    if (_this.coords.p_from_real > _this.coords.p_to_real) {
                        _this.coords.p_from_real = _this.coords.p_to_real;
                    }
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_real = checkMinInterval(_this.coords.p_from_real, _this.coords.p_to_real, "from");
                    _this.coords.p_from_real = checkMaxInterval(_this.coords.p_from_real, _this.coords.p_to_real, "from");
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    break;
                case "to":
                    if (_this.options.toStick) {
                        break;
                    }
                    _this.coords.p_to_real = convertToRealPercent(handle_x);
                    _this.coords.p_to_real = calcWithStep(_this.coords.p_to_real);
                    if (_this.coords.p_to_real < _this.coords.p_from_real) {
                        _this.coords.p_to_real = _this.coords.p_from_real;
                    }
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_to_real = checkMinInterval(_this.coords.p_to_real, _this.coords.p_from_real, "to");
                    _this.coords.p_to_real = checkMaxInterval(_this.coords.p_to_real, _this.coords.p_from_real, "to");
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    break;
                case "both":
                    if (_this.options.fromStick || _this.options.toStick) {
                        break;
                    }
                    handle_x = toFixed(handle_x + (_this.coords.p_handle * 0.001));
                    _this.coords.p_from_real = convertToRealPercent(handle_x) - _this.coords.p_gap_left;
                    _this.coords.p_from_real = calcWithStep(_this.coords.p_from_real);
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_real = checkMinInterval(_this.coords.p_from_real, _this.coords.p_to_real, "from");
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    _this.coords.p_to_real = convertToRealPercent(handle_x) + _this.coords.p_gap_right;
                    _this.coords.p_to_real = calcWithStep(_this.coords.p_to_real);
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_to_real = checkMinInterval(_this.coords.p_to_real, _this.coords.p_from_real, "to");
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    break;
                case "both_one":
                    if (_this.options.fromStick || _this.options.toStick) {
                        break;
                    }
                    const real_x = convertToRealPercent(handle_x),
                        from = _this.result.from_percent,
                        to = _this.result.to_percent,
                        full = to - from,
                        half = full / 2;
                    let new_from = real_x - half,
                        new_to = real_x + half;
                    if (new_from < 0) {
                        new_from = 0;
                        new_to = new_from + full;
                    }
                    if (new_to > 100) {
                        new_to = 100;
                        new_from = new_to - full;
                    }
                    _this.coords.p_from_real = calcWithStep(new_from);
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    _this.coords.p_to_real = calcWithStep(new_to);
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    break;
            }
            if (_this.options.type === "single") {
                _this.coords.p_bar_x = (_this.coords.p_handle / 2);
                _this.coords.p_bar_w = _this.coords.p_single_fake;
                _this.result.from_percent = _this.coords.p_single_real;
                _this.result.from = convertToValue(_this.coords.p_single_real);
                _this.result.from_pretty = _prettify(_this.result.from);
                if (_this.options.values.length) {
                    _this.result.from_value = _this.options.values[_this.result.from];
                }
            } else {
                _this.coords.p_bar_x = toFixed(_this.coords.p_from_fake + (_this.coords.p_handle / 2));
                _this.coords.p_bar_w = toFixed(_this.coords.p_to_fake - _this.coords.p_from_fake);
                _this.result.from_percent = _this.coords.p_from_real;
                _this.result.from = convertToValue(_this.coords.p_from_real);
                _this.result.from_pretty = _prettify(_this.result.from);
                _this.result.to_percent = _this.coords.p_to_real;
                _this.result.to = convertToValue(_this.coords.p_to_real);
                _this.result.to_pretty = _prettify(_this.result.to);
                if (_this.options.values.length) {
                    _this.result.from_value = _this.options.values[_this.result.from];
                    _this.result.to_value = _this.options.values[_this.result.to];
                }
            }
            calcMinMax();
            calcLabels();
        };
        /**
         * calculates pointer X in percent
         */
        const calcPointerPercent = function () {
            if (!_this.coords.w_rs) {
                _this.coords.p_pointer = 0;
                return;
            }
            if (_this.coords.x_pointer < 0 || isNaN(_this.coords.x_pointer)) {
                _this.coords.x_pointer = 0;
            } else if (_this.coords.x_pointer > _this.coords.w_rs) {
                _this.coords.x_pointer = _this.coords.w_rs;
            }
            _this.coords.p_pointer = toFixed(_this.coords.x_pointer / _this.coords.w_rs * 100);
        };
        const convertToRealPercent = function (fake) {
            const full = 100 - _this.coords.p_handle;
            return fake / full * 100;
        };
        const convertToFakePercent = function (real) {
            const full = 100 - _this.coords.p_handle;
            return real / 100 * full;
        };
        const getHandleX = function () {
            const max = 100 - _this.coords.p_handle;
            let x = toFixed(_this.coords.p_pointer - _this.coords.p_gap);
            if (x < 0) {
                x = 0;
            } else if (x > max) {
                x = max;
            }
            return x;
        };
        const calcHandlePercent = function () {
            if (_this.options.type === "single") {
                _this.coords.w_handle = _this.cache.s_single.offsetWidth;
            } else {
                _this.coords.w_handle = _this.cache.s_from.offsetWidth;
            }
            _this.coords.p_handle = toFixed(_this.coords.w_handle / _this.coords.w_rs * 100);
        };
        /**
         * Find closest handle to pointer click
         *
         * @param real_x {Number}
         * @returns {String}
         */
        const chooseHandle = function (real_x) {
            if (_this.options.type === "single") {
                return "single";
            } else {
                const m_point = _this.coords.p_from_real + ((_this.coords.p_to_real - _this.coords.p_from_real) / 2);
                if (real_x >= m_point) {
                    return _this.options.toStick ? "from" : "to";
                } else {
                    return _this.options.fromStick ? "to" : "from";
                }
            }
        };
        /**
         * Measure Min and Max labels width in percent
         */
        const calcMinMax = function () {
            if (!_this.coords.w_rs) {
                return;
            }
            _this.labels.p_min = _this.labels.w_min / _this.coords.w_rs * 100;
            _this.labels.p_max = _this.labels.w_max / _this.coords.w_rs * 100;
        };
        /**
         * Measure labels width and X in percent
         */
        const calcLabels = function () {
            if (!_this.coords.w_rs || _this.options.hideLabelSlider) {
                return;
            }
            if (_this.options.type === "single") {
                _this.labels.w_single = _this.cache.single.offsetWidth;
                _this.labels.p_single_fake = _this.labels.w_single / _this.coords.w_rs * 100;
                _this.labels.p_single_left = _this.coords.p_single_fake + (_this.coords.p_handle / 2) - (_this.labels.p_single_fake / 2);
                _this.labels.p_single_left = checkEdges(_this.labels.p_single_left, _this.labels.p_single_fake);
            } else {
                _this.labels.w_from = _this.cache.from.offsetWidth;
                _this.labels.p_from_fake = _this.labels.w_from / _this.coords.w_rs * 100;
                _this.labels.p_from_left = _this.coords.p_from_fake + (_this.coords.p_handle / 2) - (_this.labels.p_from_fake / 2);
                _this.labels.p_from_left = toFixed(_this.labels.p_from_left);
                _this.labels.p_from_left = checkEdges(_this.labels.p_from_left, _this.labels.p_from_fake);
                _this.labels.w_to = _this.cache.to.offsetWidth;
                _this.labels.p_to_fake = _this.labels.w_to / _this.coords.w_rs * 100;
                _this.labels.p_to_left = _this.coords.p_to_fake + (_this.coords.p_handle / 2) - (_this.labels.p_to_fake / 2);
                _this.labels.p_to_left = toFixed(_this.labels.p_to_left);
                _this.labels.p_to_left = checkEdges(_this.labels.p_to_left, _this.labels.p_to_fake);
                _this.labels.w_single = _this.cache.single.offsetWidth;
                _this.labels.p_single_fake = _this.labels.w_single / _this.coords.w_rs * 100;
                _this.labels.p_single_left = ((_this.labels.p_from_left + _this.labels.p_to_left + _this.labels.p_to_fake) / 2) - (_this.labels.p_single_fake / 2);
                _this.labels.p_single_left = toFixed(_this.labels.p_single_left);
                _this.labels.p_single_left = checkEdges(_this.labels.p_single_left, _this.labels.p_single_fake);
            }
        };
        /**
         * Main function called in request animation frame
         * to update everything
         */
        const updateScene = function () {
            if (_this.rafId) {
                cancelAnimationFrame(_this.rafId);
                _this.rafId = null;
            }
            clearTimeout(_this.updateTm);
            _this.updateTm = null;
            if (!_this.options) {
                return;
            }
            drawHandles();
            if (_this.isActive) {
                _this.rafId = requestAnimationFrame(updateScene);
            } else {
                _this.updateTm = setTimeout(updateScene, 300);
            }
        };
        /**
         * Draw handles
         */
        const drawHandles = function () {
            _this.coords.w_rs = _this.cache.label.offsetWidth;
            if (!_this.coords.w_rs) {
                return;
            }
            if (_this.coords.w_rs !== _this.coords.w_rs_old) {
                _this.target = "base";
                _this.isResize = true;
            }
            if (_this.coords.w_rs !== _this.coords.w_rs_old || _this.forceRedraw) {
                setMinMax();
                calc(true);
                drawLabels();
                if (_this.options.grid) {
                    calcGridMargin();
                    calcGridLabels();
                }
                _this.forceRedraw = true;
                _this.coords.w_rs_old = _this.coords.w_rs;
                drawShadow();
            }
            if (!_this.coords.w_rs) {
                return;
            }
            if (!_this.dragging && !_this.forceRedraw && !_this.isKey) {
                return;
            }
            if (_this.oldFrom !== _this.result.from || _this.oldTo !== _this.result.to || _this.forceRedraw || _this.isKey) {
                drawLabels();
                _this.cache.bar.style.left = _this.coords.p_bar_x + "%";
                _this.cache.bar.style.width = _this.coords.p_bar_w + "%";
                if (_this.options.type === "single") {
                    _this.cache.bar.style.left = "0";
                    _this.cache.bar.style.width = _this.coords.p_bar_w + _this.coords.p_bar_x + "%";
                    _this.cache.s_single.style.left = _this.coords.p_single_fake + "%";
                    _this.cache.single.style.left = _this.labels.p_single_left + "%";
                } else {
                    _this.cache.s_from.style.left = _this.coords.p_from_fake + "%";
                    _this.cache.s_to.style.left = _this.coords.p_to_fake + "%";
                    if (_this.oldFrom !== _this.result.from || _this.forceRedraw) {
                        _this.cache.from.style.left = _this.labels.p_from_left + "%";
                    }
                    if (_this.oldTo !== _this.result.to || _this.forceRedraw) {
                        _this.cache.to.style.left = _this.labels.p_to_left + "%";
                    }
                    _this.cache.single.style.left = _this.labels.p_single_left + "%";
                }
                writeToInput();
                if ((_this.oldFrom !== _this.result.from || _this.oldTo !== _this.result.to) && !_this.isStart) {
                    _this.cache.targetDom.dispatchEvent(new Event("change"));
                    _this.cache.targetDom.dispatchEvent(new Event("input"));
                }
                _this.oldFrom = _this.result.from;
                _this.oldTo = _this.result.to;
                if (!_this.isResize && !_this.isUpdate && !_this.isStart && !_this.isFinish) {
                    callOnChange();
                }
                if (_this.isKey || _this.isClick) {
                    _this.isKey = false;
                    _this.isClick = false;
                    callOnFinish();
                }
                _this.isUpdate = false;
                _this.isResize = false;
                _this.isFinish = false;
            }
            _this.isStart = false;
            _this.isKey = false;
            _this.isClick = false;
            _this.forceRedraw = false;
        };
        /**
         * Draw labels
         * measure labels collisions
         * collapse close labels
         */
        const drawLabels = function () {
            if (!_this.options) {
                return;
            }
            const values_num = _this.options.values.length,
                p_values = _this.options.pValues;
            let text_single,
                text_from,
                text_to,
                from_pretty,
                to_pretty;
            if (_this.options.hideLabelSlider) {
                return;
            }
            if (_this.options.type === "single") {
                if (values_num) {
                    text_single = decorate(p_values[_this.result.from]);
                    _this.cache.single.innerHTML = text_single;
                } else {
                    from_pretty = _prettify(_this.result.from);
                    text_single = decorate(from_pretty, _this.result.from);
                    _this.cache.single.innerHTML = text_single;
                }
                calcLabels();
                if (_this.labels.p_single_left < _this.labels.p_min + 1) {
                    _this.cache.min.style.visibility = "hidden";
                } else {
                    _this.cache.min.style.visibility = "visible";
                }
                if (_this.labels.p_single_left + _this.labels.p_single_fake > 100 - _this.labels.p_max - 1) {
                    _this.cache.max.style.visibility = "hidden";
                } else {
                    _this.cache.max.style.visibility = "visible";
                }
            } else {
                if (values_num) {
                    if (_this.options.decorateBoth) {
                        text_single = decorate(p_values[_this.result.from]);
                        text_single += _this.options.valuesSeparator;
                        text_single += decorate(p_values[_this.result.to]);
                    } else {
                        text_single = decorate(p_values[_this.result.from] + _this.options.valuesSeparator + p_values[_this.result.to]);
                    }
                    text_from = decorate(p_values[_this.result.from]);
                    text_to = decorate(p_values[_this.result.to]);
                    _this.cache.single.innerHTML = text_single;
                    _this.cache.from.innerHTML = text_from;
                    _this.cache.to.innerHTML = text_to;
                } else {
                    from_pretty = _prettify(_this.result.from);
                    to_pretty = _prettify(_this.result.to);
                    if (_this.options.decorateBoth) {
                        text_single = decorate(from_pretty, _this.result.from);
                        text_single += _this.options.valuesSeparator;
                        text_single += decorate(to_pretty, _this.result.to);
                    } else {
                        text_single = decorate(from_pretty + _this.options.valuesSeparator + to_pretty, _this.result.to);
                    }
                    text_from = decorate(from_pretty, _this.result.from);
                    text_to = decorate(to_pretty, _this.result.to);
                    _this.cache.single.innerHTML = text_single;
                    _this.cache.from.innerHTML = text_from;
                    _this.cache.to.innerHTML = text_to;
                }
                calcLabels();
                const min = Math.min(_this.labels.p_single_left, _this.labels.p_from_left),
                    single_left = _this.labels.p_single_left + _this.labels.p_single_fake,
                    to_left = _this.labels.p_to_left + _this.labels.p_to_fake;
                let max = Math.max(single_left, to_left);
                if (_this.labels.p_from_left + _this.labels.p_from_fake >= _this.labels.p_to_left) {
                    _this.cache.from.style.visibility = "hidden";
                    _this.cache.to.style.visibility = "hidden";
                    _this.cache.single.style.visibility = "visible";
                    if (_this.result.from === _this.result.to) {
                        if (_this.target === "from") {
                            _this.cache.from.style.visibility = "visible";
                        } else if (_this.target === "to") {
                            _this.cache.to.style.visibility = "visible";
                        } else if (!_this.target) {
                            _this.cache.from.style.visibility = "visible";
                        }
                        _this.cache.single.style.visibility = "hidden";
                        max = to_left;
                    } else {
                        _this.cache.from.style.visibility = "hidden";
                        _this.cache.to.style.visibility = "hidden";
                        _this.cache.single.style.visibility = "visible";
                        max = Math.max(single_left, to_left);
                    }
                } else {
                    _this.cache.from.style.visibility = "visible";
                    _this.cache.to.style.visibility = "visible";
                    _this.cache.single.style.visibility = "hidden";
                }
                min < _this.labels.p_min + 1 ? _this.cache.min.style.visibility = "hidden" : _this.cache.min.style.visibility = "visible";
                max > 100 - _this.labels.p_max - 1 ? _this.cache.max.style.visibility = "hidden" : _this.cache.max.style.visibility = "visible";
            }
        };
        /**
         * Draw shadow intervals
         */
        const drawShadow = function () {
            const o = _this.options,
                c = _this.cache,
                is_from_min = typeof o.fromMin === "number" && !isNaN(o.fromMin),
                is_from_max = typeof o.fromMax === "number" && !isNaN(o.fromMax),
                is_to_min = typeof o.toMin === "number" && !isNaN(o.toMin),
                is_to_max = typeof o.toMax === "number" && !isNaN(o.toMax);
            let from_min,
                from_max,
                to_min,
                to_max;
            if (o.type === "single") {
                if (o.fromShadow && (is_from_min || is_from_max)) {
                    from_min = convertToPercent(is_from_min ? o.fromMin : o.min);
                    from_max = convertToPercent(is_from_max ? o.fromMax : o.max) - from_min;
                    from_min = toFixed(from_min - (_this.coords.p_handle / 100 * from_min));
                    from_max = toFixed(from_max - (_this.coords.p_handle / 100 * from_max));
                    from_min = from_min + (_this.coords.p_handle / 2);
                    c.shad_single.style.display = "block";
                    c.shad_single.style.left = from_min + "%";
                    c.shad_single.style.width = from_max + "%";
                } else {
                    c.shad_single.style.display = "none";
                }
            } else {
                if (o.fromShadow && (is_from_min || is_from_max)) {
                    from_min = convertToPercent(is_from_min ? o.fromMin : o.min);
                    from_max = convertToPercent(is_from_max ? o.fromMax : o.max) - from_min;
                    from_min = toFixed(from_min - (_this.coords.p_handle / 100 * from_min));
                    from_max = toFixed(from_max - (_this.coords.p_handle / 100 * from_max));
                    from_min = from_min + (_this.coords.p_handle / 2);
                    c.shad_from.style.display = "block";
                    c.shad_from.style.left = from_min + "%";
                    c.shad_from.style.width = from_max + "%";
                } else {
                    c.shad_from.style.display = "none";
                }
                if (o.toShadow && (is_to_min || is_to_max)) {
                    to_min = convertToPercent(is_to_min ? o.toMin : o.min);
                    to_max = convertToPercent(is_to_max ? o.toMax : o.max) - to_min;
                    to_min = toFixed(to_min - (_this.coords.p_handle / 100 * to_min));
                    to_max = toFixed(to_max - (_this.coords.p_handle / 100 * to_max));
                    to_min = to_min + (_this.coords.p_handle / 2);
                    c.shad_to.style.display = "block";
                    c.shad_to.style.left = to_min + "%";
                    c.shad_to.style.width = to_max + "%";
                } else {
                    c.shad_to.style.display = "none";
                }
            }
        };
        /**
         * Write values to input targetDom
         */
        const writeToInput = function () {
            if (_this.options.type === "single") {
                if (_this.options.values.length) {
                    _this.cache.targetDom.setAttribute("value", _this.result.from_value);
                } else {
                    _this.cache.targetDom.setAttribute("value", _this.result.from);
                }
                _this.cache.targetDom.dataset.from = _this.result.from;
            } else {
                if (_this.options.values.length) {
                    _this.cache.targetDom.setAttribute("value", _this.result.from_value + _this.options.inputValuesSeparator + _this.result.to_value);
                } else {
                    _this.cache.targetDom.setAttribute("value", _this.result.from + _this.options.inputValuesSeparator + _this.result.to);
                }
                _this.cache.targetDom.dataset.from = _this.result.from;
                _this.cache.targetDom.dataset.to = _this.result.to;
            }
        };
        const callOnStart = function () {
            writeToInput();
            if (_this.options.onStart && typeof _this.options.onStart === "function") {
                if (_this.options.scope) {
                    _this.options.onStart.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onStart(_this.result);
                }
            }
        };
        const callOnChange = function () {
            writeToInput();
            if (_this.options.onChange && typeof _this.options.onChange === "function") {
                if (_this.options.scope) {
                    _this.options.onChange.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onChange(_this.result);
                }
            }
        };
        const callOnFinish = function () {
            writeToInput();
            if (_this.options.onFinish && typeof _this.options.onFinish === "function") {
                if (_this.options.scope) {
                    _this.options.onFinish.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onFinish(_this.result);
                }
            }
        };
        const callOnUpdate = function () {
            writeToInput();
            if (_this.options.onUpdate && typeof _this.options.onUpdate === "function") {
                if (_this.options.scope) {
                    _this.options.onUpdate.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onUpdate(_this.result);
                }
            }
        };
        this.toggleInput = function () {
            this.cache.targetDom.classList.toggle("ax-range-input");
            if (this.hasTabIndex) {
                this.cache.targetDom.setAttribute("tabindex", "-1");
            } else {
                this.cache.targetDom.removeAttribute("tabindex");
            }
            this.hasTabIndex = !this.hasTabIndex;
        };
        /**
         * Convert real value to percent
         *
         * @param value {Number} X in real
         * @param no_min {boolean=} don't use min value
         * @returns {Number} X in percent
         */
        const convertToPercent = function (value, no_min) {
            let diapason = _this.options.max - _this.options.min,
                one_percent = diapason / 100,
                val, percent;
            if (!diapason) {
                _this.noDiapason = true;
                return 0;
            }
            if (no_min) {
                val = value;
            } else {
                val = value - _this.options.min;
            }
            percent = val / one_percent;
            return toFixed(percent);
        };
        /**
         * Convert percent to real values
         *
         * @param percent {Number} X in percent
         * @returns {Number} X in real
         */
        const convertToValue = function (percent) {
            let min = _this.options.min,
                max = _this.options.max,
                min_decimals = min.toString().split(".")[1],
                max_decimals = max.toString().split(".")[1],
                min_length, max_length,
                avg_decimals = 0,
                abs = 0;
            if (percent === 0) {
                return _this.options.min;
            }
            if (percent === 100) {
                return _this.options.max;
            }
            if (min_decimals) {
                min_length = min_decimals.length;
                avg_decimals = min_length;
            }
            if (max_decimals) {
                max_length = max_decimals.length;
                avg_decimals = max_length;
            }
            if (min_length && max_length) {
                avg_decimals = (min_length >= max_length) ? min_length : max_length;
            }
            if (min < 0) {
                abs = Math.abs(min);
                min = +(min + abs).toFixed(avg_decimals);
                max = +(max + abs).toFixed(avg_decimals);
            }
            let number = ((max - min) / 100 * percent) + min,
                string = _this.options.step.toString().split(".")[1],
                _result;
            if (string) {
                number = +number.toFixed(string.length);
            } else {
                number = number / _this.options.step;
                number = number * _this.options.step;
                number = +number.toFixed(0);
            }
            if (abs) {
                number -= abs;
            }
            string ? _result = +number.toFixed(string.length) : _result = toFixed(number);
            if (_result < _this.options.min) {
                _result = _this.options.min;
            } else if (_result > _this.options.max) {
                _result = _this.options.max;
            }
            return _result;
        };
        /**
         * Round percent value with step
         *
         * @param percent {Number}
         * @returns percent {Number} rounded
         */
        const calcWithStep = function (percent) {
            let rounded = Math.round(percent / _this.coords.p_step) * _this.coords.p_step;
            if (rounded > 100) {
                rounded = 100;
            }
            if (percent === 100) {
                rounded = 100;
            }
            return toFixed(rounded);
        };
        const checkMinInterval = function (p_current, p_next, type) {
            let o = _this.options, current, next;
            if (!o.minInterval) {
                return p_current;
            }
            current = convertToValue(p_current);
            next = convertToValue(p_next);
            if (type === "from") {
                if (next - current < o.minInterval) {
                    current = next - o.minInterval;
                }
            } else {
                if (current - next < o.minInterval) {
                    current = next + o.minInterval;
                }
            }
            return convertToPercent(current);
        };
        const checkMaxInterval = function (p_current, p_next, type) {
            let o = _this.options, current, next;
            if (!o.maxInterval) {
                return p_current;
            }
            current = convertToValue(p_current);
            next = convertToValue(p_next);
            if (type === "from") {
                if (next - current > o.maxInterval) {
                    current = next - o.maxInterval;
                }
            } else {
                if (current - next > o.maxInterval) {
                    current = next + o.maxInterval;
                }
            }
            return convertToPercent(current);
        };
        const checkDiapason = function (p_num, min, max) {
            let num = convertToValue(p_num);
            typeof min !== 'number' ? min = _this.options.min : min;
            typeof max !== 'number' ? max = _this.options.max : max;
            num < min ? num = min : num;
            num > max ? num = max : num;
            return convertToPercent(num);
        };
        const toFixed = function (num) {
            num = num.toFixed(20);
            return +num;
        };
        const _prettify = function (num) {
            if (!_this.options.prettifyEnabled) {
                return num;
            }
            if (_this.options.prettify && typeof _this.options.prettify === "function") {
                return _this.options.prettify(num);
            } else {
                return prettify(num);
            }
        };
        const prettify = function (num) {
            return num.toString().replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, "$1" + _this.options.prettifySeparator);
        };
        const checkEdges = function (left, width) {
            if (!_this.options.forceEdges) return toFixed(left);
            left < 0 ? left = 0 : left > 100 - width ? left = 100 - width : left;
            return toFixed(left);
        };
        this.validate = function () {
            let o = this.options,
                r = this.result,
                v = o.values,
                vl = v.length,
                value,
                i;
            if (typeof o.min === "string") o.min = +o.min;
            if (typeof o.max === "string") o.max = +o.max;
            if (typeof o.from === "string") o.from = +o.from;
            if (typeof o.to === "string") o.to = +o.to;
            if (typeof o.step === "string") o.step = +o.step;
            if (typeof o.fromMin === "string") o.fromMin = +o.fromMin;
            if (typeof o.fromMax === "string") o.fromMax = +o.fromMax;
            if (typeof o.toMin === "string") o.toMin = +o.toMin;
            if (typeof o.toMax === "string") o.toMax = +o.toMax;
            if (typeof o.gridNum === "string") o.gridNum = +o.gridNum;
            if (o.max < o.min) {
                o.max = o.min;
            }
            if (vl) {
                o.pValues = [];
                o.min = 0;
                o.max = vl - 1;
                o.step = 1;
                o.gridNum = o.max;
                o.gridSnap = true;
                for (i = 0; i < vl; i++) {
                    value = +v[i];
                    if (!isNaN(value)) {
                        v[i] = value;
                        value = _prettify(value);
                    } else {
                        value = v[i];
                    }
                    o.pValues.push(value);
                }
            }
            if (typeof o.from !== "number" || isNaN(o.from)) o.from = o.min;
            if (typeof o.to !== "number" || isNaN(o.to)) o.to = o.max;
            if (o.type === "single") {
                if (o.from < o.min) o.from = o.min;
                if (o.from > o.max) o.from = o.max;
            } else {
                if (o.from < o.min) o.from = o.min;
                if (o.from > o.max) o.from = o.max;
                if (o.to < o.min) o.to = o.min;
                if (o.to > o.max) o.to = o.max;
                if (_this.update_check.from) {
                    if (_this.update_check.from !== o.from) {
                        if (o.from > o.to) o.from = o.to;
                    }
                    if (_this.update_check.to !== o.to) {
                        if (o.to < o.from) o.to = o.from;
                    }
                }
                if (o.from > o.to) o.from = o.to;
                if (o.to < o.from) o.to = o.from;
            }
            if (typeof o.step !== "number" || isNaN(o.step) || !o.step || o.step < 0) {
                o.step = 1;
            }
            if (typeof o.fromMin === "number" && o.from < o.fromMin) {
                o.from = o.fromMin;
            }
            if (typeof o.fromMax === "number" && o.from > o.fromMax) {
                o.from = o.fromMax;
            }
            if (typeof o.toMin === "number" && o.to < o.toMin) {
                o.to = o.toMin;
            }
            if (typeof o.toMax === "number" && o.from > o.toMax) {
                o.to = o.toMax;
            }
            if (r) {
                if (r.min !== o.min) r.min = o.min;
                if (r.max !== o.max) r.max = o.max;
                if (r.from < r.min || r.from > r.max) r.from = o.from;
                if (r.to < r.min || r.to > r.max) r.to = o.to;
            }
            if (typeof o.minInterval !== "number" || isNaN(o.minInterval) || !o.minInterval || o.minInterval < 0) {
                o.minInterval = 0;
            }
            if (typeof o.maxInterval !== "number" || isNaN(o.maxInterval) || !o.maxInterval || o.maxInterval < 0) {
                o.maxInterval = 0;
            }
            if (o.minInterval && o.minInterval > o.max - o.min) {
                o.minInterval = o.max - o.min;
            }
            if (o.maxInterval && o.maxInterval > o.max - o.min) {
                o.maxInterval = o.max - o.min;
            }
        };
        const decorate = function (num, original) {
            let decorated = "",
                o = _this.options;
            if (o.prefix) {
                decorated += o.prefix;
            }
            decorated += num;
            if (o.maxPostfix) {
                if (o.values.length && num === o.pValues[o.max]) {
                    decorated += o.maxPostfix;
                    if (o.postfix) {
                        decorated += " ";
                    }
                } else if (original === o.max) {
                    decorated += o.maxPostfix;
                    if (o.postfix) {
                        decorated += " ";
                    }
                }
            }
            if (o.postfix) {
                decorated += o.postfix;
            }
            return decorated;
        };
        const updateFrom = function () {
            _this.result.from = _this.options.from;
            _this.result.from_percent = convertToPercent(_this.result.from);
            _this.result.from_pretty = _prettify(_this.result.from);
            if (_this.options.values) {
                _this.result.from_value = _this.options.values[_this.result.from];
            }
        };
        const updateTo = function () {
            _this.result.to = _this.options.to;
            _this.result.to_percent = convertToPercent(_this.result.to);
            _this.result.to_pretty = _prettify(_this.result.to);
            if (_this.options.values) {
                _this.result.to_value = _this.options.values[_this.result.to];
            }
        };
        this.updateResult = function () {
            this.result.min = this.options.min;
            this.result.max = this.options.max;
            updateFrom();
            updateTo();
        };
        const appendGrid = function () {
            if (!_this.options.grid) {
                return;
            }
            let o = _this.options,
                i, z,
                total = o.max - o.min,
                big_num = o.gridNum,
                big_p = 0,
                big_w = 0,
                small_max = 4,
                local_small_max,
                small_p,
                small_w = 0,
                _result,
                html = '';
            calcGridMargin();
            if (o.gridSnap) {
                big_num = total / o.step;
            }
            if (big_num > 50) big_num = 50;
            big_p = toFixed(100 / big_num);
            if (big_num > 4) {
                small_max = 3;
            }
            if (big_num > 7) {
                small_max = 2;
            }
            if (big_num > 14) {
                small_max = 1;
            }
            if (big_num > 28) {
                small_max = 0;
            }
            for (i = 0; i < big_num + 1; i++) {
                local_small_max = small_max;
                big_w = toFixed(big_p * i);
                if (big_w > 100) {
                    big_w = 100;
                }
                _this.coords.big[i] = big_w;
                small_p = (big_w - (big_p * (i - 1))) / (local_small_max + 1);
                for (z = 1; z <= local_small_max; z++) {
                    if (big_w === 0) {
                        break;
                    }
                    small_w = toFixed(big_w - (small_p * z));
                    html += '<span class="ax-range-grid-pol ax-small" style="left: ' + small_w + '%"></span>';
                }
                html += '<span class="ax-range-grid-pol" style="left: ' + big_w + '%"></span>';
                _result = convertToValue(big_w);
                if (o.values.length) {
                    _result = o.pValues[_result];
                } else {
                    _result = _prettify(_result);
                }
                html += '<span class="ax-range-grid-text ax-grid-text-' + i + '" style="left: ' + big_w + '%">' + _result + '</span>';
            }
            _this.coords.big_num = Math.ceil(big_num + 1);
            _this.cache.cont.classList.add("ax-with-grid");
            _this.cache.grid.innerHTML = html;
            cacheridLabels();
        };
        const cacheridLabels = function () {
            for (let i = 0; i < _this.coords.big_num; i++) {
                _this.cache.grid_labels.push(_this.cache.grid.querySelector(".ax-grid-text-" + i));
            }
            calcGridLabels();
        };
        const calcGridLabels = function () {
            const start = [], finish = [],
                num = _this.coords.big_num;
            for (let i = 0; i < num; i++) {
                _this.coords.big_w[i] = _this.cache.grid_labels[i].offsetWidth;
                _this.coords.big_p[i] = toFixed(_this.coords.big_w[i] / _this.coords.w_rs * 100);
                _this.coords.big_x[i] = toFixed(_this.coords.big_p[i] / 2);
                start[i] = toFixed(_this.coords.big[i] - _this.coords.big_x[i]);
                finish[i] = toFixed(start[i] + _this.coords.big_p[i]);
            }
            if (_this.options.forceEdges) {
                if (start[0] < -_this.coords.grid_gap) {
                    start[0] = -_this.coords.grid_gap;
                    finish[0] = toFixed(start[0] + _this.coords.big_p[0]);
                    _this.coords.big_x[0] = _this.coords.grid_gap;
                }
                if (finish[num - 1] > 100 + _this.coords.grid_gap) {
                    finish[num - 1] = 100 + _this.coords.grid_gap;
                    start[num - 1] = toFixed(finish[num - 1] - _this.coords.big_p[num - 1]);
                    _this.coords.big_x[num - 1] = toFixed(_this.coords.big_p[num - 1] - _this.coords.grid_gap);
                }
            }
            calcGridCollision(2, start, finish);
            calcGridCollision(4, start, finish);
            for (let i = 0; i < num; i++) {
                const label = _this.cache.grid_labels[i];
                if (_this.coords.big_x[i] !== Number.POSITIVE_INFINITY) {
                    label.style.marginLeft = -_this.coords.big_x[i] + "%";
                }
            }
        };
        const calcGridCollision = function (step, start, finish) {
            const num = _this.coords.big_num;
            for (let i = 0; i < num; i += step) {
                let next_i = i + (step / 2);
                if (next_i >= num) {
                    break;
                }
                const label = _this.cache.grid_labels[next_i];
                if (finish[i] <= start[next_i]) {
                    label.style.visibility = "visible";
                } else {
                    label.style.visibility = "hidden";
                }
            }
        };
        const calcGridMargin = function () {
            if (!_this.options.gridMargin) {
                return;
            }
            _this.coords.w_rs = _this.cache.label.offsetWidth;
            if (!_this.coords.w_rs) {
                return;
            }
            if (_this.options.type === "single") {
                _this.coords.w_handle = _this.cache.s_single.offsetWidth;
            } else {
                _this.coords.w_handle = _this.cache.s_from.offsetWidth;
            }
            _this.coords.p_handle = toFixed(_this.coords.w_handle / _this.coords.w_rs * 100);
            _this.coords.grid_gap = toFixed((_this.coords.p_handle / 2) - 0.1);
            _this.cache.grid.style.width = toFixed(100 - _this.coords.p_handle) + "%";
            _this.cache.grid.style.left = _this.coords.grid_gap + "%";
        };
        this.init();
    }
    init() {
        this.validate();
        this.ready();
        if (this.referName) {
            if (axIsEmpty(axRanges)) {
                axRanges.push({ name: this.referName, instance: this });
            } else {
                for (let i = 0; i < axRanges.length; i++) {
                    if (axRanges[i].name == this.referName) {
                        axRanges[i].instance = this;
                        break;
                    } else {
                        axRanges.push({ name: this.referName, instance: this });
                    }
                }
            }
        }
    }
    update(options, callback) {
        if (!this.targetDom) {
            return;
        }
        this.isUpdate = true;
        this.options.from = this.result.from;
        this.options.to = this.result.to;
        this.update_check.from = this.result.from;
        this.update_check.to = this.result.to;
        this.options = Object.assign(this.options, options);
        this.validate();
        this.updateResult(options);
        this.toggleInput();
        this.remove();
        this.ready(true);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    reset(callback) {
        if (!this.targetDom) {
            return;
        }
        this.updateResult();
        'reset' in this.handlers ? this.emit('reset', '') : null;
        callback && callback.call(this);
        this.update();
    }
    destroy(callback) {
        if (!this.targetDom) {
            return;
        }
        this.toggleInput();
        this.targetDom.removeAttribute("readonly");
        this.remove();
        this.targetDom = null;
        this.options = null;
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        callback && callback.call(this);
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axRange]').forEach(element => {
        new axRange(element);
    });
})();
/*!
 * 插件：分页；使用方法：new axPagination('#id',{参数})
 * 从现有的list中自动创建分页
 * 从已知的数组创建列表并分页
 * 可追加列表item数量并重新渲染分页
 * 分页节点能自动在列表下方创建，也可以在指定的dom创建
 */
class axPagination {
    constructor(targetDom, options) {
        this.options = axExtend({
            listDom: '',
            count: 10, 
            current: 1, 
            firstText: '首页', 
            prevText: '上一页', 
            nextText: '下一页', 
            lastText: '尾页', 
            allPages: false,
            data: [], 
            template: '', 
            type: 'regular', 
            loadingMode: 'replace',
            className: '',
            lastDel: '', 
            async: '',
            delay: 0,
            dataExtend: '',
            rendered: function (current, pagesNum) {
            }
        }, options, targetDom);
        this.targetExist = targetDom ? true : false;
        this.targetDom = targetDom ? axIdToDom(targetDom) : axAddElem('div', { class: this.options.className ? 'ax-pagination ' + this.options.className : 'ax-pagination' });
        if (this.dataType(this.options.data) == 'pageDom') {
            this.listDom = axIdToDom(this.options.data);
        } else if (this.options.listDom) {
            this.listDom = axIdToDom(this.options.listDom);
        } else {
            this.listDom = '';
        }
        this.handlers = {};
        this.preData = [];
        this.selectData = [];
        this.itemsNum = 0;
        this.pagesNum = 0;
        this.current = this.options.current;
        this.loadingDom = axAddElem('div', { class: 'ax-pageTurning' })
        if (!this.options.template) {
            this.template = '';
        } else {
            if (this.options.template.trim().substr(0, 1) == '#') {
                this.template = document.querySelector(this.options.template).innerHTML
            } else {
                this.template = this.options.template;
            }
        }
        this.pagesDom = axAddElem('div', { class: 'ax-core' });
        this.pageFirst = axAddElem('a', { href: '###', class: 'ax-first' }, this.options.firstText);
        this.pageLast = axAddElem('a', { href: '###', class: 'ax-last' }, this.options.lastText);
        this.pagePrev = axAddElem('a', { href: '###', class: 'ax-prev' }, this.options.prevText);
        this.pageNext = axAddElem('a', { href: '###', class: 'ax-next' }, this.options.nextText);
        this.pageTotal = axAddElem('span', { class: 'ax-total' });
        this.pageGo = axAddElem('span', { class: 'ax-gopage' });
        this.group = axAddElem('div', { class: 'ax-group' });
        this.init(this.options.data);
    }
    init(data) {
        let _this = this;
        if (axIsEmpty(data)) {
            this.listDom ? this.listDom.innerHTML = '' : null;
            this.targetDom.remove();
            this.current = 1;
            this.pagesNum = 1;
            this.itemsNum = 0;
            return false;
        }
        if (this.dataType(data) == 'json') {
            if (!_this.template) {
                console.error('The template is required!');
                return false;
            }
            this.jsonAjax(data, function () {
                this.listDom ? this.renderList(1) : null;
                this.renderFinish();
                _this.options.rendered && _this.options.rendered.call(_this, _this.current, _this.pagesNum)
                'rendered' in _this.handlers ? _this.emit('rendered', _this.current, _this.pagesNum) : null;
            });
        } else if (this.dataType(data) == 'sql') {
            if (!this.template) {
                console.error('The template is required!');
                return false;
            }
            this.sqlAjax(this.current, function () {
                this.listDom ? this.renderList(1) : null;
                this.renderFinish();
                _this.options.rendered && _this.options.rendered.call(_this, _this.current, _this.pagesNum)
                'rendered' in _this.handlers ? _this.emit('rendered', _this.current, _this.pagesNum) : null;
            });
        } else {
            if (this.dataType(data) == 'sortList') {
                data.forEach(i => {
                    this.preData.push(i.dom);
                });
            } else if (this.dataType(data) == 'pureNode') {
                this.preData = [...data];
            } else if (this.dataType(data) == 'tplArray') {
                if (!this.template) {
                    console.error('The template is required!');
                    return false;
                }
                data.forEach(i => {
                    let item = axStrToDom(axTplEngine(this.template, i));
                    this.preData.push(item);
                });
            } else {
                this.preData = [...this.listDom.childNodes].filter(item => item.nodeType == 1);
            }
            this.getCurrent(this.preData);
            this.listDom ? this.renderList(this.current) : null;
            this.renderFinish();
            this.options.rendered && this.options.rendered.call(this, this.current, this.pagesNum)
            'rendered' in this.handlers ? this.emit('rendered', this.current, this.pagesNum) : null;
        }
    }
    dataType(data) {
        let type = '';
        if (axType(data) == 'Array') {
            if (data[0].hasOwnProperty('dom')) {
                type = 'sortList';
            } else if (axType(data[0]).includes('Element')) {
                type = 'pureNode';
            } else {
                type = 'tplArray';
            }
        } else if (axType(data) == 'String') {
            if (this.options.async == 'json') {
                type = 'json';
            } else if (this.options.async == 'sql') {
                type = 'sql';
            } else {
                type = 'pageDom';
            }
        }
        return type;
    }
    renderFinish() {
        let _this = this;
        this.renderPages(this.current);
        this.getPagination();
        if(this.listDom && !this.targetExist){
            if(this.listDom.nodeName == 'TBODY'){
                this.listDom.parentElement.insertAdjacentElement('afterend', this.targetDom)
            }else{
                this.listDom.insertAdjacentElement('afterend', this.targetDom)
            }
        }
        this.pageFirst.onclick = function (e) {
            if (_this.current <= 1) {
                axPreventDefault(e);
            } else {
                _this.current = 1;
                _this.currentRender(_this.current);
            }
        }
        this.pageLast.onclick = function (e) {
            if (_this.current >= _this.pagesNum) {
                axPreventDefault(e);
            } else {
                _this.current = _this.pagesNum;
                _this.currentRender(_this.current);
            }
        }
        this.pagePrev.onclick = function (e) {
            if (_this.current <= 1) {
                axPreventDefault(e);
            } else {
                _this.current = _this.current - 1;
                _this.currentRender(_this.current);
            }
        }
        this.pageNext.onclick = function (e) {
            if (_this.current >= _this.pagesNum) {
                axPreventDefault(e);
            } else {
                _this.current = _this.current + 1;
                _this.currentRender(_this.current);
            }
        }
    }
    currentFix(current, pagesNum = this.pagesNum) {
        if (!current) {
            return this.current;
        }
        if (current <= 1) {
            this.current = 1;
        } else if (current >= pagesNum) {
            this.current = pagesNum;
        } else {
            this.current = current;
        }
        return this.current;
    }
    getCurrent(data, current, pagesNum, itemsNum) {
        this.itemsNum = itemsNum ? itemsNum : data.length;
        if (pagesNum) {
            this.pagesNum = pagesNum;
        } else {
            let divisor = this.itemsNum / this.options.count;
            this.pagesNum = divisor % 1 === 0 ? divisor : Math.floor(divisor) + 1;
        }
        this.currentFix(current ? current : this.current, this.pagesNum);
    }
    renderList(current) {
        let fragment = document.createDocumentFragment();
        this.selectData = this.preData.slice(this.options.count * (current - 1), this.options.count * current);
        this.selectData.forEach((item, index) => {
            if (index + 1 == this.selectData.length && this.options.lastDel && item.querySelector(this.options.lastDel)) {
                item.removeChild(item.querySelector(this.options.lastDel))
            }
            fragment.appendChild(item);
        });
        this.listDom.innerHTML = '';
        this.listDom.appendChild(fragment);
    }
    renderPages(current) {
        let _this = this;
        current = this.currentFix(current);
        this.pagesDom.innerHTML = ''
        if (this.options.allPages) {
            for (let i = 1; i <= this.pagesNum; i++) {
                let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                this.pagesDom.appendChild(item);
            }
        } else {
            if (this.pagesNum < 11) {
                for (let i = 1; i <= this.pagesNum; i++) {
                    let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                    this.pagesDom.appendChild(item);
                }
            } else {
                if (current < 6) {
                    for (let i = 1; i <= 8; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = this.pagesNum - 1; i <= this.pagesNum; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                } else if (this.pagesNum - current < 5) {
                    for (let i = 1; i <= 2; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = this.pagesNum - 6; i <= this.pagesNum; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                } else {
                    for (let i = 1; i <= 2; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = current - 2; i <= current + 2; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = this.pagesNum - 1; i <= this.pagesNum; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                }
            }
        }
        let pages = this.pagesDom.querySelectorAll('[data-page]');
        [...pages].forEach(item => {
            item.onclick = function () {
                _this.current = ~~item.dataset.page; 
                _this.currentRender(_this.current);
            }
        });
        this.setClass(current);
        return this.pagesDom;
    }
    setClass(current) {
        let pages = this.pagesDom.querySelectorAll('[data-page]'),
            page = [...pages].filter(item => ~~item.dataset.page == current)[0];
        page.classList.add('ax-active');
        if (~~page.dataset.page == 1) {
            this.pageFirst.classList.add('ax-disabled');
            this.pagePrev.classList.add('ax-disabled');
            if(this.pagesNum == 1){
                this.pageLast.classList.add('ax-disabled');
                this.pageNext.classList.add('ax-disabled');
            }else{
                this.pageLast.classList.remove('ax-disabled');
                this.pageNext.classList.remove('ax-disabled');
            }
        } else if (~~page.dataset.page == this.pagesNum) {
            this.pageLast.classList.add('ax-disabled');
            this.pageNext.classList.add('ax-disabled');
            this.pageFirst.classList.remove('ax-disabled');
            this.pagePrev.classList.remove('ax-disabled');
        } else {
            this.pageFirst.classList.remove('ax-disabled');
            this.pagePrev.classList.remove('ax-disabled');
            this.pageLast.classList.remove('ax-disabled');
            this.pageNext.classList.remove('ax-disabled');
        }
    }
    getPagination() {
        let _this = this;
        let fragment = document.createDocumentFragment();
        this.pageTotal.innerHTML = '共有' + this.pagesNum + '页, ' + this.itemsNum + '条数据';
        this.pageGo.innerHTML = '跳到</span><input type="text"><button type="button" class="ax-btn">确定</button>';
        let goInput = this.pageGo.querySelector('input'),
            goBtn = this.pageGo.querySelector('button');
        goBtn.onclick = function () {
            let val = ~~goInput.value;
            if (val <= 1) {
                console.warn('The value is out of range,it has been fixed!');
                goInput.value = 1;
                _this.current = 1;
            } else if (val >= _this.pagesNum) {
                console.warn('The value is out of range,it has been fixed!');
                goInput.value = _this.pagesNum;
                _this.current = _this.pagesNum;
            } else {
                _this.current = val;
            }
            _this.currentRender(_this.current);
        }
        goInput.onkeyup = function(e){
            if(e.keyCode == 13){
                goBtn.click();
            }
        }
        if (this.options.type == 'regular') {
            fragment.appendChild(this.pageFirst);
            fragment.appendChild(this.pagePrev);
            fragment.appendChild(this.pagesDom);
            fragment.appendChild(this.pageNext);
            fragment.appendChild(this.pageLast);
        } else if (this.options.type == 'group') {
            this.group.appendChild(this.pageFirst);
            this.group.appendChild(this.pagePrev);
            this.group.appendChild(this.pagesDom);
            this.group.appendChild(this.pageNext);
            this.group.appendChild(this.pageLast);
            fragment.appendChild(this.group);
        } else if (this.options.type == 'simple') {
            fragment.appendChild(this.pagePrev);
            fragment.appendChild(this.pageNext);
        } else if (this.options.type == 'full') {
            fragment.appendChild(this.pageFirst);
            fragment.appendChild(this.pagePrev);
            fragment.appendChild(this.pagesDom);
            fragment.appendChild(this.pageNext);
            fragment.appendChild(this.pageLast);
            fragment.appendChild(this.pageTotal);
            fragment.appendChild(this.pageGo);
        } else if (this.options.type == 'pagesRight') {
            let left = axAddElem('div'),
                right = axAddElem('div', { class: 'ax-col ax-align-right' });
            this.targetDom.classList.add('ax-row');
            left.appendChild(this.pageTotal);
            left.appendChild(this.pageGo);
            right.appendChild(this.pageFirst);
            right.appendChild(this.pagePrev);
            right.appendChild(this.pagesDom);
            right.appendChild(this.pageNext);
            right.appendChild(this.pageLast);
            fragment.appendChild(left);
            fragment.appendChild(right);
        } else if (this.options.type == 'pagesLeft') {
            let right = axAddElem('div'),
                left = axAddElem('div', { class: 'ax-col ax-align-left' });
            this.targetDom.classList.add('ax-row');
            right.appendChild(this.pageTotal);
            right.appendChild(this.pageGo);
            left.appendChild(this.pageFirst);
            left.appendChild(this.pagePrev);
            left.appendChild(this.pagesDom);
            left.appendChild(this.pageNext);
            left.appendChild(this.pageLast);
            fragment.appendChild(left);
            fragment.appendChild(right);
        } else {
            fragment.appendChild(this.pagesDom);
        }
        this.targetDom.appendChild(fragment);
    }
    jsonAjax(data, callback) {
        let _this = this;
        axAjax({
            url: data,
            before: function (loading) {
                _this.listDom ? _this.listDom.innerHTML = '<div class="ax-pageTurning">' + loading + '</div>' : null;
            },
            success: function (content) {
                content.forEach(i => {
                    let item = axStrToDom(axTplEngine(_this.template, i));
                    _this.preData.push(item);
                });
                _this.getCurrent(_this.preData);
                callback && callback.call(_this);
            }
        })
    }
    sqlAjax(current, callback) {
        let _this = this;
        axAjax({
            data: Object.assign({ count: this.options.count, current: current }, _this.options.dataExtend),
            url: this.options.data,
            before: function (loading) {
                if (_this.listDom) {
                    _this.loadingDom.style = '';
                    _this.loadingDom.innerHTML = loading;
                    if (_this.options.loadingMode == 'overlay') {
                        _this.loadingDom.classList.add('ax-overlay');
                    } else {
                        _this.listDom.innerHTML = '';
                        _this.listDom.appendChild(_this.loadingDom)
                    }
                    _this.listDom.insertAdjacentElement('afterbegin', _this.loadingDom);
                    axFadeIn(_this.loadingDom, 'flex');
                }
            },
            success: function (content) {
                if(typeof content != 'object'){
                    console.error('The type of content must be object!');
                    return false;
                }
                if(axIsEmpty(content.data)){
                    _this.listDom?_this.listDom.innerHTML ='':null;
                    _this.targetDom.innerHTML = '';
                    return false;
                }
                _this.preData = [];
                content.data.forEach(i => {
                    let item = axStrToDom(axTplEngine(_this.template, i));
                    _this.preData.push(item);
                });
                _this.getCurrent(content.data, ~~content.current, ~~content.pagesNum, ~~content.itemsNum);
                callback && callback.call(_this);
            }
        })
    }
    currentRender(current) {
        let _this = this;
        if (_this.dataType(this.options.data) == 'sql') {
            this.sqlAjax(current, function () {
                if (_this.options.delay) {
                    setTimeout(function () {
                        _this.listDom ? _this.renderList(1) : null;
                    }, _this.options.delay)
                } else {
                    _this.listDom ? _this.renderList(1) : null;
                }
            });
        } else {
            _this.listDom ? _this.renderList(current) : null;
        }
        _this.renderPages(current);
        'turned' in this.handlers ? this.emit('turned', this.current, this.pagesNum) : null;
    }
    first(callback) {
        this.current = 1;
        this.currentRender(this.current);
        callback && callback.call(this, this.current, this.pagesNum);
        return this;
    }
    prev(callback) {
        if (this.current <= 1) {
            return false;
        } else {
            this.current = this.current - 1;
            this.currentRender(this.current);
            callback && callback.call(this, this.current, this.pagesNum);
        }
        return this;
    }
    next(callback) {
        if (this.current >= this.pagesNum) {
            return false;
        } else {
            this.current = this.current + 1;
            this.currentRender(this.current);
            callback && callback.call(this, this.current, this.pagesNum);
        }
        return this;
    }
    last(callback) {
        this.current = this.pagesNum;
        this.currentRender(this.current);
        callback && callback.call(this, this.current, this.pagesNum);
        return this;
    }
    go(page, callback) {
        if (this.current <= 1 || this.current >= this.pagesNum) {
            console.error('The value is out of range!');
            return false;
        } else {
            this.current = ~~page;
            this.currentRender(this.current);
            callback && callback.call(this, this.current, this.pagesNum);
        }
        return this;
    }
    info(callback) {
        let info = { current: this.current, pagesNum: this.pagesNum, count: this.options.count, itemsNum: this.itemsNum, selectData: this.selectData };
        callback && callback.call(this, info);
        return info;
    }
    update(setting, mode = 'overwrite', callback) {
        this.options = axExtend(this.options, setting);
        this.current = this.options.current;
        this.targetDom.innerHTML = '';
        mode == 'overwrite' ? this.preData = [] : null;
        this.init(this.options.data);
        'updated' in this.handlers ? this.emit('updated', this.current, this.pagesNum) : null;
        callback && callback.call(this);
        return this;
    }
    updateData(data, mode = 'overwrite', callback) {
        this.options.data = data;
        this.targetDom.innerHTML = '';
        mode == 'overwrite' ? this.preData = [] : null;
        this.init(this.options.data);
        'updated' in this.handlers ? this.emit('updated', this.current, this.pagesNum) : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axPagination]').forEach(element => {
        new axPagination(element);
    });
})();
/*!
* 插件：可排序列表；使用方法：new axList('#id',{参数})；#id是可选参数，可以从该dom获取参数值
*/
class axList {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            names: '',
            keyDelay: 200,
            paginationDom: null,
            maxCount: 10000,
            pagination: true,
            updated: function (current, pagesNum) {
            },
            count: 10, 
            current: 1, 
            firstText: '首页', 
            prevText: '上一页', 
            nextText: '下一页', 
            lastText: '尾页', 
            allPages: false,
            data: [], 
            template: null, 
            type: 'regular', 
            className: '',
            lastDel: '', 
            async: '',
            loadingMode: 'overlay',
            delay: 0,
            dataExtend: '',
            rendered: function (current, pagesNum) {
            }
        }, options, this.targetDom);
        this.handlers = {};
        this.rawData = [];
        this.preData = [];
        this.paginationDom = this.options.paginationDom ? axIdToDom(this.options.paginationDom) : '';
        if (!this.options.template) {
            this.template = '';
        } else {
            if (this.options.template.trim().substr(0, 1) == '#') {
                this.template = document.querySelector(this.options.template).innerHTML
            } else {
                this.template = this.options.template;
            }
        }
        this.names = this.options.names.replace(/\s+/g, '').split(',');
        this.listDom = this.targetDom.querySelector('[list]');
        this.searchs = this.targetDom.querySelectorAll('[search]');
        this.keywords = this.targetDom.querySelectorAll('[keyword]');
        this.searchVal = '';
        this.sorts = this.targetDom.querySelectorAll('[sort]');
        this.resets = this.targetDom.querySelectorAll('[reset]');
        this.filters = this.targetDom.querySelectorAll('[filter]');
        this.extends = this.targetDom.querySelectorAll('[extend]');
        this.paginationOpt = {};
        this.pagination = null;
        this.init();
    }
    init() {
        let _this = this;
        this.setPaginationOpt();
        if (!axIsEmpty(this.listDom.childNodes)) {
            let data = [...this.listDom.childNodes].filter(item => item.nodeType == 1);
            this.getDomArr(data);
            this.paginationOpt.data = this.preData;
            this.renderFinish();
        } else if (axType(this.options.data) == 'String' && this.options.template) {
            if (this.options.async == 'json') {
                let _this = this;
                axAjax({
                    url: _this.options.data,
                    success: function (content) {
                        let data = [];
                        content.forEach(i => {
                            let item = axStrToDom(axTplEngine(_this.template, i));
                            data.push(item);
                        });
                        _this.getDomArr(data);
                        _this.paginationOpt.data = _this.preData;
                        _this.renderFinish();
                    }
                })
            } else if (this.options.async == 'sql') {
                if (!['relative', 'absolute', 'fixed'].includes(axStyle(this.listDom).position)) {
                    this.listDom.style.position = 'relative';
                }
                this.renderSqlFinish();
            }
        } else {
            this.paginationOpt.data = this.options.data;
            this.renderFinish();
        }
    }
    getDomArr(listData) {
        if (this.options.names) {
            listData.forEach(item => {
                let obj = { dom: item };
                this.names.forEach(i => {
                    item.querySelector('[' + i + ']') ? obj[i] = item.querySelector('[' + i + ']').innerHTML.trim() : null;
                })
                this.preData.push(obj);
            });
            this.rawData = [...this.preData];
            return true;
        } else {
            this.preData = listData;
            this.rawData = [...listData];
            return false;
        }
    }
    renderFinish() {
        let _this = this;
        this.pagination = new axPagination(this.paginationDom, this.paginationOpt);
        if (!this.options.pagination) {
            this.pagination.targetDom.remove();
            if (this.pagination.itemsNum > this.paginationOpt.count) {
                console.error('The maximum length cannot exceed ' + this.paginationOpt.count + '!');
                return false;
            }
        }
        [...this.sorts].forEach(item => {
            if (!item) {
                console.error(axError.noNode);
                return false;
            }
            let attr = item.getAttribute('sort');
            if (_this.names.some(i => i == attr)) {
                item.onclick = function () {
                    if (this.hasAttribute('desc')) {
                        this.removeAttribute('desc');
                        this.setAttribute('asc', '')
                        _this.sort(attr, 'asc');
                    } else {
                        this.removeAttribute('asc');
                        this.setAttribute('desc', '');
                        _this.sort(attr, 'desc');
                    }
                }
            }
        });
        [...this.resets].forEach(item => {
            if (!item) {
                console.error(axError.noNode);
                return false;
            }
            item.onclick = function () {
                _this.preData = [..._this.rawData];
                _this.pagination.updateData(_this.preData, 'overwrite', function () {
                    'reset' in _this.handlers ? _this.emit('reset', _this.pagination.current, _this.pagination.pagesNum) : null;
                    _this.options.updated && _this.options.updated.call(_this, _this.pagination.current, _this.pagination.pagesNum);
                })
            }
        });
        [...this.searchs].forEach(item => {
            if (!item) {
                console.error(axError.noNode);
                return false;
            }
            let source = [..._this.preData];
            item.oninput = axDebounce(function () {
                let value = '';
                if (this.getAttribute('for')) {
                    let arr = this.getAttribute('for').split(','),
                        obj = {};
                    arr.forEach(i => {
                        obj[i] = this.value;
                    });
                    value = obj;
                } else {
                    value = this.value;
                }
                _this.keySearch(value, source, item);
            }, _this.options.keyDelay);
            /*        item.oninput = function () {
                       let value = '';
                       if (this.getAttribute('for')) {
                           let arr = this.getAttribute('for').split(','),
                               obj = {};
                           arr.forEach(i => {
                               obj[i] = this.value;
                           })
                           value = obj;
                       } else {
                           value = this.value;
                       }
                       if (timeout) {
                           clearTimeout(timeout)
                       }
                       timeout = setTimeout(_this.keySearch(value, source, item), _this.options.keyDelay); 
                   }*/
        });
        [...this.filters].forEach(item => {
            if (!item) {
                console.error(axError.noNode);
                return false;
            }
            let source = [..._this.preData],
                names = JSON.parse(item.getAttribute('filter'));
            item.onclick = function () {
                _this.keySearch(names, source, item);
            }
        });
    }
    setPaginationOpt() {
        this.paginationOpt.listDom = this.listDom;
        this.paginationOpt.count = !this.options.pagination ? this.options.maxCount : this.options.count;
        this.paginationOpt.current = this.options.current;
        this.paginationOpt.firstText = this.options.firstText;
        this.paginationOpt.prevText = this.options.prevText;
        this.paginationOpt.nextText = this.options.nextText;
        this.paginationOpt.lastText = this.options.lastText;
        this.paginationOpt.allPages = this.options.allPages;
        this.paginationOpt.data = this.options.data;
        this.paginationOpt.template = this.options.template;
        this.paginationOpt.type = this.options.type;
        this.paginationOpt.className = this.options.className;
        this.paginationOpt.lastDel = this.options.lastDel;
        this.paginationOpt.async = this.options.async;
        this.paginationOpt.delay = this.options.delay;
        this.paginationOpt.loadingMode = this.options.loadingMode;
        this.paginationOpt.dataExtend = this.options.dataExtend;
        this.paginationOpt.rendered = this.options.rendered;
        return this.paginationOpt;
    }
    renderSqlFinish() {
        let _this = this;
        this.pagination = new axPagination(this.paginationDom, this.paginationOpt);
        [...this.sorts].forEach(item => {
            if (!item) {
                console.error(axError.noNode);
                return false;
            }
            let attr = item.getAttribute('sort');
            item.onclick = function () {
                let obj = { sort: attr };
                _this.updateSql({ dataExtend: obj });
                if (!attr.includes(',')) {
                    if (attr.includes('desc')) {
                        attr = attr.replace('desc', 'asc');
                        item.removeAttribute('desc');
                        item.setAttribute('asc', '');
                    } else if (attr.includes('asc')) {
                        attr = attr.replace('asc', 'desc');
                        item.removeAttribute('asc');
                        item.setAttribute('desc', '');
                    }
                }
            }
        });
        [...this.filters].forEach(item => {
            if (!item) {
                console.error(axError.noNode);
                return false;
            }
            let attr = item.getAttribute('filter'),
                obj = { filter: attr };
            item.onclick = function () {
                _this.updateSql({ dataExtend: obj });
                _this.pagination.on('rendered', function () {
                    if (axIsEmpty(_this.pagination.preData)) {
                        _this.listDom.innerHTML = '';
                        _this.pagination.targetDom.innerHTML = '';
                    }
                });
            }
        });
        [...this.extends].forEach(item => {
            if (!item) {
                console.error(axError.noNode);
                return false;
            }
            let attr = item.getAttribute('extend'),
                obj = { extend: attr };
            item.onclick = function () {
                _this.updateSql({ dataExtend: obj });
                _this.pagination.on('rendered', function () {
                    if (axIsEmpty(_this.pagination.preData)) {
                        _this.listDom.innerHTML = '';
                        _this.pagination.targetDom.innerHTML = '';
                    }
                });
            }
        });
        [...this.searchs].forEach(item => {
            if (!item) {
                console.error(axError.noNode);
                return false;
            }
            let searchNames = item.getAttribute('search'),
                keyInput = [...this.keywords].filter(i => i.getAttribute('keyword') == item.getAttribute('for'))[0];
            searchNames = searchNames ? searchNames.replace(/\s+/g, '').split(',') : this.names;
            item.onclick = function () {
                _this.sqlSearch(searchNames, keyInput.value);
            }
            keyInput.onkeyup = function (e) {
                if (e.keyCode === 13) {
                    item.click();
                }
            }
        });
        [...this.resets].forEach(item => {
            if (!item) {
                console.error(axError.noNode);
                return false;
            }
            item.onclick = function () {
                _this.updateSql({ dataExtend: { reset: true } });
                [..._this.sorts].forEach(i => {
                    i.removeAttribute('desc', 'asc')
                });
                [..._this.keywords].forEach(i => {
                    i.value = '';
                });
            }
        });
    }
    sort(name, order, callback) {
        let _this = this;
        if (order == 'asc') {
            this.preData.sort(function (a, b) {
                if (isNaN(a[name] - b[name])) {
                    return b[name].localeCompare(a[name], 'zh-CN-u-kf-lower');
                } else {
                    return b[name] - a[name];
                }
            })
        } else if (order == 'desc') {
            this.preData.sort(function (a, b) {
                if (isNaN(a[name] - b[name])) {
                    return a[name].localeCompare(b[name], 'zh-CN-u-kf-lower');
                } else {
                    return a[name] - b[name];
                }
            })
        } else {
            return false;
        }
        this.pagination.updateData(this.preData, 'overwrite');
        'sorted' in this.handlers ? this.emit('sorted', _this.pagination.current, _this.pagination.pagesNum) : null;
        _this.options.updated && _this.options.updated.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        callback && callback.call(this, this.preData, this.pagination.current);
        return this;
    }
    keySearch(value, sourceArr, item, callback) {
        let _this = this,
            filterArr = sourceArr.filter(i => {
                let values = [];
                if (typeof value == "object") {
                    let flag = [];
                    for (let k in value) {
                        flag.push(i[k].includes(value[k]));
                    }
                    if (item.hasAttribute('or')) {
                        return flag.some(k => k == true);
                    } else {
                        return !flag.some(k => k == false);
                    }
                } else {
                    for (let k of _this.names) {
                        values.push(i[k]);
                    }
                    return values.toString().includes(value);
                }
            });
        _this.preData = filterArr;
        if (axIsEmpty(_this.preData)) {
            'filtered' in _this.handlers ? _this.emit('filtered', _this.pagination.current, _this.pagination.pagesNum) : null;
            callback && callback.call(_this, _this.pagination.current, _this.pagination.pagesNum);
            _this.preData = [...this.rawData];
            _this.listDom.innerHTML = '';
            _this.pagination.targetDom.innerHTML = '';
            return false;
        } else {
            _this.pagination.updateData(_this.preData, 'overwrite');
            'filtered' in _this.handlers ? _this.emit('filtered', _this.pagination.current, _this.pagination.pagesNum) : null;
            _this.options.updated && _this.options.updated.call(_this, _this.pagination.current, _this.pagination.pagesNum);
            callback && callback.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        }
    }
    sqlSearch(names, value) {
        let _this = this,
            dataString = '',
            last;
        names.forEach((i, index) => {
            last = names.length - 1 != index ? 'or ' : '';
            dataString += i + " like '%" + value + "%' " + last;
        });
        _this.options.dataExtend = '';
        _this.update({ dataExtend: { search: dataString } });
        _this.pagination.on('rendered', function () {
            if (axIsEmpty(_this.pagination.preData)) {
                _this.listDom.innerHTML = '';
                _this.pagination.targetDom.innerHTML = '';
            }
        })
    }
    updateSql(extend, callback) {
        let _this = this;
        _this.pagination.options.dataExtend = '';
        _this.pagination.update(extend, 'overwrite', function () {
            'updated' in _this.handlers ? _this.emit('updated', _this.pagination.current, _this.pagination.pagesNum) : null;
            _this.options.updated && _this.options.updated.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        });
        callback && callback.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        return this;
    }
    update(setting, callback) {
        let _this = this;
        _this.options = axExtend(_this.options, setting);
        _this.pagination.update(setting, 'overwrite', function () {
            'updated' in _this.handlers ? _this.emit('updated', _this.pagination.current, _this.pagination.pagesNum) : null;
            _this.options.updated && _this.options.updated.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        });
        callback && callback.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axList]').forEach(element => {
        new axList(element);
    });
})();
/*!
 * 轮播插件axSwipe，使用方法：new axSwipe('#id',{参数})。源自Swiper v8.1.4 from https://swiperjs.com | AXUI做了部分修改
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.axSwiper = factory());
    document.querySelectorAll('[axSwiper]').forEach(element => {
        new axSwiper(element);
    });
})(this, (function () {
    'use strict';
    /**
     * SSR Window 4.0.2
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: December 13, 2021
     */
    /* eslint-disable no-param-reassign */
    function isObject$1(obj) {
        return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
    }
    function extend$1(target, src) {
        if (target === void 0) {
            target = {};
        }
        if (src === void 0) {
            src = {};
        }
        Object.keys(src).forEach(key => {
            if (typeof target[key] === 'undefined') target[key] = src[key]; else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
                extend$1(target[key], src[key]);
            }
        });
    }
    const ssrDocument = {
        body: {},
        addEventListener() { },
        removeEventListener() { },
        activeElement: {
            blur() { },
            nodeName: ''
        },
        querySelector() {
            return null;
        },
        querySelectorAll() {
            return [];
        },
        getElementById() {
            return null;
        },
        createEvent() {
            return {
                initEvent() { }
            };
        },
        createElement() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute() { },
                getElementsByTagName() {
                    return [];
                }
            };
        },
        createElementNS() {
            return {};
        },
        importNode() {
            return null;
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
        }
    };
    function getDocument() {
        const doc = typeof document !== 'undefined' ? document : {};
        extend$1(doc, ssrDocument);
        return doc;
    }
    const ssrWindow = {
        document: ssrDocument,
        navigator: {
            userAgent: ''
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
        },
        history: {
            replaceState() { },
            pushState() { },
            go() { },
            back() { }
        },
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener() { },
        removeEventListener() { },
        getComputedStyle() {
            return {
                getPropertyValue() {
                    return '';
                }
            };
        },
        Image() { },
        Date() { },
        screen: {},
        setTimeout() { },
        clearTimeout() { },
        matchMedia() {
            return {};
        },
        requestAnimationFrame(callback) {
            if (typeof setTimeout === 'undefined') {
                callback();
                return null;
            }
            return setTimeout(callback, 0);
        },
        cancelAnimationFrame(id) {
            if (typeof setTimeout === 'undefined') {
                return;
            }
            clearTimeout(id);
        }
    };
    function getWindow() {
        const win = typeof window !== 'undefined' ? window : {};
        extend$1(win, ssrWindow);
        return win;
    }
    /**
     * Dom7 4.0.4
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2022, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: January 11, 2022
     */
    /* eslint-disable no-proto */
    function makeReactive(obj) {
        const proto = obj.__proto__;
        Object.defineProperty(obj, '__proto__', {
            get() {
                return proto;
            },
            set(value) {
                proto.__proto__ = value;
            }
        });
    }
    class Dom7 extends Array {
        constructor(items) {
            if (typeof items === 'number') {
                super(items);
            } else {
                super(...(items || []));
                makeReactive(this);
            }
        }
    }
    function arrayFlat(arr) {
        if (arr === void 0) {
            arr = [];
        }
        const res = [];
        arr.forEach(el => {
            if (Array.isArray(el)) {
                res.push(...arrayFlat(el));
            } else {
                res.push(el);
            }
        });
        return res;
    }
    function arrayFilter(arr, callback) {
        return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
        const uniqueArray = [];
        for (let i = 0; i < arr.length; i += 1) {
            if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
        }
        return uniqueArray;
    }
    function qsa(selector, context) {
        if (typeof selector !== 'string') {
            return [selector];
        }
        const a = [];
        const res = context.querySelectorAll(selector);
        for (let i = 0; i < res.length; i += 1) {
            a.push(res[i]);
        }
        return a;
    }
    function $(selector, context) {
        const window = getWindow();
        const document = getDocument();
        let arr = [];
        if (!context && selector instanceof Dom7) {
            return selector;
        }
        if (!selector) {
            return new Dom7(arr);
        }
        if (typeof selector === 'string') {
            const html = selector.trim();
            if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                let toCreate = 'div';
                if (html.indexOf('<li') === 0) toCreate = 'ul';
                if (html.indexOf('<tr') === 0) toCreate = 'tbody';
                if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
                if (html.indexOf('<tbody') === 0) toCreate = 'table';
                if (html.indexOf('<option') === 0) toCreate = 'select';
                const tempParent = document.createElement(toCreate);
                tempParent.innerHTML = html;
                for (let i = 0; i < tempParent.childNodes.length; i += 1) {
                    arr.push(tempParent.childNodes[i]);
                }
            } else {
                arr = qsa(selector.trim(), context || document);
            } 
        } else if (selector.nodeType || selector === window || selector === document) {
            arr.push(selector);
        } else if (Array.isArray(selector)) {
            if (selector instanceof Dom7) return selector;
            arr = selector;
        }
        return new Dom7(arrayUnique(arr));
    }
    $.fn = Dom7.prototype; 
    function addClass() {
        for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
            classes[_key] = arguments[_key];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        this.forEach(el => {
            el.classList.add(...classNames);
        });
        return this;
    }
    function removeClass() {
        for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            classes[_key2] = arguments[_key2];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        this.forEach(el => {
            el.classList.remove(...classNames);
        });
        return this;
    }
    function toggleClass() {
        for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            classes[_key3] = arguments[_key3];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        this.forEach(el => {
            classNames.forEach(className => {
                el.classList.toggle(className);
            });
        });
    }
    function hasClass() {
        for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            classes[_key4] = arguments[_key4];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        return arrayFilter(this, el => {
            return classNames.filter(className => el.classList.contains(className)).length > 0;
        }).length > 0;
    }
    function attr(attrs, value) {
        if (arguments.length === 1 && typeof attrs === 'string') {
            if (this[0]) return this[0].getAttribute(attrs);
            return undefined;
        } 
        for (let i = 0; i < this.length; i += 1) {
            if (arguments.length === 2) {
                this[i].setAttribute(attrs, value);
            } else {
                for (const attrName in attrs) {
                    this[i][attrName] = attrs[attrName];
                    this[i].setAttribute(attrName, attrs[attrName]);
                }
            }
        }
        return this;
    }
    function removeAttr(attr) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].removeAttribute(attr);
        }
        return this;
    }
    function transform(transform) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].style.transform = transform;
        }
        return this;
    }
    function transition$1(duration) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
        }
        return this;
    }
    function on() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
        }
        let [eventType, targetSelector, listener, capture] = args;
        if (typeof args[1] === 'function') {
            [eventType, listener, capture] = args;
            targetSelector = undefined;
        }
        if (!capture) capture = false;
        function handleLiveEvent(e) {
            const target = e.target;
            if (!target) return;
            const eventData = e.target.dom7EventData || [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            if ($(target).is(targetSelector)) listener.apply(target, eventData); else {
                const parents = $(target).parents(); 
                for (let k = 0; k < parents.length; k += 1) {
                    if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
                }
            }
        }
        function handleEvent(e) {
            const eventData = e && e.target ? e.target.dom7EventData || [] : [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            listener.apply(this, eventData);
        }
        const events = eventType.split(' ');
        let j;
        for (let i = 0; i < this.length; i += 1) {
            const el = this[i];
            if (!targetSelector) {
                for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7Listeners) el.dom7Listeners = {};
                    if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
                    el.dom7Listeners[event].push({
                        listener,
                        proxyListener: handleEvent
                    });
                    el.addEventListener(event, handleEvent, capture);
                }
            } else {
                for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
                    if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
                    el.dom7LiveListeners[event].push({
                        listener,
                        proxyListener: handleLiveEvent
                    });
                    el.addEventListener(event, handleLiveEvent, capture);
                }
            }
        }
        return this;
    }
    function off() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
        }
        let [eventType, targetSelector, listener, capture] = args;
        if (typeof args[1] === 'function') {
            [eventType, listener, capture] = args;
            targetSelector = undefined;
        }
        if (!capture) capture = false;
        const events = eventType.split(' ');
        for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
                const el = this[j];
                let handlers;
                if (!targetSelector && el.dom7Listeners) {
                    handlers = el.dom7Listeners[event];
                } else if (targetSelector && el.dom7LiveListeners) {
                    handlers = el.dom7LiveListeners[event];
                }
                if (handlers && handlers.length) {
                    for (let k = handlers.length - 1; k >= 0; k -= 1) {
                        const handler = handlers[k];
                        if (listener && handler.listener === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (!listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        }
                    }
                }
            }
        }
        return this;
    }
    function trigger() {
        const window = getWindow();
        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            args[_key9] = arguments[_key9];
        }
        const events = args[0].split(' ');
        const eventData = args[1];
        for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
                const el = this[j];
                if (window.CustomEvent) {
                    const evt = new window.CustomEvent(event, {
                        detail: eventData,
                        bubbles: true,
                        cancelable: true
                    });
                    el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
                    el.dispatchEvent(evt);
                    el.dom7EventData = [];
                    delete el.dom7EventData;
                }
            }
        }
        return this;
    }
    function transitionEnd$1(callback) {
        const dom = this;
        function fireCallBack(e) {
            if (e.target !== this) return;
            callback.call(this, e);
            dom.off('transitionend', fireCallBack);
        }
        if (callback) {
            dom.on('transitionend', fireCallBack);
        }
        return this;
    }
    function outerWidth(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
            }
            return this[0].offsetWidth;
        }
        return null;
    }
    function outerHeight(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
            }
            return this[0].offsetHeight;
        }
        return null;
    }
    function offset() {
        if (this.length > 0) {
            const window = getWindow();
            const document = getDocument();
            const el = this[0];
            const box = el.getBoundingClientRect();
            const body = document.body;
            const clientTop = el.clientTop || body.clientTop || 0;
            const clientLeft = el.clientLeft || body.clientLeft || 0;
            const scrollTop = el === window ? window.scrollY : el.scrollTop;
            const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
            return {
                top: box.top + scrollTop - clientTop,
                left: box.left + scrollLeft - clientLeft
            };
        }
        return null;
    }
    function styles() {
        const window = getWindow();
        if (this[0]) return window.getComputedStyle(this[0], null);
        return {};
    }
    function css(props, value) {
        const window = getWindow();
        let i;
        if (arguments.length === 1) {
            if (typeof props === 'string') {
                if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
            } else {
                for (i = 0; i < this.length; i += 1) {
                    for (const prop in props) {
                        this[i].style[prop] = props[prop];
                    }
                }
                return this;
            }
        }
        if (arguments.length === 2 && typeof props === 'string') {
            for (i = 0; i < this.length; i += 1) {
                this[i].style[props] = value;
            }
            return this;
        }
        return this;
    }
    function each(callback) {
        if (!callback) return this;
        this.forEach((el, index) => {
            callback.apply(el, [el, index]);
        });
        return this;
    }
    function filter(callback) {
        const result = arrayFilter(this, callback);
        return $(result);
    }
    function html(html) {
        if (typeof html === 'undefined') {
            return this[0] ? this[0].innerHTML : null;
        }
        for (let i = 0; i < this.length; i += 1) {
            this[i].innerHTML = html;
        }
        return this;
    }
    function text(text) {
        if (typeof text === 'undefined') {
            return this[0] ? this[0].textContent.trim() : null;
        }
        for (let i = 0; i < this.length; i += 1) {
            this[i].textContent = text;
        }
        return this;
    }
    function is(selector) {
        const window = getWindow();
        const document = getDocument();
        const el = this[0];
        let compareWith;
        let i;
        if (!el || typeof selector === 'undefined') return false;
        if (typeof selector === 'string') {
            if (el.matches) return el.matches(selector);
            if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
            if (el.msMatchesSelector) return el.msMatchesSelector(selector);
            compareWith = $(selector);
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) return true;
            }
            return false;
        }
        if (selector === document) {
            return el === document;
        }
        if (selector === window) {
            return el === window;
        }
        if (selector.nodeType || selector instanceof Dom7) {
            compareWith = selector.nodeType ? [selector] : selector;
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) return true;
            }
            return false;
        }
        return false;
    }
    function index() {
        let child = this[0];
        let i;
        if (child) {
            i = 0; 
            while ((child = child.previousSibling) !== null) {
                if (child.nodeType === 1) i += 1;
            }
            return i;
        }
        return undefined;
    }
    function eq(index) {
        if (typeof index === 'undefined') return this;
        const length = this.length;
        if (index > length - 1) {
            return $([]);
        }
        if (index < 0) {
            const returnIndex = length + index;
            if (returnIndex < 0) return $([]);
            return $([this[returnIndex]]);
        }
        return $([this[index]]);
    }
    function append() {
        let newChild;
        const document = getDocument();
        for (let k = 0; k < arguments.length; k += 1) {
            newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];
            for (let i = 0; i < this.length; i += 1) {
                if (typeof newChild === 'string') {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = newChild;
                    while (tempDiv.firstChild) {
                        this[i].appendChild(tempDiv.firstChild);
                    }
                } else if (newChild instanceof Dom7) {
                    for (let j = 0; j < newChild.length; j += 1) {
                        this[i].appendChild(newChild[j]);
                    }
                } else {
                    this[i].appendChild(newChild);
                }
            }
        }
        return this;
    }
    function prepend(newChild) {
        const document = getDocument();
        let i;
        let j;
        for (i = 0; i < this.length; i += 1) {
            if (typeof newChild === 'string') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = newChild;
                for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
                    this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                }
            } else if (newChild instanceof Dom7) {
                for (j = 0; j < newChild.length; j += 1) {
                    this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                }
            } else {
                this[i].insertBefore(newChild, this[i].childNodes[0]);
            }
        }
        return this;
    }
    function next(selector) {
        if (this.length > 0) {
            if (selector) {
                if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                    return $([this[0].nextElementSibling]);
                }
                return $([]);
            }
            if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
            return $([]);
        }
        return $([]);
    }
    function nextAll(selector) {
        const nextEls = [];
        let el = this[0];
        if (!el) return $([]);
        while (el.nextElementSibling) {
            const next = el.nextElementSibling; 
            if (selector) {
                if ($(next).is(selector)) nextEls.push(next);
            } else nextEls.push(next);
            el = next;
        }
        return $(nextEls);
    }
    function prev(selector) {
        if (this.length > 0) {
            const el = this[0];
            if (selector) {
                if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
                    return $([el.previousElementSibling]);
                }
                return $([]);
            }
            if (el.previousElementSibling) return $([el.previousElementSibling]);
            return $([]);
        }
        return $([]);
    }
    function prevAll(selector) {
        const prevEls = [];
        let el = this[0];
        if (!el) return $([]);
        while (el.previousElementSibling) {
            const prev = el.previousElementSibling; 
            if (selector) {
                if ($(prev).is(selector)) prevEls.push(prev);
            } else prevEls.push(prev);
            el = prev;
        }
        return $(prevEls);
    }
    function parent(selector) {
        const parents = []; 
        for (let i = 0; i < this.length; i += 1) {
            if (this[i].parentNode !== null) {
                if (selector) {
                    if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
                } else {
                    parents.push(this[i].parentNode);
                }
            }
        }
        return $(parents);
    }
    function parents(selector) {
        const parents = []; 
        for (let i = 0; i < this.length; i += 1) {
            let parent = this[i].parentNode; 
            while (parent) {
                if (selector) {
                    if ($(parent).is(selector)) parents.push(parent);
                } else {
                    parents.push(parent);
                }
                parent = parent.parentNode;
            }
        }
        return $(parents);
    }
    function closest(selector) {
        let closest = this; 
        if (typeof selector === 'undefined') {
            return $([]);
        }
        if (!closest.is(selector)) {
            closest = closest.parents(selector).eq(0);
        }
        return closest;
    }
    function find(selector) {
        const foundElements = [];
        for (let i = 0; i < this.length; i += 1) {
            const found = this[i].querySelectorAll(selector);
            for (let j = 0; j < found.length; j += 1) {
                foundElements.push(found[j]);
            }
        }
        return $(foundElements);
    }
    function children(selector) {
        const children = []; 
        for (let i = 0; i < this.length; i += 1) {
            const childNodes = this[i].children;
            for (let j = 0; j < childNodes.length; j += 1) {
                if (!selector || $(childNodes[j]).is(selector)) {
                    children.push(childNodes[j]);
                }
            }
        }
        return $(children);
    }
    function remove() {
        for (let i = 0; i < this.length; i += 1) {
            if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
        }
        return this;
    }
    const Methods = {
        addClass,
        removeClass,
        hasClass,
        toggleClass,
        attr,
        removeAttr,
        transform,
        transition: transition$1,
        on,
        off,
        trigger,
        transitionEnd: transitionEnd$1,
        outerWidth,
        outerHeight,
        styles,
        offset,
        css,
        each,
        html,
        text,
        is,
        index,
        eq,
        append,
        prepend,
        next,
        nextAll,
        prev,
        prevAll,
        parent,
        parents,
        closest,
        find,
        children,
        filter,
        remove
    };
    Object.keys(Methods).forEach(methodName => {
        Object.defineProperty($.fn, methodName, {
            value: Methods[methodName],
            writable: true
        });
    });
    function deleteProps(obj) {
        const object = obj;
        Object.keys(object).forEach(key => {
            try {
                object[key] = null;
            } catch (e) {
            }
            try {
                delete object[key];
            } catch (e) {
            }
        });
    }
    function nextTick(callback, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setTimeout(callback, delay);
    }
    function now() {
        return Date.now();
    }
    function getComputedStyle$1(el) {
        const window = getWindow();
        let style;
        if (window.getComputedStyle) {
            style = window.getComputedStyle(el, null);
        }
        if (!style && el.currentStyle) {
            style = el.currentStyle;
        }
        if (!style) {
            style = el.style;
        }
        return style;
    }
    function getTranslate(el, axis) {
        if (axis === void 0) {
            axis = 'x';
        }
        const window = getWindow();
        let matrix;
        let curTransform;
        let transformMatrix;
        const curStyle = getComputedStyle$1(el);
        if (window.WebKitCSSMatrix) {
            curTransform = curStyle.transform || curStyle.webkitTransform;
            if (curTransform.split(',').length > 6) {
                curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
            } 
            transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
        } else {
            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
            matrix = transformMatrix.toString().split(',');
        }
        if (axis === 'x') {
            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; 
            else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); 
            else curTransform = parseFloat(matrix[4]);
        }
        if (axis === 'y') {
            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; 
            else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); 
            else curTransform = parseFloat(matrix[5]);
        }
        return curTransform || 0;
    }
    function isObject(o) {
        return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }
    function isNode(node) {
        if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
            return node instanceof HTMLElement;
        }
        return node && (node.nodeType === 1 || node.nodeType === 11);
    }
    function extend() {
        const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
        const noExtend = ['__proto__', 'constructor', 'prototype'];
        for (let i = 1; i < arguments.length; i += 1) {
            const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
            if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
                const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
                for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                    const nextKey = keysArray[nextIndex];
                    const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                    if (desc !== undefined && desc.enumerable) {
                        if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                            if (nextSource[nextKey].__swiper__) {
                                to[nextKey] = nextSource[nextKey];
                            } else {
                                extend(to[nextKey], nextSource[nextKey]);
                            }
                        } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) {
                                to[nextKey] = nextSource[nextKey];
                            } else {
                                extend(to[nextKey], nextSource[nextKey]);
                            }
                        } else {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
        }
        return to;
    }
    function setCSSProperty(el, varName, varValue) {
        el.style.setProperty(varName, varValue);
    }
    function animateCSSModeScroll(_ref) {
        let {
            swiper,
            targetPosition,
            side
        } = _ref;
        const window = getWindow();
        const startPosition = -swiper.translate;
        let startTime = null;
        let time;
        const duration = swiper.params.speed;
        swiper.wrapperEl.style.scrollSnapType = 'none';
        window.cancelAnimationFrame(swiper.cssModeFrameID);
        const dir = targetPosition > startPosition ? 'next' : 'prev';
        const isOutOfBound = (current, target) => {
            return dir === 'next' && current >= target || dir === 'prev' && current <= target;
        };
        const animate = () => {
            time = new Date().getTime();
            if (startTime === null) {
                startTime = time;
            }
            const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
            const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
            let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
            if (isOutOfBound(currentPosition, targetPosition)) {
                currentPosition = targetPosition;
            }
            swiper.wrapperEl.scrollTo({
                [side]: currentPosition
            });
            if (isOutOfBound(currentPosition, targetPosition)) {
                swiper.wrapperEl.style.overflow = 'hidden';
                swiper.wrapperEl.style.scrollSnapType = '';
                setTimeout(() => {
                    swiper.wrapperEl.style.overflow = '';
                    swiper.wrapperEl.scrollTo({
                        [side]: currentPosition
                    });
                });
                window.cancelAnimationFrame(swiper.cssModeFrameID);
                return;
            }
            swiper.cssModeFrameID = window.requestAnimationFrame(animate);
        };
        animate();
    }
    let support;
    function calcSupport() {
        const window = getWindow();
        const document = getDocument();
        return {
            smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
            touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
            passiveListener: function checkPassiveListener() {
                let supportsPassive = false;
                try {
                    const opts = Object.defineProperty({}, 'passive', {
                        get() {
                            supportsPassive = true;
                        }
                    });
                    window.addEventListener('testPassiveListener', null, opts);
                } catch (e) {
                }
                return supportsPassive;
            }(),
            gestures: function checkGestures() {
                return 'ongesturestart' in window;
            }()
        };
    }
    function getSupport() {
        if (!support) {
            support = calcSupport();
        }
        return support;
    }
    let deviceCached;
    function calcDevice(_temp) {
        let {
            userAgent
        } = _temp === void 0 ? {} : _temp;
        const support = getSupport();
        const window = getWindow();
        const platform = window.navigator.platform;
        const ua = userAgent || window.navigator.userAgent;
        const device = {
            ios: false,
            android: false
        };
        const screenWidth = window.screen.width;
        const screenHeight = window.screen.height;
        const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); 
        let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
        const windows = platform === 'Win32';
        let macos = platform === 'MacIntel'; 
        const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
        if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
            ipad = ua.match(/(Version)\/([\d.]+)/);
            if (!ipad) ipad = [0, 1, '13_0_0'];
            macos = false;
        } 
        if (android && !windows) {
            device.os = 'android';
            device.android = true;
        }
        if (ipad || iphone || ipod) {
            device.os = 'ios';
            device.ios = true;
        } 
        return device;
    }
    function getDevice(overrides) {
        if (overrides === void 0) {
            overrides = {};
        }
        if (!deviceCached) {
            deviceCached = calcDevice(overrides);
        }
        return deviceCached;
    }
    let browser;
    function calcBrowser() {
        const window = getWindow();
        function isSafari() {
            const ua = window.navigator.userAgent.toLowerCase();
            return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
        }
        return {
            isSafari: isSafari(),
            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
        };
    }
    function getBrowser() {
        if (!browser) {
            browser = calcBrowser();
        }
        return browser;
    }
    function Resize(_ref) {
        let {
            swiper,
            on,
            emit
        } = _ref;
        const window = getWindow();
        let observer = null;
        let animationFrame = null;
        const resizeHandler = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            emit('beforeResize');
            emit('resize');
        };
        const createObserver = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            observer = new ResizeObserver(entries => {
                animationFrame = window.requestAnimationFrame(() => {
                    const {
                        width,
                        height
                    } = swiper;
                    let newWidth = width;
                    let newHeight = height;
                    entries.forEach(_ref2 => {
                        let {
                            contentBoxSize,
                            contentRect,
                            target
                        } = _ref2;
                        if (target && target !== swiper.el) return;
                        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                    });
                    if (newWidth !== width || newHeight !== height) {
                        resizeHandler();
                    }
                });
            });
            observer.observe(swiper.el);
        };
        const removeObserver = () => {
            if (animationFrame) {
                window.cancelAnimationFrame(animationFrame);
            }
            if (observer && observer.unobserve && swiper.el) {
                observer.unobserve(swiper.el);
                observer = null;
            }
        };
        const orientationChangeHandler = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            emit('orientationchange');
        };
        on('init', () => {
            if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
                createObserver();
                return;
            }
            window.addEventListener('resize', resizeHandler);
            window.addEventListener('orientationchange', orientationChangeHandler);
        });
        on('destroy', () => {
            removeObserver();
            window.removeEventListener('resize', resizeHandler);
            window.removeEventListener('orientationchange', orientationChangeHandler);
        });
    }
    function Observer(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const observers = [];
        const window = getWindow();
        const attach = function (target, options) {
            if (options === void 0) {
                options = {};
            }
            const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
            const observer = new ObserverFunc(mutations => {
                if (mutations.length === 1) {
                    emit('observerUpdate', mutations[0]);
                    return;
                }
                const observerUpdate = function observerUpdate() {
                    emit('observerUpdate', mutations[0]);
                };
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(observerUpdate);
                } else {
                    window.setTimeout(observerUpdate, 0);
                }
            });
            observer.observe(target, {
                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                childList: typeof options.childList === 'undefined' ? true : options.childList,
                characterData: typeof options.characterData === 'undefined' ? true : options.characterData
            });
            observers.push(observer);
        };
        const init = () => {
            if (!swiper.params.observer) return;
            if (swiper.params.observeParents) {
                const containerParents = swiper.$el.parents();
                for (let i = 0; i < containerParents.length; i += 1) {
                    attach(containerParents[i]);
                }
            } 
            attach(swiper.$el[0], {
                childList: swiper.params.observeSlideChildren
            }); 
            attach(swiper.$wrapperEl[0], {
                attributes: false
            });
        };
        const destroy = () => {
            observers.forEach(observer => {
                observer.disconnect();
            });
            observers.splice(0, observers.length);
        };
        extendParams({
            observer: false,
            observeParents: false,
            observeSlideChildren: false
        });
        on('init', init);
        on('destroy', destroy);
    }
    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
        on(events, handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            const method = priority ? 'unshift' : 'push';
            events.split(' ').forEach(event => {
                if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                self.eventsListeners[event][method](handler);
            });
            return self;
        },
        once(events, handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            function onceHandler() {
                self.off(events, onceHandler);
                if (onceHandler.__emitterProxy) {
                    delete onceHandler.__emitterProxy;
                }
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }
                handler.apply(self, args);
            }
            onceHandler.__emitterProxy = handler;
            return self.on(events, onceHandler, priority);
        },
        onAny(handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            const method = priority ? 'unshift' : 'push';
            if (self.eventsAnyListeners.indexOf(handler) < 0) {
                self.eventsAnyListeners[method](handler);
            }
            return self;
        },
        offAny(handler) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsAnyListeners) return self;
            const index = self.eventsAnyListeners.indexOf(handler);
            if (index >= 0) {
                self.eventsAnyListeners.splice(index, 1);
            }
            return self;
        },
        off(events, handler) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsListeners) return self;
            events.split(' ').forEach(event => {
                if (typeof handler === 'undefined') {
                    self.eventsListeners[event] = [];
                } else if (self.eventsListeners[event]) {
                    self.eventsListeners[event].forEach((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                            self.eventsListeners[event].splice(index, 1);
                        }
                    });
                }
            });
            return self;
        },
        emit() {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsListeners) return self;
            let events;
            let data;
            let context;
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }
            if (typeof args[0] === 'string' || Array.isArray(args[0])) {
                events = args[0];
                data = args.slice(1, args.length);
                context = self;
            } else {
                events = args[0].events;
                data = args[0].data;
                context = args[0].context || self;
            }
            data.unshift(context);
            const eventsArray = Array.isArray(events) ? events : events.split(' ');
            eventsArray.forEach(event => {
                if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
                    self.eventsAnyListeners.forEach(eventHandler => {
                        eventHandler.apply(context, [event, ...data]);
                    });
                }
                if (self.eventsListeners && self.eventsListeners[event]) {
                    self.eventsListeners[event].forEach(eventHandler => {
                        eventHandler.apply(context, data);
                    });
                }
            });
            return self;
        }
    };
    function updateSize() {
        const swiper = this;
        let width;
        let height;
        const $el = swiper.$el;
        if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
            width = swiper.params.width;
        } else {
            width = $el[0].clientWidth;
        }
        if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
            height = swiper.params.height;
        } else {
            height = $el[0].clientHeight;
        }
        if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
            return;
        } 
        width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
        height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
        if (Number.isNaN(width)) width = 0;
        if (Number.isNaN(height)) height = 0;
        Object.assign(swiper, {
            width,
            height,
            size: swiper.isHorizontal() ? width : height
        });
    }
    function updateSlides() {
        const swiper = this;
        function getDirectionLabel(property) {
            if (swiper.isHorizontal()) {
                return property;
            } 
            return {
                'width': 'height',
                'margin-top': 'margin-left',
                'margin-bottom ': 'margin-right',
                'margin-left': 'margin-top',
                'margin-right': 'margin-bottom',
                'padding-left': 'padding-top',
                'padding-right': 'padding-bottom',
                'marginRight': 'marginBottom'
            }[property];
        }
        function getDirectionPropertyValue(node, label) {
            return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
        }
        const params = swiper.params;
        const {
            $wrapperEl,
            size: swiperSize,
            rtlTranslate: rtl,
            wrongRTL
        } = swiper;
        const isVirtual = swiper.virtual && params.virtual.enabled;
        const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
        const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
        const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
        let snapGrid = [];
        const slidesGrid = [];
        const slidesSizesGrid = [];
        let offsetBefore = params.slidesOffsetBefore;
        if (typeof offsetBefore === 'function') {
            offsetBefore = params.slidesOffsetBefore.call(swiper);
        }
        let offsetAfter = params.slidesOffsetAfter;
        if (typeof offsetAfter === 'function') {
            offsetAfter = params.slidesOffsetAfter.call(swiper);
        }
        const previousSnapGridLength = swiper.snapGrid.length;
        const previousSlidesGridLength = swiper.slidesGrid.length;
        let spaceBetween = params.spaceBetween;
        let slidePosition = -offsetBefore;
        let prevSlideSize = 0;
        let index = 0;
        if (typeof swiperSize === 'undefined') {
            return;
        }
        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
            spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
        }
        swiper.virtualSize = -spaceBetween; 
        if (rtl) slides.css({
            marginLeft: '',
            marginBottom: '',
            marginTop: ''
        }); else slides.css({
            marginRight: '',
            marginBottom: '',
            marginTop: ''
        }); 
        if (params.centeredSlides && params.cssMode) {
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
        }
        const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
        if (gridEnabled) {
            swiper.grid.initSlides(slidesLength);
        } 
        let slideSize;
        const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
            return typeof params.breakpoints[key].slidesPerView !== 'undefined';
        }).length > 0;
        for (let i = 0; i < slidesLength; i += 1) {
            slideSize = 0;
            const slide = slides.eq(i);
            if (gridEnabled) {
                swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
            }
            if (slide.css('display') === 'none') continue; 
            if (params.slidesPerView === 'auto') {
                if (shouldResetSlideSize) {
                    slides[i].style[getDirectionLabel('width')] = ``;
                }
                const slideStyles = getComputedStyle(slide[0]);
                const currentTransform = slide[0].style.transform;
                const currentWebKitTransform = slide[0].style.webkitTransform;
                if (currentTransform) {
                    slide[0].style.transform = 'none';
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = 'none';
                }
                if (params.roundLengths) {
                    slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
                } else {
                    const width = getDirectionPropertyValue(slideStyles, 'width');
                    const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
                    const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
                    const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
                    const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
                    const boxSizing = slideStyles.getPropertyValue('box-sizing');
                    if (boxSizing && boxSizing === 'border-box') {
                        slideSize = width + marginLeft + marginRight;
                    } else {
                        const {
                            clientWidth,
                            offsetWidth
                        } = slide[0];
                        slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                    }
                }
                if (currentTransform) {
                    slide[0].style.transform = currentTransform;
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = currentWebKitTransform;
                }
                if (params.roundLengths) slideSize = Math.floor(slideSize);
            } else {
                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                if (params.roundLengths) slideSize = Math.floor(slideSize);
                if (slides[i]) {
                    slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
                }
            }
            if (slides[i]) {
                slides[i].swiperSlideSize = slideSize;
            }
            slidesSizesGrid.push(slideSize);
            if (params.centeredSlides) {
                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                slidesGrid.push(slidePosition);
            } else {
                if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                slidesGrid.push(slidePosition);
                slidePosition = slidePosition + slideSize + spaceBetween;
            }
            swiper.virtualSize += slideSize + spaceBetween;
            prevSlideSize = slideSize;
            index += 1;
        }
        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
        if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
            $wrapperEl.css({
                width: `${swiper.virtualSize + params.spaceBetween}px`
            });
        }
        if (params.setWrapperSize) {
            $wrapperEl.css({
                [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
            });
        }
        if (gridEnabled) {
            swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
        } 
        if (!params.centeredSlides) {
            const newSlidesGrid = [];
            for (let i = 0; i < snapGrid.length; i += 1) {
                let slidesGridItem = snapGrid[i];
                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
                    newSlidesGrid.push(slidesGridItem);
                }
            }
            snapGrid = newSlidesGrid;
            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
                snapGrid.push(swiper.virtualSize - swiperSize);
            }
        }
        if (snapGrid.length === 0) snapGrid = [0];
        if (params.spaceBetween !== 0) {
            const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
            slides.filter((_, slideIndex) => {
                if (!params.cssMode) return true;
                if (slideIndex === slides.length - 1) {
                    return false;
                }
                return true;
            }).css({
                [key]: `${spaceBetween}px`
            });
        }
        if (params.centeredSlides && params.centeredSlidesBounds) {
            let allSlidesSize = 0;
            slidesSizesGrid.forEach(slideSizeValue => {
                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize -= params.spaceBetween;
            const maxSnap = allSlidesSize - swiperSize;
            snapGrid = snapGrid.map(snap => {
                if (snap < 0) return -offsetBefore;
                if (snap > maxSnap) return maxSnap + offsetAfter;
                return snap;
            });
        }
        if (params.centerInsufficientSlides) {
            let allSlidesSize = 0;
            slidesSizesGrid.forEach(slideSizeValue => {
                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize -= params.spaceBetween;
            if (allSlidesSize < swiperSize) {
                const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                snapGrid.forEach((snap, snapIndex) => {
                    snapGrid[snapIndex] = snap - allSlidesOffset;
                });
                slidesGrid.forEach((snap, snapIndex) => {
                    slidesGrid[snapIndex] = snap + allSlidesOffset;
                });
            }
        }
        Object.assign(swiper, {
            slides,
            snapGrid,
            slidesGrid,
            slidesSizesGrid
        });
        if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
            const addToSnapGrid = -swiper.snapGrid[0];
            const addToSlidesGrid = -swiper.slidesGrid[0];
            swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
            swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
        }
        if (slidesLength !== previousSlidesLength) {
            swiper.emit('slidesLengthChange');
        }
        if (snapGrid.length !== previousSnapGridLength) {
            if (swiper.params.watchOverflow) swiper.checkOverflow();
            swiper.emit('snapGridLengthChange');
        }
        if (slidesGrid.length !== previousSlidesGridLength) {
            swiper.emit('slidesGridLengthChange');
        }
        if (params.watchSlidesProgress) {
            swiper.updateSlidesOffset();
        }
        if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
            const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
            if (slidesLength <= params.maxBackfaceHiddenSlides) {
                if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
            } else if (hasClassBackfaceClassAdded) {
                swiper.$el.removeClass(backFaceHiddenClass);
            }
        }
    }
    function updateAutoHeight(speed) {
        const swiper = this;
        const activeSlides = [];
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        let newHeight = 0;
        let i;
        if (typeof speed === 'number') {
            swiper.setTransition(speed);
        } else if (speed === true) {
            swiper.setTransition(swiper.params.speed);
        }
        const getSlideByIndex = index => {
            if (isVirtual) {
                return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
            }
            return swiper.slides.eq(index)[0];
        }; 
        if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
            if (swiper.params.centeredSlides) {
                swiper.visibleSlides.each(slide => {
                    activeSlides.push(slide);
                });
            } else {
                for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                    const index = swiper.activeIndex + i;
                    if (index > swiper.slides.length && !isVirtual) break;
                    activeSlides.push(getSlideByIndex(index));
                }
            }
        } else {
            activeSlides.push(getSlideByIndex(swiper.activeIndex));
        } 
        for (i = 0; i < activeSlides.length; i += 1) {
            if (typeof activeSlides[i] !== 'undefined') {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
        } 
        if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }
    function updateSlidesOffset() {
        const swiper = this;
        const slides = swiper.slides;
        for (let i = 0; i < slides.length; i += 1) {
            slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
        }
    }
    function updateSlidesProgress(translate) {
        if (translate === void 0) {
            translate = this && this.translate || 0;
        }
        const swiper = this;
        const params = swiper.params;
        const {
            slides,
            rtlTranslate: rtl,
            snapGrid
        } = swiper;
        if (slides.length === 0) return;
        if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
        let offsetCenter = -translate;
        if (rtl) offsetCenter = translate; 
        slides.removeClass(params.slideVisibleClass);
        swiper.visibleSlidesIndexes = [];
        swiper.visibleSlides = [];
        for (let i = 0; i < slides.length; i += 1) {
            const slide = slides[i];
            let slideOffset = slide.swiperSlideOffset;
            if (params.cssMode && params.centeredSlides) {
                slideOffset -= slides[0].swiperSlideOffset;
            }
            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
            const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
            const slideBefore = -(offsetCenter - slideOffset);
            const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
            const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
            if (isVisible) {
                swiper.visibleSlides.push(slide);
                swiper.visibleSlidesIndexes.push(i);
                slides.eq(i).addClass(params.slideVisibleClass);
            }
            slide.progress = rtl ? -slideProgress : slideProgress;
            slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
        }
        swiper.visibleSlides = $(swiper.visibleSlides);
    }
    function updateProgress(translate) {
        const swiper = this;
        if (typeof translate === 'undefined') {
            const multiplier = swiper.rtlTranslate ? -1 : 1; 
            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
        }
        const params = swiper.params;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        let {
            progress,
            isBeginning,
            isEnd
        } = swiper;
        const wasBeginning = isBeginning;
        const wasEnd = isEnd;
        if (translatesDiff === 0) {
            progress = 0;
            isBeginning = true;
            isEnd = true;
        } else {
            progress = (translate - swiper.minTranslate()) / translatesDiff;
            isBeginning = progress <= 0;
            isEnd = progress >= 1;
        }
        Object.assign(swiper, {
            progress,
            isBeginning,
            isEnd
        });
        if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
        if (isBeginning && !wasBeginning) {
            swiper.emit('reachBeginning toEdge');
        }
        if (isEnd && !wasEnd) {
            swiper.emit('reachEnd toEdge');
        }
        if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
            swiper.emit('fromEdge');
        }
        swiper.emit('progress', progress);
    }
    function updateSlidesClasses() {
        const swiper = this;
        const {
            slides,
            params,
            $wrapperEl,
            activeIndex,
            realIndex
        } = swiper;
        const isVirtual = swiper.virtual && params.virtual.enabled;
        slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
        let activeSlide;
        if (isVirtual) {
            activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
        } else {
            activeSlide = slides.eq(activeIndex);
        } 
        activeSlide.addClass(params.slideActiveClass);
        if (params.loop) {
            if (activeSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            }
        } 
        let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
        if (params.loop && nextSlide.length === 0) {
            nextSlide = slides.eq(0);
            nextSlide.addClass(params.slideNextClass);
        } 
        let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
        if (params.loop && prevSlide.length === 0) {
            prevSlide = slides.eq(-1);
            prevSlide.addClass(params.slidePrevClass);
        }
        if (params.loop) {
            if (nextSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
            }
            if (prevSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
            }
        }
        swiper.emitSlidesClasses();
    }
    function updateActiveIndex(newActiveIndex) {
        const swiper = this;
        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        const {
            slidesGrid,
            snapGrid,
            params,
            activeIndex: previousIndex,
            realIndex: previousRealIndex,
            snapIndex: previousSnapIndex
        } = swiper;
        let activeIndex = newActiveIndex;
        let snapIndex;
        if (typeof activeIndex === 'undefined') {
            for (let i = 0; i < slidesGrid.length; i += 1) {
                if (typeof slidesGrid[i + 1] !== 'undefined') {
                    if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
                        activeIndex = i;
                    } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                        activeIndex = i + 1;
                    }
                } else if (translate >= slidesGrid[i]) {
                    activeIndex = i;
                }
            } 
            if (params.normalizeSlideIndex) {
                if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
            }
        }
        if (snapGrid.indexOf(translate) >= 0) {
            snapIndex = snapGrid.indexOf(translate);
        } else {
            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
        }
        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
        if (activeIndex === previousIndex) {
            if (snapIndex !== previousSnapIndex) {
                swiper.snapIndex = snapIndex;
                swiper.emit('snapIndexChange');
            }
            return;
        } 
        const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
        Object.assign(swiper, {
            snapIndex,
            realIndex,
            previousIndex,
            activeIndex
        });
        swiper.emit('activeIndexChange');
        swiper.emit('snapIndexChange');
        if (previousRealIndex !== realIndex) {
            swiper.emit('realIndexChange');
        }
        if (swiper.initialized || swiper.params.runCallbacksOnInit) {
            swiper.emit('slideChange');
        }
    }
    function updateClickedSlide(e) {
        const swiper = this;
        const params = swiper.params;
        const slide = $(e).closest(`.${params.slideClass}`)[0];
        let slideFound = false;
        let slideIndex;
        if (slide) {
            for (let i = 0; i < swiper.slides.length; i += 1) {
                if (swiper.slides[i] === slide) {
                    slideFound = true;
                    slideIndex = i;
                    break;
                }
            }
        }
        if (slide && slideFound) {
            swiper.clickedSlide = slide;
            if (swiper.virtual && swiper.params.virtual.enabled) {
                swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
            } else {
                swiper.clickedIndex = slideIndex;
            }
        } else {
            swiper.clickedSlide = undefined;
            swiper.clickedIndex = undefined;
            return;
        }
        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
            swiper.slideToClickedSlide();
        }
    }
    var update = {
        updateSize,
        updateSlides,
        updateAutoHeight,
        updateSlidesOffset,
        updateSlidesProgress,
        updateProgress,
        updateSlidesClasses,
        updateActiveIndex,
        updateClickedSlide
    };
    function getSwiperTranslate(axis) {
        if (axis === void 0) {
            axis = this.isHorizontal() ? 'x' : 'y';
        }
        const swiper = this;
        const {
            params,
            rtlTranslate: rtl,
            translate,
            $wrapperEl
        } = swiper;
        if (params.virtualTranslate) {
            return rtl ? -translate : translate;
        }
        if (params.cssMode) {
            return translate;
        }
        let currentTranslate = getTranslate($wrapperEl[0], axis);
        if (rtl) currentTranslate = -currentTranslate;
        return currentTranslate || 0;
    }
    function setTranslate(translate, byController) {
        const swiper = this;
        const {
            rtlTranslate: rtl,
            params,
            $wrapperEl,
            wrapperEl,
            progress
        } = swiper;
        let x = 0;
        let y = 0;
        const z = 0;
        if (swiper.isHorizontal()) {
            x = rtl ? -translate : translate;
        } else {
            y = translate;
        }
        if (params.roundLengths) {
            x = Math.floor(x);
            y = Math.floor(y);
        }
        if (params.cssMode) {
            wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
        } else if (!params.virtualTranslate) {
            $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
        }
        swiper.previousTranslate = swiper.translate;
        swiper.translate = swiper.isHorizontal() ? x : y; 
        let newProgress;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        if (translatesDiff === 0) {
            newProgress = 0;
        } else {
            newProgress = (translate - swiper.minTranslate()) / translatesDiff;
        }
        if (newProgress !== progress) {
            swiper.updateProgress(translate);
        }
        swiper.emit('setTranslate', swiper.translate, byController);
    }
    function minTranslate() {
        return -this.snapGrid[0];
    }
    function maxTranslate() {
        return -this.snapGrid[this.snapGrid.length - 1];
    }
    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
        if (translate === void 0) {
            translate = 0;
        }
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        if (translateBounds === void 0) {
            translateBounds = true;
        }
        const swiper = this;
        const {
            params,
            wrapperEl
        } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return false;
        }
        const minTranslate = swiper.minTranslate();
        const maxTranslate = swiper.maxTranslate();
        let newTranslate;
        if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate; 
        swiper.updateProgress(newTranslate);
        if (params.cssMode) {
            const isH = swiper.isHorizontal();
            if (speed === 0) {
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
            } else {
                if (!swiper.support.smoothScroll) {
                    animateCSSModeScroll({
                        swiper,
                        targetPosition: -newTranslate,
                        side: isH ? 'left' : 'top'
                    });
                    return true;
                }
                wrapperEl.scrollTo({
                    [isH ? 'left' : 'top']: -newTranslate,
                    behavior: 'smooth'
                });
            }
            return true;
        }
        if (speed === 0) {
            swiper.setTransition(0);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
                swiper.emit('beforeTransitionStart', speed, internal);
                swiper.emit('transitionEnd');
            }
        } else {
            swiper.setTransition(speed);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
                swiper.emit('beforeTransitionStart', speed, internal);
                swiper.emit('transitionStart');
            }
            if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onTranslateToWrapperTransitionEnd) {
                    swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        if (runCallbacks) {
                            swiper.emit('transitionEnd');
                        }
                    };
                }
                swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
            }
        }
        return true;
    }
    var translate = {
        getTranslate: getSwiperTranslate,
        setTranslate,
        minTranslate,
        maxTranslate,
        translateTo
    };
    function setTransition(duration, byController) {
        const swiper = this;
        if (!swiper.params.cssMode) {
            swiper.$wrapperEl.transition(duration);
        }
        swiper.emit('setTransition', duration, byController);
    }
    function transitionEmit(_ref) {
        let {
            swiper,
            runCallbacks,
            direction,
            step
        } = _ref;
        const {
            activeIndex,
            previousIndex
        } = swiper;
        let dir = direction;
        if (!dir) {
            if (activeIndex > previousIndex) dir = 'next'; else if (activeIndex < previousIndex) dir = 'prev'; else dir = 'reset';
        }
        swiper.emit(`transition${step}`);
        if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === 'reset') {
                swiper.emit(`slideResetTransition${step}`);
                return;
            }
            swiper.emit(`slideChangeTransition${step}`);
            if (dir === 'next') {
                swiper.emit(`slideNextTransition${step}`);
            } else {
                swiper.emit(`slidePrevTransition${step}`);
            }
        }
    }
    function transitionStart(runCallbacks, direction) {
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            params
        } = swiper;
        if (params.cssMode) return;
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }
        transitionEmit({
            swiper,
            runCallbacks,
            direction,
            step: 'Start'
        });
    }
    function transitionEnd(runCallbacks, direction) {
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            params
        } = swiper;
        swiper.animating = false;
        if (params.cssMode) return;
        swiper.setTransition(0);
        transitionEmit({
            swiper,
            runCallbacks,
            direction,
            step: 'End'
        });
    }
    var transition = {
        setTransition,
        transitionStart,
        transitionEnd
    };
    function slideTo(index, speed, runCallbacks, internal, initial) {
        if (index === void 0) {
            index = 0;
        }
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        if (typeof index !== 'number' && typeof index !== 'string') {
            throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
        }
        if (typeof index === 'string') {
            /**
             * The `index` argument converted from `string` to `number`.
             * @type {number}
             */
            const indexAsNumber = parseInt(index, 10);
            /**
             * Determines whether the `index` argument is a valid `number`
             * after being converted from the `string` type.
             * @type {boolean}
             */
            const isValidNumber = isFinite(indexAsNumber);
            if (!isValidNumber) {
                throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
            } 
            index = indexAsNumber;
        }
        const swiper = this;
        let slideIndex = index;
        if (slideIndex < 0) slideIndex = 0;
        const {
            params,
            snapGrid,
            slidesGrid,
            previousIndex,
            activeIndex,
            rtlTranslate: rtl,
            wrapperEl,
            enabled
        } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
            return false;
        }
        const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
        let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
        if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
            swiper.emit('beforeSlideChangeStart');
        }
        const translate = -snapGrid[snapIndex]; 
        swiper.updateProgress(translate); 
        if (params.normalizeSlideIndex) {
            for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== 'undefined') {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
                        slideIndex = i;
                    } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
                        slideIndex = i + 1;
                    }
                } else if (normalizedTranslate >= normalizedGrid) {
                    slideIndex = i;
                }
            }
        } 
        if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
                return false;
            }
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
                if ((activeIndex || 0) !== slideIndex) return false;
            }
        }
        let direction;
        if (slideIndex > activeIndex) direction = 'next'; else if (slideIndex < activeIndex) direction = 'prev'; else direction = 'reset'; 
        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
            swiper.updateActiveIndex(slideIndex); 
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
            swiper.updateSlidesClasses();
            if (params.effect !== 'slide') {
                swiper.setTranslate(translate);
            }
            if (direction !== 'reset') {
                swiper.transitionStart(runCallbacks, direction);
                swiper.transitionEnd(runCallbacks, direction);
            }
            return false;
        }
        if (params.cssMode) {
            const isH = swiper.isHorizontal();
            const t = rtl ? translate : -translate;
            if (speed === 0) {
                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                if (isVirtual) {
                    swiper.wrapperEl.style.scrollSnapType = 'none';
                    swiper._immediateVirtual = true;
                }
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
                if (isVirtual) {
                    requestAnimationFrame(() => {
                        swiper.wrapperEl.style.scrollSnapType = '';
                        swiper._swiperImmediateVirtual = false;
                    });
                }
            } else {
                if (!swiper.support.smoothScroll) {
                    animateCSSModeScroll({
                        swiper,
                        targetPosition: t,
                        side: isH ? 'left' : 'top'
                    });
                    return true;
                }
                wrapperEl.scrollTo({
                    [isH ? 'left' : 'top']: t,
                    behavior: 'smooth'
                });
            }
            return true;
        }
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        if (speed === 0) {
            swiper.transitionEnd(runCallbacks, direction);
        } else if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onSlideToWrapperTransitionEnd) {
                swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
            }
            swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
        return true;
    }
    function slideToLoop(index, speed, runCallbacks, internal) {
        if (index === void 0) {
            index = 0;
        }
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        let newIndex = index;
        if (swiper.params.loop) {
            newIndex += swiper.loopedSlides;
        }
        return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slideNext(speed, runCallbacks, internal) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            animating,
            enabled,
            params
        } = swiper;
        if (!enabled) return swiper;
        let perGroup = params.slidesPerGroup;
        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
            perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
        }
        const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
        if (params.loop) {
            if (animating && params.loopPreventsSlide) return false;
            swiper.loopFix(); 
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        if (params.rewind && swiper.isEnd) {
            return swiper.slideTo(0, speed, runCallbacks, internal);
        }
        return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slidePrev(speed, runCallbacks, internal) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            params,
            animating,
            snapGrid,
            slidesGrid,
            rtlTranslate,
            enabled
        } = swiper;
        if (!enabled) return swiper;
        if (params.loop) {
            if (animating && params.loopPreventsSlide) return false;
            swiper.loopFix(); 
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        const translate = rtlTranslate ? swiper.translate : -swiper.translate;
        function normalize(val) {
            if (val < 0) return -Math.floor(Math.abs(val));
            return Math.floor(val);
        }
        const normalizedTranslate = normalize(translate);
        const normalizedSnapGrid = snapGrid.map(val => normalize(val));
        let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
        if (typeof prevSnap === 'undefined' && params.cssMode) {
            let prevSnapIndex;
            snapGrid.forEach((snap, snapIndex) => {
                if (normalizedTranslate >= snap) {
                    prevSnapIndex = snapIndex;
                }
            });
            if (typeof prevSnapIndex !== 'undefined') {
                prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
        }
        let prevIndex = 0;
        if (typeof prevSnap !== 'undefined') {
            prevIndex = slidesGrid.indexOf(prevSnap);
            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
            if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
                prevIndex = Math.max(prevIndex, 0);
            }
        }
        if (params.rewind && swiper.isBeginning) {
            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
        }
        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slideReset(speed, runCallbacks, internal) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed, runCallbacks, internal, threshold) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        if (threshold === void 0) {
            threshold = 0.5;
        }
        const swiper = this;
        let index = swiper.activeIndex;
        const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
        const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        if (translate >= swiper.snapGrid[snapIndex]) {
            const currentSnap = swiper.snapGrid[snapIndex];
            const nextSnap = swiper.snapGrid[snapIndex + 1];
            if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
                index += swiper.params.slidesPerGroup;
            }
        } else {
            const prevSnap = swiper.snapGrid[snapIndex - 1];
            const currentSnap = swiper.snapGrid[snapIndex];
            if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
                index -= swiper.params.slidesPerGroup;
            }
        }
        index = Math.max(index, 0);
        index = Math.min(index, swiper.slidesGrid.length - 1);
        return swiper.slideTo(index, speed, runCallbacks, internal);
    }
    function slideToClickedSlide() {
        const swiper = this;
        const {
            params,
            $wrapperEl
        } = swiper;
        const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
        let slideToIndex = swiper.clickedIndex;
        let realIndex;
        if (params.loop) {
            if (swiper.animating) return;
            realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            if (params.centeredSlides) {
                if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                    nextTick(() => {
                        swiper.slideTo(slideToIndex);
                    });
                } else {
                    swiper.slideTo(slideToIndex);
                }
            } else if (slideToIndex > swiper.slides.length - slidesPerView) {
                swiper.loopFix();
                slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                nextTick(() => {
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else {
            swiper.slideTo(slideToIndex);
        }
    }
    var slide = {
        slideTo,
        slideToLoop,
        slideNext,
        slidePrev,
        slideReset,
        slideToClosest,
        slideToClickedSlide
    };
    function loopCreate() {
        const swiper = this;
        const document = getDocument();
        const {
            params,
            $wrapperEl
        } = swiper; 
        const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
        $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
        let slides = $selector.children(`.${params.slideClass}`);
        if (params.loopFillGroupWithBlank) {
            const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
            if (blankSlidesNum !== params.slidesPerGroup) {
                for (let i = 0; i < blankSlidesNum; i += 1) {
                    const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
                    $selector.append(blankNode);
                }
                slides = $selector.children(`.${params.slideClass}`);
            }
        }
        if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
        swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
        swiper.loopedSlides += params.loopAdditionalSlides;
        if (swiper.loopedSlides > slides.length) {
            swiper.loopedSlides = slides.length;
        }
        const prependSlides = [];
        const appendSlides = [];
        slides.each((el, index) => {
            const slide = $(el);
            if (index < swiper.loopedSlides) {
                appendSlides.push(el);
            }
            if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
                prependSlides.push(el);
            }
            slide.attr('data-swiper-slide-index', index);
        });
        for (let i = 0; i < appendSlides.length; i += 1) {
            $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
        for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
            $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
    }
    function loopFix() {
        const swiper = this;
        swiper.emit('beforeLoopFix');
        const {
            activeIndex,
            slides,
            loopedSlides,
            allowSlidePrev,
            allowSlideNext,
            snapGrid,
            rtlTranslate: rtl
        } = swiper;
        let newIndex;
        swiper.allowSlidePrev = true;
        swiper.allowSlideNext = true;
        const snapTranslate = -snapGrid[activeIndex];
        const diff = snapTranslate - swiper.getTranslate(); 
        if (activeIndex < loopedSlides) {
            newIndex = slides.length - loopedSlides * 3 + activeIndex;
            newIndex += loopedSlides;
            const slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        } else if (activeIndex >= slides.length - loopedSlides) {
            newIndex = -slides.length + activeIndex + loopedSlides;
            newIndex += loopedSlides;
            const slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        swiper.emit('loopFix');
    }
    function loopDestroy() {
        const swiper = this;
        const {
            $wrapperEl,
            params,
            slides
        } = swiper;
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
        slides.removeAttr('data-swiper-slide-index');
    }
    var loop = {
        loopCreate,
        loopFix,
        loopDestroy
    };
    function setGrabCursor(moving) {
        const swiper = this;
        if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
        const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
        el.style.cursor = 'move';
        el.style.cursor = moving ? 'grabbing' : 'grab';
    }
    function unsetGrabCursor() {
        const swiper = this;
        if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
            return;
        }
        swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    }
    var grabCursor = {
        setGrabCursor,
        unsetGrabCursor
    };
    function closestElement(selector, base) {
        if (base === void 0) {
            base = this;
        }
        function __closestFrom(el) {
            if (!el || el === getDocument() || el === getWindow()) return null;
            if (el.assignedSlot) el = el.assignedSlot;
            const found = el.closest(selector);
            return found || __closestFrom(el.getRootNode().host);
        }
        return __closestFrom(base);
    }
    function onTouchStart(event) {
        const swiper = this;
        const document = getDocument();
        const window = getWindow();
        const data = swiper.touchEventsData;
        const {
            params,
            touches,
            enabled
        } = swiper;
        if (!enabled) return;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return;
        }
        if (!swiper.animating && params.cssMode && params.loop) {
            swiper.loopFix();
        }
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        let $targetEl = $(e.target);
        if (params.touchEventsTarget === 'wrapper') {
            if (!$targetEl.closest(swiper.wrapperEl).length) return;
        }
        data.isTouchEvent = e.type === 'touchstart';
        if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
        if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
        if (data.isTouched && data.isMoved) return; 
        const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
        if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
            $targetEl = $(event.path[0]);
        }
        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
        const isTargetShadow = !!(e.target && e.target.shadowRoot); 
        if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
            swiper.allowClick = true;
            return;
        }
        if (params.swipeHandler) {
            if (!$targetEl.closest(params.swipeHandler)[0]) return;
        }
        touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        const startX = touches.currentX;
        const startY = touches.currentY; 
        const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
        const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
            if (edgeSwipeDetection === 'prevent') {
                axPreventDefault(event);
            } else {
                return;
            }
        }
        Object.assign(data, {
            isTouched: true,
            isMoved: false,
            allowTouchCallbacks: true,
            isScrolling: undefined,
            startMoving: undefined
        });
        touches.startX = startX;
        touches.startY = startY;
        data.touchStartTime = now();
        swiper.allowClick = true;
        swiper.updateSize();
        swiper.swipeDirection = undefined;
        if (params.threshold > 0) data.allowThresholdMove = false;
        if (e.type !== 'touchstart') {
            let preventDefault = true;
            if ($targetEl.is(data.focusableElements)) {
                preventDefault = false;
                if ($targetEl[0].nodeName === 'SELECT') {
                    data.isTouched = false;
                }
            }
            if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
                document.activeElement.blur();
            }
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
                axPreventDefault(e);
            }
        }
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
            swiper.freeMode.onTouchStart();
        }
        swiper.emit('touchStart', e);
    }
    function onTouchMove(event) {
        const document = getDocument();
        const swiper = this;
        const data = swiper.touchEventsData;
        const {
            params,
            touches,
            rtlTranslate: rtl,
            enabled
        } = swiper;
        if (!enabled) return;
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        if (!data.isTouched) {
            if (data.startMoving && data.isScrolling) {
                swiper.emit('touchMoveOpposite', e);
            }
            return;
        }
        if (data.isTouchEvent && e.type !== 'touchmove') return;
        const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
        const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
        const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
        if (e.preventedByNestedSwiper) {
            touches.startX = pageX;
            touches.startY = pageY;
            return;
        }
        if (!swiper.allowTouchMove) {
            if (!$(e.target).is(data.focusableElements)) {
                swiper.allowClick = false;
            }
            if (data.isTouched) {
                Object.assign(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY
                });
                data.touchStartTime = now();
            }
            return;
        }
        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
            if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
                return;
            }
        }
        if (data.isTouchEvent && document.activeElement) {
            if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
        }
        if (data.allowTouchCallbacks) {
            swiper.emit('touchMove', e);
        }
        if (e.targetTouches && e.targetTouches.length > 1) return;
        touches.currentX = pageX;
        touches.currentY = pageY;
        const diffX = touches.currentX - touches.startX;
        const diffY = touches.currentY - touches.startY;
        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
        if (typeof data.isScrolling === 'undefined') {
            let touchAngle;
            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
                data.isScrolling = false;
            } else {
                if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
        }
        if (data.isScrolling) {
            swiper.emit('touchMoveOpposite', e);
        }
        if (typeof data.startMoving === 'undefined') {
            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
                data.startMoving = true;
            }
        }
        if (data.isScrolling) {
            data.isTouched = false;
            return;
        }
        if (!data.startMoving) {
            return;
        }
        swiper.allowClick = false;
        if (!params.cssMode && e.cancelable) {
            axPreventDefault(e);
        }
        if (params.touchMoveStopPropagation && !params.nested) {
            e.stopPropagation();
        }
        if (!data.isMoved) {
            if (params.loop && !params.cssMode) {
                swiper.loopFix();
            }
            data.startTranslate = swiper.getTranslate();
            swiper.setTransition(0);
            if (swiper.animating) {
                swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
            }
            data.allowMomentumBounce = false; 
            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                swiper.setGrabCursor(true);
            }
            swiper.emit('sliderFirstMove', e);
        }
        swiper.emit('sliderMove', e);
        data.isMoved = true;
        let diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff;
        diff *= params.touchRatio;
        if (rtl) diff = -diff;
        swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
        data.currentTranslate = diff + data.startTranslate;
        let disableParentSwiper = true;
        let resistanceRatio = params.resistanceRatio;
        if (params.touchReleaseOnEdges) {
            resistanceRatio = 0;
        }
        if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
        } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
        }
        if (disableParentSwiper) {
            e.preventedByNestedSwiper = true;
        } 
        if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }
        if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }
        if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
            data.currentTranslate = data.startTranslate;
        } 
        if (params.threshold > 0) {
            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
        }
        if (!params.followFinger || params.cssMode) return; 
        if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
            swiper.freeMode.onTouchMove();
        } 
        swiper.updateProgress(data.currentTranslate); 
        swiper.setTranslate(data.currentTranslate);
    }
    function onTouchEnd(event) {
        const swiper = this;
        const data = swiper.touchEventsData;
        const {
            params,
            touches,
            rtlTranslate: rtl,
            slidesGrid,
            enabled
        } = swiper;
        if (!enabled) return;
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        if (data.allowTouchCallbacks) {
            swiper.emit('touchEnd', e);
        }
        data.allowTouchCallbacks = false;
        if (!data.isTouched) {
            if (data.isMoved && params.grabCursor) {
                swiper.setGrabCursor(false);
            }
            data.isMoved = false;
            data.startMoving = false;
            return;
        } 
        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(false);
        } 
        const touchEndTime = now();
        const timeDiff = touchEndTime - data.touchStartTime; 
        if (swiper.allowClick) {
            const pathTree = e.path || e.composedPath && e.composedPath();
            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
            swiper.emit('tap click', e);
            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
                swiper.emit('doubleTap doubleClick', e);
            }
        }
        data.lastClickTime = now();
        nextTick(() => {
            if (!swiper.destroyed) swiper.allowClick = true;
        });
        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            return;
        }
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        let currentPos;
        if (params.followFinger) {
            currentPos = rtl ? swiper.translate : -swiper.translate;
        } else {
            currentPos = -data.currentTranslate;
        }
        if (params.cssMode) {
            return;
        }
        if (swiper.params.freeMode && params.freeMode.enabled) {
            swiper.freeMode.onTouchEnd({
                currentPos
            });
            return;
        } 
        let stopIndex = 0;
        let groupSize = swiper.slidesSizesGrid[0];
        for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (typeof slidesGrid[i + increment] !== 'undefined') {
                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                    stopIndex = i;
                    groupSize = slidesGrid[i + increment] - slidesGrid[i];
                }
            } else if (currentPos >= slidesGrid[i]) {
                stopIndex = i;
                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
            }
        }
        let rewindFirstIndex = null;
        let rewindLastIndex = null;
        if (params.rewind) {
            if (swiper.isBeginning) {
                rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
            } else if (swiper.isEnd) {
                rewindFirstIndex = 0;
            }
        } 
        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
        const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (timeDiff > params.longSwipesMs) {
            if (!params.longSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (swiper.swipeDirection === 'next') {
                if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
            }
            if (swiper.swipeDirection === 'prev') {
                if (ratio > 1 - params.longSwipesRatio) {
                    swiper.slideTo(stopIndex + increment);
                } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
                    swiper.slideTo(rewindLastIndex);
                } else {
                    swiper.slideTo(stopIndex);
                }
            }
        } else {
            if (!params.shortSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
            if (!isNavButtonTarget) {
                if (swiper.swipeDirection === 'next') {
                    swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                }
                if (swiper.swipeDirection === 'prev') {
                    swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                }
            } else if (e.target === swiper.navigation.nextEl) {
                swiper.slideTo(stopIndex + increment);
            } else {
                swiper.slideTo(stopIndex);
            }
        }
    }
    function onResize() {
        const swiper = this;
        const {
            params,
            el
        } = swiper;
        if (el && el.offsetWidth === 0) return; 
        if (params.breakpoints) {
            swiper.setBreakpoint();
        } 
        const {
            allowSlideNext,
            allowSlidePrev,
            snapGrid
        } = swiper; 
        swiper.allowSlideNext = true;
        swiper.allowSlidePrev = true;
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateSlidesClasses();
        if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
            swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
            swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
            swiper.autoplay.run();
        } 
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
    }
    function onClick(e) {
        const swiper = this;
        if (!swiper.enabled) return;
        if (!swiper.allowClick) {
            if (swiper.params.preventClicks){
                axPreventDefault(e);
            }
            if (swiper.params.preventClicksPropagation && swiper.animating) {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }
    }
    function onScroll() {
        const swiper = this;
        const {
            wrapperEl,
            rtlTranslate,
            enabled
        } = swiper;
        if (!enabled) return;
        swiper.previousTranslate = swiper.translate;
        if (swiper.isHorizontal()) {
            swiper.translate = -wrapperEl.scrollLeft;
        } else {
            swiper.translate = -wrapperEl.scrollTop;
        } 
        if (swiper.translate === 0) swiper.translate = 0;
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        let newProgress;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        if (translatesDiff === 0) {
            newProgress = 0;
        } else {
            newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
        }
        if (newProgress !== swiper.progress) {
            swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
        }
        swiper.emit('setTranslate', swiper.translate, false);
    }
    let dummyEventAttached = false;
    function dummyEventListener() { }
    const events = (swiper, method) => {
        const document = getDocument();
        const {
            params,
            touchEvents,
            el,
            wrapperEl,
            device,
            support
        } = swiper;
        const capture = !!params.nested;
        const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
        const swiperMethod = method; 
        if (!support.touch) {
            el[domMethod](touchEvents.start, swiper.onTouchStart, false);
            document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
            document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
        } else {
            const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
            el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
                passive: false,
                capture
            } : capture);
            el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
            if (touchEvents.cancel) {
                el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
        } 
        if (params.preventClicks || params.preventClicksPropagation) {
            el[domMethod]('click', swiper.onClick, true);
        }
        if (params.cssMode) {
            wrapperEl[domMethod]('scroll', swiper.onScroll);
        } 
        if (params.updateOnWindowResize) {
            swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
        } else {
            swiper[swiperMethod]('observerUpdate', onResize, true);
        }
    };
    function attachEvents() {
        const swiper = this;
        const document = getDocument();
        const {
            params,
            support
        } = swiper;
        swiper.onTouchStart = onTouchStart.bind(swiper);
        swiper.onTouchMove = onTouchMove.bind(swiper);
        swiper.onTouchEnd = onTouchEnd.bind(swiper);
        if (params.cssMode) {
            swiper.onScroll = onScroll.bind(swiper);
        }
        swiper.onClick = onClick.bind(swiper);
        if (support.touch && !dummyEventAttached) {
            document.addEventListener('touchstart', dummyEventListener);
            dummyEventAttached = true;
        }
        events(swiper, 'on');
    }
    function detachEvents() {
        const swiper = this;
        events(swiper, 'off');
    }
    var _events = {
        attachEvents,
        detachEvents
    };
    const isGridEnabled = (swiper, params) => {
        return swiper.grid && params.grid && params.grid.rows > 1;
    };
    function setBreakpoint() {
        const swiper = this;
        const {
            activeIndex,
            initialized,
            loopedSlides = 0,
            params,
            $el
        } = swiper;
        const breakpoints = params.breakpoints;
        if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; 
        const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
        if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
        const breakpointParams = breakpointOnlyParams || swiper.originalParams;
        const wasMultiRow = isGridEnabled(swiper, params);
        const isMultiRow = isGridEnabled(swiper, breakpointParams);
        const wasEnabled = params.enabled;
        if (wasMultiRow && !isMultiRow) {
            $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
            swiper.emitContainerClasses();
        } else if (!wasMultiRow && isMultiRow) {
            $el.addClass(`${params.containerModifierClass}grid`);
            if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
                $el.addClass(`${params.containerModifierClass}grid-column`);
            }
            swiper.emitContainerClasses();
        }
        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
        const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
        if (directionChanged && initialized) {
            swiper.changeDirection();
        }
        extend(swiper.params, breakpointParams);
        const isEnabled = swiper.params.enabled;
        Object.assign(swiper, {
            allowTouchMove: swiper.params.allowTouchMove,
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev
        });
        if (wasEnabled && !isEnabled) {
            swiper.disable();
        } else if (!wasEnabled && isEnabled) {
            swiper.enable();
        }
        swiper.currentBreakpoint = breakpoint;
        swiper.emit('_beforeBreakpoint', breakpointParams);
        if (needsReLoop && initialized) {
            swiper.loopDestroy();
            swiper.loopCreate();
            swiper.updateSlides();
            swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
        }
        swiper.emit('breakpoint', breakpointParams);
    }
    function getBreakpoint(breakpoints, base, containerEl) {
        if (base === void 0) {
            base = 'window';
        }
        if (!breakpoints || base === 'container' && !containerEl) return undefined;
        let breakpoint = false;
        const window = getWindow();
        const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
        const points = Object.keys(breakpoints).map(point => {
            if (typeof point === 'string' && point.indexOf('@') === 0) {
                const minRatio = parseFloat(point.substr(1));
                const value = currentHeight * minRatio;
                return {
                    value,
                    point
                };
            }
            return {
                value: point,
                point
            };
        });
        points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
        for (let i = 0; i < points.length; i += 1) {
            const {
                point,
                value
            } = points[i];
            if (base === 'window') {
                if (window.matchMedia(`(min-width: ${value}px)`).matches) {
                    breakpoint = point;
                }
            } else if (value <= containerEl.clientWidth) {
                breakpoint = point;
            }
        }
        return breakpoint || 'max';
    }
    var breakpoints = {
        setBreakpoint,
        getBreakpoint
    };
    function prepareClasses(entries, prefix) {
        const resultClasses = [];
        entries.forEach(item => {
            if (typeof item === 'object') {
                Object.keys(item).forEach(classNames => {
                    if (item[classNames]) {
                        resultClasses.push(prefix + classNames);
                    }
                });
            } else if (typeof item === 'string') {
                resultClasses.push(prefix + item);
            }
        });
        return resultClasses;
    }
    function addClasses() {
        const swiper = this;
        const {
            classNames,
            params,
            rtl,
            $el,
            device,
            support
        } = swiper; 
        const suffixes = prepareClasses(['initialized', params.direction, {
            'pointer-events': !support.touch
        }, {
                'free-mode': swiper.params.freeMode && params.freeMode.enabled
            }, {
                'autoheight': params.autoHeight
            }, {
                'rtl': rtl
            }, {
                'grid': params.grid && params.grid.rows > 1
            }, {
                'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
            }, {
                'android': device.android
            }, {
                'ios': device.ios
            }, {
                'css-mode': params.cssMode
            }, {
                'centered': params.cssMode && params.centeredSlides
            }, {
                'watch-progress': params.watchSlidesProgress
            }], params.containerModifierClass);
        classNames.push(...suffixes);
        $el.addClass([...classNames].join(' '));
        swiper.emitContainerClasses();
    }
    function removeClasses() {
        const swiper = this;
        const {
            $el,
            classNames
        } = swiper;
        $el.removeClass(classNames.join(' '));
        swiper.emitContainerClasses();
    }
    var classes = {
        addClasses,
        removeClasses
    };
    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
        const window = getWindow();
        let image;
        function onReady() {
            if (callback) callback();
        }
        const isPicture = $(imageEl).parent('picture')[0];
        if (!isPicture && (!imageEl.complete || !checkForComplete)) {
            if (src) {
                image = new window.Image();
                image.onload = onReady;
                image.onerror = onReady;
                if (sizes) {
                    image.sizes = sizes;
                }
                if (srcset) {
                    image.srcset = srcset;
                }
                if (src) {
                    image.src = src;
                }
            } else {
                onReady();
            }
        } else {
            onReady();
        }
    }
    function preloadImages() {
        const swiper = this;
        swiper.imagesToLoad = swiper.$el.find('img');
        function onReady() {
            if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
            if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
            if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
                if (swiper.params.updateOnImagesReady) swiper.update();
                swiper.emit('imagesReady');
            }
        }
        for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
            const imageEl = swiper.imagesToLoad[i];
            swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
        }
    }
    var images = {
        loadImage,
        preloadImages
    };
    function checkOverflow() {
        const swiper = this;
        const {
            isLocked: wasLocked,
            params
        } = swiper;
        const {
            slidesOffsetBefore
        } = params;
        if (slidesOffsetBefore) {
            const lastSlideIndex = swiper.slides.length - 1;
            const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
            swiper.isLocked = swiper.size > lastSlideRightEdge;
        } else {
            swiper.isLocked = swiper.snapGrid.length === 1;
        }
        if (params.allowSlideNext === true) {
            swiper.allowSlideNext = !swiper.isLocked;
        }
        if (params.allowSlidePrev === true) {
            swiper.allowSlidePrev = !swiper.isLocked;
        }
        if (wasLocked && wasLocked !== swiper.isLocked) {
            swiper.isEnd = false;
        }
        if (wasLocked !== swiper.isLocked) {
            swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
        }
    }
    var checkOverflow$1 = {
        checkOverflow
    };
    var defaults = {
        init: true,
        direction: 'horizontal',
        touchEventsTarget: 'wrapper',
        initialSlide: 0,
        speed: 300,
        cssMode: false,
        updateOnWindowResize: true,
        resizeObserver: true,
        nested: false,
        createElements: false,
        enabled: true,
        focusableElements: 'input, select, option, textarea, button, video, label',
        width: null,
        height: null,
        preventInteractionOnTransition: false,
        userAgent: null,
        url: null,
        edgeSwipeDetection: false,
        edgeSwipeThreshold: 20,
        autoHeight: false,
        setWrapperSize: false,
        virtualTranslate: false,
        effect: 'slide',
        breakpoints: undefined,
        breakpointsBase: 'window',
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: false,
        centeredSlides: false,
        centeredSlidesBounds: false,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: true,
        centerInsufficientSlides: false,
        watchOverflow: true,
        roundLengths: false,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: true,
        shortSwipes: true,
        longSwipes: true,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: true,
        allowTouchMove: true,
        threshold: 0,
        touchMoveStopPropagation: false,
        touchStartPreventDefault: true,
        touchStartForcePreventDefault: false,
        touchReleaseOnEdges: false,
        uniqueNavElements: true,
        resistance: true,
        resistanceRatio: 0.85,
        watchSlidesProgress: false,
        grabCursor: false,
        preventClicks: true,
        preventClicksPropagation: true,
        slideToClickedSlide: false,
        preloadImages: true,
        updateOnImagesReady: true,
        loop: false,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: false,
        loopPreventsSlide: true,
        rewind: false,
        allowSlidePrev: true,
        allowSlideNext: true,
        swipeHandler: null,
        noSwiping: true,
        noSwipingClass: 'ax-no-swiping',
        noSwipingSelector: null,
        passiveListeners: true,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: 'ax-',
        slideClass: 'ax-slide',
        slideBlankClass: 'ax-slide-invisible-blank',
        slideActiveClass: 'ax-slide-active',
        slideDuplicateActiveClass: 'ax-slide-duplicate-active',
        slideVisibleClass: 'ax-slide-visible',
        slideDuplicateClass: 'ax-slide-duplicate',
        slideNextClass: 'ax-slide-next',
        slideDuplicateNextClass: 'ax-slide-duplicate-next',
        slidePrevClass: 'ax-slide-prev',
        slideDuplicatePrevClass: 'ax-slide-duplicate-prev',
        wrapperClass: 'ax-wrapper',
        runCallbacksOnInit: true,
        _emitClasses: false
    };
    function moduleExtendParams(params, allModulesParams) {
        return function extendParams(obj) {
            if (obj === void 0) {
                obj = {};
            }
            const moduleParamName = Object.keys(obj)[0];
            const moduleParams = obj[moduleParamName];
            if (typeof moduleParams !== 'object' || moduleParams === null) {
                extend(allModulesParams, obj);
                return;
            }
            if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
                params[moduleParamName] = {
                    auto: true
                };
            }
            if (!(moduleParamName in params && 'enabled' in moduleParams)) {
                extend(allModulesParams, obj);
                return;
            }
            if (params[moduleParamName] === true) {
                params[moduleParamName] = {
                    enabled: true
                };
            }
            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
                params[moduleParamName].enabled = true;
            }
            if (!params[moduleParamName]) params[moduleParamName] = {
                enabled: false
            };
            extend(allModulesParams, obj);
        };
    }
    /* eslint no-param-reassign: "off" */
    const prototypes = {
        eventsEmitter,
        update,
        translate,
        transition,
        slide,
        loop,
        grabCursor,
        events: _events,
        breakpoints,
        checkOverflow: checkOverflow$1,
        classes,
        images
    };
    const extendedDefaults = {};
    class Swiper {
        constructor() {
            let el;
            let params;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
                params = args[0];
            } else {
                [el, params] = args;
            }
            if (!params) params = {};
            params = extend({}, params);
            if (el && !params.el) params.el = el;
            if (params.el && $(params.el).length > 1) {
                const swipers = [];
                $(params.el).each(containerEl => {
                    const newParams = extend({}, params, {
                        el: containerEl
                    });
                    swipers.push(new Swiper(newParams));
                });
                return swipers;
            } 
            const swiper = this;
            swiper.__swiper__ = true;
            swiper.support = getSupport();
            swiper.device = getDevice({
                userAgent: params.userAgent
            });
            swiper.browser = getBrowser();
            swiper.eventsListeners = {};
            swiper.eventsAnyListeners = [];
            swiper.modules = [...swiper.__modules__];
            if (params.modules && Array.isArray(params.modules)) {
                swiper.modules.push(...params.modules);
            }
            const allModulesParams = {};
            swiper.modules.forEach(mod => {
                mod({
                    swiper,
                    extendParams: moduleExtendParams(params, allModulesParams),
                    on: swiper.on.bind(swiper),
                    once: swiper.once.bind(swiper),
                    off: swiper.off.bind(swiper),
                    emit: swiper.emit.bind(swiper)
                });
            }); 
            const swiperParams = extend({}, defaults, allModulesParams); 
            swiper.params = extend({}, swiperParams, extendedDefaults, params);
            swiper.params = axDataset(params.el, swiper.params);
            if (typeof params.el == 'string') {
                if (swiper.params.navigation.prevEl == '.ax-prev') {
                    swiper.params.navigation.prevEl = document.querySelector(params.el + ' .ax-prev');
                }
                if (swiper.params.navigation.nextEl == '.ax-next') {
                    swiper.params.navigation.nextEl = document.querySelector(params.el + ' .ax-next');
                }
            } else {
                if (swiper.params.navigation.prevEl == '.ax-prev') {
                    swiper.params.navigation.prevEl = params.el.querySelector('.ax-prev');
                }
                if (swiper.params.navigation.nextEl == '.ax-next') {
                    swiper.params.navigation.nextEl = params.el.querySelector('.ax-next');
                }
            }
            swiper.originalParams = extend({}, swiper.params);
            swiper.passedParams = extend({}, params); 
            if (swiper.params && swiper.params.on) {
                Object.keys(swiper.params.on).forEach(eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                });
            }
            if (swiper.params && swiper.params.onAny) {
                swiper.onAny(swiper.params.onAny);
            } 
            swiper.$ = $; 
            Object.assign(swiper, {
                enabled: swiper.params.enabled,
                el,
                classNames: [],
                slides: $(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal() {
                    return swiper.params.direction === 'horizontal';
                },
                isVertical() {
                    return swiper.params.direction === 'vertical';
                },
                activeIndex: 0,
                realIndex: 0,
                isBeginning: true,
                isEnd: false,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: false,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,
                touchEvents: function touchEvents() {
                    const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
                    const desktop = ['pointerdown', 'pointermove', 'pointerup'];
                    swiper.touchEventsTouch = {
                        start: touch[0],
                        move: touch[1],
                        end: touch[2],
                        cancel: touch[3]
                    };
                    swiper.touchEventsDesktop = {
                        start: desktop[0],
                        move: desktop[1],
                        end: desktop[2]
                    };
                    return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
                }(),
                touchEventsData: {
                    isTouched: undefined,
                    isMoved: undefined,
                    allowTouchCallbacks: undefined,
                    touchStartTime: undefined,
                    isScrolling: undefined,
                    currentTranslate: undefined,
                    startTranslate: undefined,
                    allowThresholdMove: undefined,
                    focusableElements: swiper.params.focusableElements,
                    lastClickTime: now(),
                    clickTimeout: undefined,
                    velocities: [],
                    allowMomentumBounce: undefined,
                    isTouchEvent: undefined,
                    startMoving: undefined
                },
                allowClick: true,
                allowTouchMove: swiper.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            });
            swiper.emit('_swiper'); 
            if (swiper.params.init) {
                swiper.init();
            } 
            return swiper;
        }
        enable() {
            const swiper = this;
            if (swiper.enabled) return;
            swiper.enabled = true;
            if (swiper.params.grabCursor) {
                swiper.setGrabCursor();
            }
            swiper.emit('enable');
        }
        disable() {
            const swiper = this;
            if (!swiper.enabled) return;
            swiper.enabled = false;
            if (swiper.params.grabCursor) {
                swiper.unsetGrabCursor();
            }
            swiper.emit('disable');
        }
        setProgress(progress, speed) {
            const swiper = this;
            progress = Math.min(Math.max(progress, 0), 1);
            const min = swiper.minTranslate();
            const max = swiper.maxTranslate();
            const current = (max - min) * progress + min;
            swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        emitContainerClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const cls = swiper.el.className.split(' ').filter(className => {
                return className.indexOf('ax') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
            });
            swiper.emit('_containerClasses', cls.join(' '));
        }
        getSlideClasses(slideEl) {
            const swiper = this;
            if (swiper.destroyed) return '';
            return slideEl.className.split(' ').filter(className => {
                return className.indexOf('ax-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
            }).join(' ');
        }
        emitSlidesClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const updates = [];
            swiper.slides.each(slideEl => {
                const classNames = swiper.getSlideClasses(slideEl);
                updates.push({
                    slideEl,
                    classNames
                });
                swiper.emit('_slideClass', slideEl, classNames);
            });
            swiper.emit('_slideClasses', updates);
        }
        slidesPerViewDynamic(view, exact) {
            if (view === void 0) {
                view = 'current';
            }
            if (exact === void 0) {
                exact = false;
            }
            const swiper = this;
            const {
                params,
                slides,
                slidesGrid,
                slidesSizesGrid,
                size: swiperSize,
                activeIndex
            } = swiper;
            let spv = 1;
            if (params.centeredSlides) {
                let slideSize = slides[activeIndex].swiperSlideSize;
                let breakLoop;
                for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                }
                for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                }
            } else {
                if (view === 'current') {
                    for (let i = activeIndex + 1; i < slides.length; i += 1) {
                        const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                        if (slideInView) {
                            spv += 1;
                        }
                    }
                } else {
                    for (let i = activeIndex - 1; i >= 0; i -= 1) {
                        const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                        if (slideInView) {
                            spv += 1;
                        }
                    }
                }
            }
            return spv;
        }
        update() {
            const swiper = this;
            if (!swiper || swiper.destroyed) return;
            const {
                snapGrid,
                params
            } = swiper; 
            if (params.breakpoints) {
                swiper.setBreakpoint();
            }
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
            function setTranslate() {
                const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                swiper.setTranslate(newTranslate);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            let translated;
            if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
                setTranslate();
                if (swiper.params.autoHeight) {
                    swiper.updateAutoHeight();
                }
            } else {
                if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                    translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
                } else {
                    translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                }
                if (!translated) {
                    setTranslate();
                }
            }
            if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
                swiper.checkOverflow();
            }
            swiper.emit('update');
        }
        changeDirection(newDirection, needUpdate) {
            if (needUpdate === void 0) {
                needUpdate = true;
            }
            const swiper = this;
            const currentDirection = swiper.params.direction;
            if (!newDirection) {
                newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
            }
            if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
                return swiper;
            }
            swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
            swiper.emitContainerClasses();
            swiper.params.direction = newDirection;
            swiper.slides.each(slideEl => {
                if (newDirection === 'vertical') {
                    slideEl.style.width = '';
                } else {
                    slideEl.style.height = '';
                }
            });
            swiper.emit('changeDirection');
            if (needUpdate) swiper.update();
            return swiper;
        }
        mount(el) {
            const swiper = this;
            if (swiper.mounted) return true; 
            const $el = $(el || swiper.params.el);
            el = $el[0];
            if (!el) {
                return false;
            }
            el.swiper = swiper;
            const getWrapperSelector = () => {
                return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
            };
            const getWrapper = () => {
                if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                    const res = $(el.shadowRoot.querySelector(getWrapperSelector())); 
                    res.children = options => $el.children(options);
                    return res;
                }
                return $el.children(getWrapperSelector());
            }; 
            let $wrapperEl = getWrapper();
            if ($wrapperEl.length === 0 && swiper.params.createElements) {
                const document = getDocument();
                const wrapper = document.createElement('div');
                $wrapperEl = $(wrapper);
                wrapper.className = swiper.params.wrapperClass;
                $el.append(wrapper);
                $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
                    $wrapperEl.append(slideEl);
                });
            }
            Object.assign(swiper, {
                $el,
                el,
                $wrapperEl,
                wrapperEl: $wrapperEl[0],
                mounted: true,
                rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
                rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
                wrongRTL: $wrapperEl.css('display') === '-webkit-box'
            });
            return true;
        }
        init(el) {
            const swiper = this;
            if (swiper.initialized) return swiper;
            const mounted = swiper.mount(el);
            if (mounted === false) return swiper;
            swiper.emit('beforeInit'); 
            if (swiper.params.breakpoints) {
                swiper.setBreakpoint();
            } 
            swiper.addClasses(); 
            if (swiper.params.loop) {
                swiper.loopCreate();
            } 
            swiper.updateSize(); 
            swiper.updateSlides();
            if (swiper.params.watchOverflow) {
                swiper.checkOverflow();
            } 
            if (swiper.params.grabCursor && swiper.enabled) {
                swiper.setGrabCursor();
            }
            if (swiper.params.preloadImages) {
                swiper.preloadImages();
            } 
            if (swiper.params.loop) {
                swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
            } else {
                swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
            } 
            swiper.attachEvents(); 
            swiper.initialized = true; 
            swiper.emit('init');
            swiper.emit('afterInit');
            return swiper;
        }
        destroy(deleteInstance, cleanStyles) {
            if (deleteInstance === void 0) {
                deleteInstance = true;
            }
            if (cleanStyles === void 0) {
                cleanStyles = true;
            }
            const swiper = this;
            const {
                params,
                $el,
                $wrapperEl,
                slides
            } = swiper;
            if (typeof swiper.params === 'undefined' || swiper.destroyed) {
                return null;
            }
            swiper.emit('beforeDestroy'); 
            swiper.initialized = false; 
            swiper.detachEvents(); 
            if (params.loop) {
                swiper.loopDestroy();
            } 
            if (cleanStyles) {
                swiper.removeClasses();
                $el.removeAttr('style');
                $wrapperEl.removeAttr('style');
                if (slides && slides.length) {
                    slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
                }
            }
            swiper.emit('destroy'); 
            Object.keys(swiper.eventsListeners).forEach(eventName => {
                swiper.off(eventName);
            });
            if (deleteInstance !== false) {
                swiper.$el[0].swiper = null;
                deleteProps(swiper);
            }
            swiper.destroyed = true;
            return null;
        }
        static extendDefaults(newDefaults) {
            extend(extendedDefaults, newDefaults);
        }
        static get extendedDefaults() {
            return extendedDefaults;
        }
        static get defaults() {
            return defaults;
        }
        static installModule(mod) {
            if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
            const modules = Swiper.prototype.__modules__;
            if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
                modules.push(mod);
            }
        }
        static use(module) {
            if (Array.isArray(module)) {
                module.forEach(m => Swiper.installModule(m));
                return Swiper;
            }
            Swiper.installModule(module);
            return Swiper;
        }
    }
    Object.keys(prototypes).forEach(prototypeGroup => {
        Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        });
    });
    Swiper.use([Resize, Observer]);
    function Virtual(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        extendParams({
            virtual: {
                enabled: false,
                slides: [],
                cache: true,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: true,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        });
        let cssModeTimeout;
        swiper.virtual = {
            cache: {},
            from: undefined,
            to: undefined,
            slides: [],
            offset: 0,
            slidesGrid: []
        };
        function renderSlide(slide, index) {
            const params = swiper.params.virtual;
            if (params.cache && swiper.virtual.cache[index]) {
                return swiper.virtual.cache[index];
            }
            const $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
            if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
            if (params.cache) swiper.virtual.cache[index] = $slideEl;
            return $slideEl;
        }
        function update(force) {
            const {
                slidesPerView,
                slidesPerGroup,
                centeredSlides
            } = swiper.params;
            const {
                addSlidesBefore,
                addSlidesAfter
            } = swiper.params.virtual;
            const {
                from: previousFrom,
                to: previousTo,
                slides,
                slidesGrid: previousSlidesGrid,
                offset: previousOffset
            } = swiper.virtual;
            if (!swiper.params.cssMode) {
                swiper.updateActiveIndex();
            }
            const activeIndex = swiper.activeIndex || 0;
            let offsetProp;
            if (swiper.rtlTranslate) offsetProp = 'right'; else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
            let slidesAfter;
            let slidesBefore;
            if (centeredSlides) {
                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
            } else {
                slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
                slidesBefore = slidesPerGroup + addSlidesBefore;
            }
            const from = Math.max((activeIndex || 0) - slidesBefore, 0);
            const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
            const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
            Object.assign(swiper.virtual, {
                from,
                to,
                offset,
                slidesGrid: swiper.slidesGrid
            });
            function onRendered() {
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                if (swiper.lazy && swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
                emit('virtualUpdate');
            }
            if (previousFrom === from && previousTo === to && !force) {
                if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                    swiper.slides.css(offsetProp, `${offset}px`);
                }
                swiper.updateProgress();
                emit('virtualUpdate');
                return;
            }
            if (swiper.params.virtual.renderExternal) {
                swiper.params.virtual.renderExternal.call(swiper, {
                    offset,
                    from,
                    to,
                    slides: function getSlides() {
                        const slidesToRender = [];
                        for (let i = from; i <= to; i += 1) {
                            slidesToRender.push(slides[i]);
                        }
                        return slidesToRender;
                    }()
                });
                if (swiper.params.virtual.renderExternalUpdate) {
                    onRendered();
                } else {
                    emit('virtualUpdate');
                }
                return;
            }
            const prependIndexes = [];
            const appendIndexes = [];
            if (force) {
                swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
            } else {
                for (let i = previousFrom; i <= previousTo; i += 1) {
                    if (i < from || i > to) {
                        swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
                    }
                }
            }
            for (let i = 0; i < slides.length; i += 1) {
                if (i >= from && i <= to) {
                    if (typeof previousTo === 'undefined' || force) {
                        appendIndexes.push(i);
                    } else {
                        if (i > previousTo) appendIndexes.push(i);
                        if (i < previousFrom) prependIndexes.push(i);
                    }
                }
            }
            appendIndexes.forEach(index => {
                swiper.$wrapperEl.append(renderSlide(slides[index], index));
            });
            prependIndexes.sort((a, b) => b - a).forEach(index => {
                swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
            });
            swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
            onRendered();
        }
        function appendSlide(slides) {
            if (typeof slides === 'object' && 'length' in slides) {
                for (let i = 0; i < slides.length; i += 1) {
                    if (slides[i]) swiper.virtual.slides.push(slides[i]);
                }
            } else {
                swiper.virtual.slides.push(slides);
            }
            update(true);
        }
        function prependSlide(slides) {
            const activeIndex = swiper.activeIndex;
            let newActiveIndex = activeIndex + 1;
            let numberOfNewSlides = 1;
            if (Array.isArray(slides)) {
                for (let i = 0; i < slides.length; i += 1) {
                    if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
                }
                newActiveIndex = activeIndex + slides.length;
                numberOfNewSlides = slides.length;
            } else {
                swiper.virtual.slides.unshift(slides);
            }
            if (swiper.params.virtual.cache) {
                const cache = swiper.virtual.cache;
                const newCache = {};
                Object.keys(cache).forEach(cachedIndex => {
                    const $cachedEl = cache[cachedIndex];
                    const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
                    if (cachedElIndex) {
                        $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
                    }
                    newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
                });
                swiper.virtual.cache = newCache;
            }
            update(true);
            swiper.slideTo(newActiveIndex, 0);
        }
        function removeSlide(slidesIndexes) {
            if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
            let activeIndex = swiper.activeIndex;
            if (Array.isArray(slidesIndexes)) {
                for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
                    swiper.virtual.slides.splice(slidesIndexes[i], 1);
                    if (swiper.params.virtual.cache) {
                        delete swiper.virtual.cache[slidesIndexes[i]];
                    }
                    if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
                    activeIndex = Math.max(activeIndex, 0);
                }
            } else {
                swiper.virtual.slides.splice(slidesIndexes, 1);
                if (swiper.params.virtual.cache) {
                    delete swiper.virtual.cache[slidesIndexes];
                }
                if (slidesIndexes < activeIndex) activeIndex -= 1;
                activeIndex = Math.max(activeIndex, 0);
            }
            update(true);
            swiper.slideTo(activeIndex, 0);
        }
        function removeAllSlides() {
            swiper.virtual.slides = [];
            if (swiper.params.virtual.cache) {
                swiper.virtual.cache = {};
            }
            update(true);
            swiper.slideTo(0, 0);
        }
        on('beforeInit', () => {
            if (!swiper.params.virtual.enabled) return;
            swiper.virtual.slides = swiper.params.virtual.slides;
            swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
            if (!swiper.params.initialSlide) {
                update();
            }
        });
        on('setTranslate', () => {
            if (!swiper.params.virtual.enabled) return;
            if (swiper.params.cssMode && !swiper._immediateVirtual) {
                clearTimeout(cssModeTimeout);
                cssModeTimeout = setTimeout(() => {
                    update();
                }, 100);
            } else {
                update();
            }
        });
        on('init update resize', () => {
            if (!swiper.params.virtual.enabled) return;
            if (swiper.params.cssMode) {
                setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
            }
        });
        Object.assign(swiper.virtual, {
            appendSlide,
            prependSlide,
            removeSlide,
            removeAllSlides,
            update
        });
    }
    /* eslint-disable consistent-return */
    function Keyboard(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const document = getDocument();
        const window = getWindow();
        swiper.keyboard = {
            enabled: false
        };
        extendParams({
            keyboard: {
                enabled: false,
                onlyInViewport: true,
                pageUpDown: true
            }
        });
        function handle(event) {
            if (!swiper.enabled) return;
            const {
                rtlTranslate: rtl
            } = swiper;
            let e = event;
            if (e.originalEvent) e = e.originalEvent; 
            const kc = e.keyCode || e.charCode;
            const pageUpDown = swiper.params.keyboard.pageUpDown;
            const isPageUp = pageUpDown && kc === 33;
            const isPageDown = pageUpDown && kc === 34;
            const isArrowLeft = kc === 37;
            const isArrowRight = kc === 39;
            const isArrowUp = kc === 38;
            const isArrowDown = kc === 40; 
            if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
                return false;
            }
            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return undefined;
            }
            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
                return undefined;
            }
            if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
                let inView = false; 
                if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
                    return undefined;
                }
                const $el = swiper.$el;
                const swiperWidth = $el[0].clientWidth;
                const swiperHeight = $el[0].clientHeight;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const swiperOffset = swiper.$el.offset();
                if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
                const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
                for (let i = 0; i < swiperCoord.length; i += 1) {
                    const point = swiperCoord[i];
                    if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                        if (point[0] === 0 && point[1] === 0) continue; 
                        inView = true;
                    }
                }
                if (!inView) return undefined;
            }
            if (swiper.isHorizontal()) {
                if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                    axPreventDefault(e);
                }
                if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
                if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
            } else {
                if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                    axPreventDefault(e);
                }
                if (isPageDown || isArrowDown) swiper.slideNext();
                if (isPageUp || isArrowUp) swiper.slidePrev();
            }
            emit('keyPress', kc);
            return undefined;
        }
        function enable() {
            if (swiper.keyboard.enabled) return;
            $(document).on('keydown', handle);
            swiper.keyboard.enabled = true;
        }
        function disable() {
            if (!swiper.keyboard.enabled) return;
            $(document).off('keydown', handle);
            swiper.keyboard.enabled = false;
        }
        on('init', () => {
            if (swiper.params.keyboard.enabled) {
                enable();
            }
        });
        on('destroy', () => {
            if (swiper.keyboard.enabled) {
                disable();
            }
        });
        Object.assign(swiper.keyboard, {
            enable,
            disable
        });
    }
    /* eslint-disable consistent-return */
    function Mousewheel(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const window = getWindow();
        extendParams({
            mousewheel: {
                enabled: false,
                releaseOnEdges: false,
                invert: false,
                forceToAxis: false,
                sensitivity: 1,
                eventsTarget: 'container',
                thresholdDelta: null,
                thresholdTime: null
            }
        });
        swiper.mousewheel = {
            enabled: false
        };
        let timeout;
        let lastScrollTime = now();
        let lastEventBeforeSnap;
        const recentWheelEvents = [];
        function normalize(e) {
            const PIXEL_STEP = 10;
            const LINE_HEIGHT = 40;
            const PAGE_HEIGHT = 800;
            let sX = 0;
            let sY = 0; 
            let pX = 0;
            let pY = 0; 
            if ('detail' in e) {
                sY = e.detail;
            }
            if ('wheelDelta' in e) {
                sY = -e.wheelDelta / 120;
            }
            if ('wheelDeltaY' in e) {
                sY = -e.wheelDeltaY / 120;
            }
            if ('wheelDeltaX' in e) {
                sX = -e.wheelDeltaX / 120;
            } 
            if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
                sX = sY;
                sY = 0;
            }
            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;
            if ('deltaY' in e) {
                pY = e.deltaY;
            }
            if ('deltaX' in e) {
                pX = e.deltaX;
            }
            if (e.shiftKey && !pX) {
                pX = pY;
                pY = 0;
            }
            if ((pX || pY) && e.deltaMode) {
                if (e.deltaMode === 1) {
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            } 
            if (pX && !sX) {
                sX = pX < 1 ? -1 : 1;
            }
            if (pY && !sY) {
                sY = pY < 1 ? -1 : 1;
            }
            return {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY
            };
        }
        function handleMouseEnter() {
            if (!swiper.enabled) return;
            swiper.mouseEntered = true;
        }
        function handleMouseLeave() {
            if (!swiper.enabled) return;
            swiper.mouseEntered = false;
        }
        function animateSlider(newEvent) {
            if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
                return false;
            }
            if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
                return false;
            } 
            if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
                return true;
            } 
            if (newEvent.direction < 0) {
                if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                    swiper.slideNext();
                    emit('scroll', newEvent.raw);
                }
            } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                swiper.slidePrev();
                emit('scroll', newEvent.raw);
            } 
            lastScrollTime = new window.Date().getTime(); 
            return false;
        }
        function releaseScroll(newEvent) {
            const params = swiper.params.mousewheel;
            if (newEvent.direction < 0) {
                if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                    return true;
                }
            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
                return true;
            }
            return false;
        }
        function handle(event) {
            let e = event;
            let disableParentSwiper = true;
            if (!swiper.enabled) return;
            const params = swiper.params.mousewheel;
            if (swiper.params.cssMode) {
                axPreventDefault(e);
            }
            let target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarget !== 'container') {
                target = $(swiper.params.mousewheel.eventsTarget);
            }
            if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
            if (e.originalEvent) e = e.originalEvent; 
            let delta = 0;
            const rtlFactor = swiper.rtlTranslate ? -1 : 1;
            const data = normalize(e);
            if (params.forceToAxis) {
                if (swiper.isHorizontal()) {
                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor; else return true;
                } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY; else return true;
            } else {
                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            }
            if (delta === 0) return true;
            if (params.invert) delta = -delta; 
            let positions = swiper.getTranslate() + delta * params.sensitivity;
            if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
            if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); 
            disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
            if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
            if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
                const newEvent = {
                    time: now(),
                    delta: Math.abs(delta),
                    direction: Math.sign(delta),
                    raw: event
                }; 
                if (recentWheelEvents.length >= 2) {
                    recentWheelEvents.shift(); 
                }
                const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                recentWheelEvents.push(newEvent); 
                if (prevEvent) {
                    if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                        animateSlider(newEvent);
                    }
                } else {
                    animateSlider(newEvent);
                } 
                if (releaseScroll(newEvent)) {
                    return true;
                }
            } else {
                const newEvent = {
                    time: now(),
                    delta: Math.abs(delta),
                    direction: Math.sign(delta)
                };
                const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
                if (!ignoreWheelEvents) {
                    lastEventBeforeSnap = undefined;
                    if (swiper.params.loop) {
                        swiper.loopFix();
                    }
                    let position = swiper.getTranslate() + delta * params.sensitivity;
                    const wasBeginning = swiper.isBeginning;
                    const wasEnd = swiper.isEnd;
                    if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                    if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                    swiper.setTransition(0);
                    swiper.setTranslate(position);
                    swiper.updateProgress();
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                    if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                        swiper.updateSlidesClasses();
                    }
                    if (swiper.params.freeMode.sticky) {
                        clearTimeout(timeout);
                        timeout = undefined;
                        if (recentWheelEvents.length >= 15) {
                            recentWheelEvents.shift(); 
                        }
                        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                        const firstEvent = recentWheelEvents[0];
                        recentWheelEvents.push(newEvent);
                        if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                            recentWheelEvents.splice(0);
                        } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                            lastEventBeforeSnap = newEvent;
                            recentWheelEvents.splice(0);
                            timeout = nextTick(() => {
                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                            }, 0); 
                        }
                        if (!timeout) {
                            timeout = nextTick(() => {
                                const snapToThreshold = 0.5;
                                lastEventBeforeSnap = newEvent;
                                recentWheelEvents.splice(0);
                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                            }, 500);
                        }
                    } 
                    if (!ignoreWheelEvents) emit('scroll', e); 
                    if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); 
                    if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
                }
            }
            axPreventDefault(e);
            return false;
        }
        function events(method) {
            let target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarget !== 'container') {
                target = $(swiper.params.mousewheel.eventsTarget);
            }
            target[method]('mouseenter', handleMouseEnter);
            target[method]('mouseleave', handleMouseLeave);
            target[method]('wheel', handle);
        }
        function enable() {
            if (swiper.params.cssMode) {
                swiper.wrapperEl.removeEventListener('wheel', handle);
                return true;
            }
            if (swiper.mousewheel.enabled) return false;
            events('on');
            swiper.mousewheel.enabled = true;
            return true;
        }
        function disable() {
            if (swiper.params.cssMode) {
                swiper.wrapperEl.addEventListener(event, handle);
                return true;
            }
            if (!swiper.mousewheel.enabled) return false;
            events('off');
            swiper.mousewheel.enabled = false;
            return true;
        }
        on('init', () => {
            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
                disable();
            }
            if (swiper.params.mousewheel.enabled) enable();
        });
        on('destroy', () => {
            if (swiper.params.cssMode) {
                enable();
            }
            if (swiper.mousewheel.enabled) disable();
        });
        Object.assign(swiper.mousewheel, {
            enable,
            disable
        });
    }
    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
        const document = getDocument();
        if (swiper.params.createElements) {
            Object.keys(checkProps).forEach(key => {
                if (!params[key] && params.auto === true) {
                    let element = swiper.$el.children(`.${checkProps[key]}`)[0];
                    if (!element) {
                        element = document.createElement('div');
                        element.className = checkProps[key];
                        swiper.$el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            });
        }
        return params;
    }
    function Navigation(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        extendParams({
            navigation: {
                nextEl: '.ax-next',
                prevEl: '.ax-prev',
                hideOnClick: false,
                disabledClass: 'ax-disabled',
                hiddenClass: 'ax-hidden',
                lockClass: 'ax-lock'
            }
        });
        swiper.navigation = {
            nextEl: null,
            $nextEl: null,
            prevEl: null,
            $prevEl: null
        };
        function getEl(el) {
            let $el;
            if (el) {
                $el = $(el);
                if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
                    $el = swiper.$el.find(el);
                }
            }
            return $el;
        }
        function toggleEl($el, disabled) {
            const params = swiper.params.navigation;
            if ($el && $el.length > 0) {
                $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
                if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
                if (swiper.params.watchOverflow && swiper.enabled) {
                    $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
                }
            }
        }
        function update() {
            if (swiper.params.loop) return;
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
            toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
        }
        function onPrevClick(e) {
            axPreventDefault(e);
            if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
            swiper.slidePrev();
        }
        function onNextClick(e) {
            axPreventDefault(e);
            if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
            swiper.slideNext();
        }
        function init() {
            const params = swiper.params.navigation;
            swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                nextEl: 'ax-next',
                prevEl: 'ax-prev'
            });
            if (!(params.nextEl || params.prevEl)) return;
            const $nextEl = getEl(params.nextEl);
            const $prevEl = getEl(params.prevEl);
            if ($nextEl && $nextEl.length > 0) {
                $nextEl.on('click', onNextClick);
            }
            if ($prevEl && $prevEl.length > 0) {
                $prevEl.on('click', onPrevClick);
            }
            Object.assign(swiper.navigation, {
                $nextEl,
                nextEl: $nextEl && $nextEl[0],
                $prevEl,
                prevEl: $prevEl && $prevEl[0]
            });
            if (!swiper.enabled) {
                if ($nextEl) $nextEl.addClass(params.lockClass);
                if ($prevEl) $prevEl.addClass(params.lockClass);
            }
        }
        function destroy() {
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            if ($nextEl && $nextEl.length) {
                $nextEl.off('click', onNextClick);
                $nextEl.removeClass(swiper.params.navigation.disabledClass);
            }
            if ($prevEl && $prevEl.length) {
                $prevEl.off('click', onPrevClick);
                $prevEl.removeClass(swiper.params.navigation.disabledClass);
            }
        }
        on('init', () => {
            init();
            update();
        });
        on('toEdge fromEdge lock unlock', () => {
            update();
        });
        on('destroy', () => {
            destroy();
        });
        on('enable disable', () => {
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            if ($nextEl) {
                $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
            }
            if ($prevEl) {
                $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
            }
        });
        on('click', (_s, e) => {
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            const targetEl = e.target;
            if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                let isHidden;
                if ($nextEl) {
                    isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
                } else if ($prevEl) {
                    isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
                }
                if (isHidden === true) {
                    emit('navigationShow');
                } else {
                    emit('navigationHide');
                }
                if ($nextEl) {
                    $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
                if ($prevEl) {
                    $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
            }
        });
        Object.assign(swiper.navigation, {
            update,
            init,
            destroy
        });
    }
    function classesToSelector(classes) {
        if (classes === void 0) {
            classes = '';
        }
        return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') 
            .replace(/ /g, '.')}`;
    }
    function Pagination(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const pfx = 'ax-pages';
        extendParams({
            pagination: {
                el: '.' + pfx,
                bulletElement: 'i',
                clickable: true,
                hideOnClick: false,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: false,
                type: 'bullets',
                dynamicBullets: false,
                dynamicMainBullets: 1,
                formatFractionCurrent: number => number,
                formatFractionTotal: number => number,
                bulletClass: `${pfx}-bullet`,
                bulletActiveClass: `${pfx}-bullet-active`,
                modifierClass: `${pfx}-`,
                currentClass: `${pfx}-current`,
                totalClass: `${pfx}-total`,
                hiddenClass: `${pfx}-hidden`,
                progressbarFillClass: `${pfx}-progressbar-fill`,
                progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                clickableClass: `${pfx}-clickable`,
                lockClass: `${pfx}-lock`,
                horizontalClass: `${pfx}-horizontal`,
                verticalClass: `${pfx}-vertical`
            }
        });
        swiper.pagination = {
            el: null,
            $el: null,
            bullets: []
        };
        let bulletSize;
        let dynamicBulletIndex = 0;
        function isPaginationDisabled() {
            return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
        }
        function setSideBullets($bulletEl, position) {
            const {
                bulletActiveClass
            } = swiper.params.pagination;
            $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
        }
        function update() {
            const rtl = swiper.rtl;
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            const $el = swiper.pagination.$el; 
            let current;
            const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.loop) {
                current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
                if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
                    current -= slidesLength - swiper.loopedSlides * 2;
                }
                if (current > total - 1) current -= total;
                if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
            } else if (typeof swiper.snapIndex !== 'undefined') {
                current = swiper.snapIndex;
            } else {
                current = swiper.activeIndex || 0;
            } 
            if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                const bullets = swiper.pagination.bullets;
                let firstIndex;
                let lastIndex;
                let midIndex;
                if (params.dynamicBullets) {
                    bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
                    $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);
                    if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
                        dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
                        if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                            dynamicBulletIndex = params.dynamicMainBullets - 1;
                        } else if (dynamicBulletIndex < 0) {
                            dynamicBulletIndex = 0;
                        }
                    }
                    firstIndex = Math.max(current - dynamicBulletIndex, 0);
                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                    midIndex = (lastIndex + firstIndex) / 2;
                }
                bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));
                if ($el.length > 1) {
                    bullets.each(bullet => {
                        const $bullet = $(bullet);
                        const bulletIndex = $bullet.index();
                        if (bulletIndex === current) {
                            $bullet.addClass(params.bulletActiveClass);
                        }
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                                $bullet.addClass(`${params.bulletActiveClass}-main`);
                            }
                            if (bulletIndex === firstIndex) {
                                setSideBullets($bullet, 'prev');
                            }
                            if (bulletIndex === lastIndex) {
                                setSideBullets($bullet, 'next');
                            }
                        }
                    });
                } else {
                    const $bullet = bullets.eq(current);
                    const bulletIndex = $bullet.index();
                    $bullet.addClass(params.bulletActiveClass);
                    if (params.dynamicBullets) {
                        const $firstDisplayedBullet = bullets.eq(firstIndex);
                        const $lastDisplayedBullet = bullets.eq(lastIndex);
                        for (let i = firstIndex; i <= lastIndex; i += 1) {
                            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
                        }
                        if (swiper.params.loop) {
                            if (bulletIndex >= bullets.length) {
                                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                                    bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                                }
                                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                            } else {
                                setSideBullets($firstDisplayedBullet, 'prev');
                                setSideBullets($lastDisplayedBullet, 'next');
                            }
                        } else {
                            setSideBullets($firstDisplayedBullet, 'prev');
                            setSideBullets($lastDisplayedBullet, 'next');
                        }
                    }
                }
                if (params.dynamicBullets) {
                    const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                    const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                    const offsetProp = rtl ? 'right' : 'left';
                    bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
                }
            }
            if (params.type === 'fraction') {
                $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
                $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
            }
            if (params.type === 'progressbar') {
                let progressbarDirection;
                if (params.progressbarOpposite) {
                    progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
                } else {
                    progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
                }
                const scale = (current + 1) / total;
                let scaleX = 1;
                let scaleY = 1;
                if (progressbarDirection === 'horizontal') {
                    scaleX = scale;
                } else {
                    scaleY = scale;
                }
                $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
            }
            if (params.type === 'custom' && params.renderCustom) {
                $el.html(params.renderCustom(swiper, current + 1, total));
                emit('paginationRender', $el[0]);
            } else {
                emit('paginationUpdate', $el[0]);
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
            }
        }
        function render() {
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            const $el = swiper.pagination.$el;
            let paginationHTML = '';
            if (params.type === 'bullets') {
                let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
                    numberOfBullets = slidesLength;
                }
                for (let i = 0; i < numberOfBullets; i += 1) {
                    if (params.renderBullet) {
                        paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
                    } else {
                        paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
                    }
                }
                $el.html(paginationHTML);
                swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
            }
            if (params.type === 'fraction') {
                if (params.renderFraction) {
                    paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
                } else {
                    paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
                }
                $el.html(paginationHTML);
            }
            if (params.type === 'progressbar') {
                if (params.renderProgressbar) {
                    paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
                } else {
                    paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                }
                $el.html(paginationHTML);
            }
            if (params.type !== 'custom') {
                emit('paginationRender', swiper.pagination.$el[0]);
            }
        }
        function init() {
            swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                el: 'ax-pages'
            });
            const params = swiper.params.pagination;
            if (!params.el) return;
            let $el = $(params.el);
            if ($el.length === 0) return;
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
                $el = swiper.$el.find(params.el); 
                if ($el.length > 1) {
                    $el = $el.filter(el => {
                        if ($(el).parents('.swiper')[0] !== swiper.el) return false;
                        return true;
                    });
                }
            }
            if (params.type === 'bullets' && params.clickable) {
                $el.addClass(params.clickableClass);
            }
            $el.addClass(params.modifierClass + params.type);
            $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            if (params.type === 'bullets' && params.dynamicBullets) {
                $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
                dynamicBulletIndex = 0;
                if (params.dynamicMainBullets < 1) {
                    params.dynamicMainBullets = 1;
                }
            }
            if (params.type === 'progressbar' && params.progressbarOpposite) {
                $el.addClass(params.progressbarOppositeClass);
            }
            if (params.clickable) {
                $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
                    axPreventDefault(e);
                    let index = $(this).index() * swiper.params.slidesPerGroup;
                    if (swiper.params.loop) index += swiper.loopedSlides;
                    swiper.slideTo(index);
                });
            }
            Object.assign(swiper.pagination, {
                $el,
                el: $el[0]
            });
            if (!swiper.enabled) {
                $el.addClass(params.lockClass);
            }
        }
        function destroy() {
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const $el = swiper.pagination.$el;
            $el.removeClass(params.hiddenClass);
            $el.removeClass(params.modifierClass + params.type);
            $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
            if (params.clickable) {
                $el.off('click', classesToSelector(params.bulletClass));
            }
        }
        on('init', () => {
            init();
            render();
            update();
        });
        on('activeIndexChange', () => {
            if (swiper.params.loop) {
                update();
            } else if (typeof swiper.snapIndex === 'undefined') {
                update();
            }
        });
        on('snapIndexChange', () => {
            if (!swiper.params.loop) {
                update();
            }
        });
        on('slidesLengthChange', () => {
            if (swiper.params.loop) {
                render();
                update();
            }
        });
        on('snapGridLengthChange', () => {
            if (!swiper.params.loop) {
                render();
                update();
            }
        });
        on('destroy', () => {
            destroy();
        });
        on('enable disable', () => {
            const {
                $el
            } = swiper.pagination;
            if ($el) {
                $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
            }
        });
        on('lock unlock', () => {
            update();
        });
        on('click', (_s, e) => {
            const targetEl = e.target;
            const {
                $el
            } = swiper.pagination;
            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
                if (isHidden === true) {
                    emit('paginationShow');
                } else {
                    emit('paginationHide');
                }
                $el.toggleClass(swiper.params.pagination.hiddenClass);
            }
        });
        Object.assign(swiper.pagination, {
            render,
            update,
            init,
            destroy
        });
    }
    function Scrollbar(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const document = getDocument();
        let isTouched = false;
        let timeout = null;
        let dragTimeout = null;
        let dragStartPos;
        let dragSize;
        let trackSize;
        let divider;
        extendParams({
            scrollbar: {
                el: '.ax-scrollbar',
                dragSize: 'auto',
                hide: true,
                draggable: true,
                snapOnRelease: true,
                lockClass: 'ax-scrollbar-lock',
                dragClass: 'ax-scrollbar-drag'
            }
        });
        swiper.scrollbar = {
            el: null,
            dragEl: null,
            $el: null,
            $dragEl: null
        };
        function setTranslate() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
                scrollbar,
                rtlTranslate: rtl,
                progress
            } = swiper;
            const {
                $dragEl,
                $el
            } = scrollbar;
            const params = swiper.params.scrollbar;
            let newSize = dragSize;
            let newPos = (trackSize - dragSize) * progress;
            if (rtl) {
                newPos = -newPos;
                if (newPos > 0) {
                    newSize = dragSize - newPos;
                    newPos = 0;
                } else if (-newPos + dragSize > trackSize) {
                    newSize = trackSize + newPos;
                }
            } else if (newPos < 0) {
                newSize = dragSize + newPos;
                newPos = 0;
            } else if (newPos + dragSize > trackSize) {
                newSize = trackSize - newPos;
            }
            if (swiper.isHorizontal()) {
                $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
                $dragEl[0].style.width = `${newSize}px`;
            } else {
                $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
                $dragEl[0].style.height = `${newSize}px`;
            }
            if (params.hide) {
                clearTimeout(timeout);
                $el[0].style.opacity = 1;
                timeout = setTimeout(() => {
                    $el[0].style.opacity = 0;
                    $el.transition(400);
                }, 1000);
            }
        }
        function setTransition(duration) {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            swiper.scrollbar.$dragEl.transition(duration);
        }
        function updateSize() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
                scrollbar
            } = swiper;
            const {
                $dragEl,
                $el
            } = scrollbar;
            $dragEl[0].style.width = '';
            $dragEl[0].style.height = '';
            trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
            divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
            if (swiper.params.scrollbar.dragSize === 'auto') {
                dragSize = trackSize * divider;
            } else {
                dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
            }
            if (swiper.isHorizontal()) {
                $dragEl[0].style.width = `${dragSize}px`;
            } else {
                $dragEl[0].style.height = `${dragSize}px`;
            }
            if (divider >= 1) {
                $el[0].style.display = 'none';
            } else {
                $el[0].style.display = '';
            }
            if (swiper.params.scrollbar.hide) {
                $el[0].style.opacity = 0;
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
            }
        }
        function getPointerPosition(e) {
            if (swiper.isHorizontal()) {
                return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
            }
            return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
        }
        function setDragPosition(e) {
            const {
                scrollbar,
                rtlTranslate: rtl
            } = swiper;
            const {
                $el
            } = scrollbar;
            let positionRatio;
            positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
            positionRatio = Math.max(Math.min(positionRatio, 1), 0);
            if (rtl) {
                positionRatio = 1 - positionRatio;
            }
            const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
            swiper.updateProgress(position);
            swiper.setTranslate(position);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        function onDragStart(e) {
            const params = swiper.params.scrollbar;
            const {
                scrollbar,
                $wrapperEl
            } = swiper;
            const {
                $el,
                $dragEl
            } = scrollbar;
            isTouched = true;
            dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
            axPreventDefault(e);
            e.stopPropagation();
            $wrapperEl.transition(100);
            $dragEl.transition(100);
            setDragPosition(e);
            clearTimeout(dragTimeout);
            $el.transition(0);
            if (params.hide) {
                $el.css('opacity', 1);
            }
            if (swiper.params.cssMode) {
                swiper.$wrapperEl.css('scroll-snap-type', 'none');
            }
            emit('scrollbarDragStart', e);
        }
        function onDragMove(e) {
            const {
                scrollbar,
                $wrapperEl
            } = swiper;
            const {
                $el,
                $dragEl
            } = scrollbar;
            if (!isTouched) return;
            axPreventDefault(e);
            setDragPosition(e);
            $wrapperEl.transition(0);
            $el.transition(0);
            $dragEl.transition(0);
            emit('scrollbarDragMove', e);
        }
        function onDragEnd(e) {
            const params = swiper.params.scrollbar;
            const {
                scrollbar,
                $wrapperEl
            } = swiper;
            const {
                $el
            } = scrollbar;
            if (!isTouched) return;
            isTouched = false;
            if (swiper.params.cssMode) {
                swiper.$wrapperEl.css('scroll-snap-type', '');
                $wrapperEl.transition('');
            }
            if (params.hide) {
                clearTimeout(dragTimeout);
                dragTimeout = nextTick(() => {
                    $el.css('opacity', 0);
                    $el.transition(400);
                }, 1000);
            }
            emit('scrollbarDragEnd', e);
            if (params.snapOnRelease) {
                swiper.slideToClosest();
            }
        }
        function events(method) {
            const {
                scrollbar,
                touchEventsTouch,
                touchEventsDesktop,
                params,
                support
            } = swiper;
            const $el = scrollbar.$el;
            const target = $el[0];
            const activeListener = support.passiveListener && params.passiveListeners ? {
                passive: false,
                capture: false
            } : false;
            const passiveListener = support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (!target) return;
            const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
            if (!support.touch) {
                target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
                document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
                document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
            } else {
                target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
                target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
                target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
            }
        }
        function enableDraggable() {
            if (!swiper.params.scrollbar.el) return;
            events('on');
        }
        function disableDraggable() {
            if (!swiper.params.scrollbar.el) return;
            events('off');
        }
        function init() {
            const {
                scrollbar,
                $el: $swiperEl
            } = swiper;
            swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
                el: 'ax-scrollbar'
            });
            const params = swiper.params.scrollbar;
            if (!params.el) return;
            let $el = $(params.el);
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
                $el = $swiperEl.find(params.el);
            }
            let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
            if ($dragEl.length === 0) {
                $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
                $el.append($dragEl);
            }
            Object.assign(scrollbar, {
                $el,
                el: $el[0],
                $dragEl,
                dragEl: $dragEl[0]
            });
            if (params.draggable) {
                enableDraggable();
            }
            if ($el) {
                $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
            }
        }
        function destroy() {
            disableDraggable();
        }
        on('init', () => {
            init();
            updateSize();
            setTranslate();
        });
        on('update resize observerUpdate lock unlock', () => {
            updateSize();
        });
        on('setTranslate', () => {
            setTranslate();
        });
        on('setTransition', (_s, duration) => {
            setTransition(duration);
        });
        on('enable disable', () => {
            const {
                $el
            } = swiper.scrollbar;
            if ($el) {
                $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
            }
        });
        on('destroy', () => {
            destroy();
        });
        Object.assign(swiper.scrollbar, {
            updateSize,
            setTranslate,
            init,
            destroy
        });
    }
    function Parallax(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            parallax: {
                enabled: false
            }
        });
        const setTransform = (el, progress) => {
            const {
                rtl
            } = swiper;
            const $el = $(el);
            const rtlFactor = rtl ? -1 : 1;
            const p = $el.attr('data-swiper-parallax') || '0';
            let x = $el.attr('data-swiper-parallax-x');
            let y = $el.attr('data-swiper-parallax-y');
            const scale = $el.attr('data-swiper-parallax-scale');
            const opacity = $el.attr('data-swiper-parallax-opacity');
            if (x || y) {
                x = x || '0';
                y = y || '0';
            } else if (swiper.isHorizontal()) {
                x = p;
                y = '0';
            } else {
                y = p;
                x = '0';
            }
            if (x.indexOf('%') >= 0) {
                x = `${parseInt(x, 10) * progress * rtlFactor}%`;
            } else {
                x = `${x * progress * rtlFactor}px`;
            }
            if (y.indexOf('%') >= 0) {
                y = `${parseInt(y, 10) * progress}%`;
            } else {
                y = `${y * progress}px`;
            }
            if (typeof opacity !== 'undefined' && opacity !== null) {
                const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
                $el[0].style.opacity = currentOpacity;
            }
            if (typeof scale === 'undefined' || scale === null) {
                $el.transform(`translate3d(${x}, ${y}, 0px)`);
            } else {
                const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
                $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
            }
        };
        const setTranslate = () => {
            const {
                $el,
                slides,
                progress,
                snapGrid
            } = swiper;
            $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
                setTransform(el, progress);
            });
            slides.each((slideEl, slideIndex) => {
                let slideProgress = slideEl.progress;
                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
                    slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
                }
                slideProgress = Math.min(Math.max(slideProgress, -1), 1);
                $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
                    setTransform(el, slideProgress);
                });
            });
        };
        const setTransition = function (duration) {
            if (duration === void 0) {
                duration = swiper.params.speed;
            }
            const {
                $el
            } = swiper;
            $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
                const $parallaxEl = $(parallaxEl);
                let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
                if (duration === 0) parallaxDuration = 0;
                $parallaxEl.transition(parallaxDuration);
            });
        };
        on('beforeInit', () => {
            if (!swiper.params.parallax.enabled) return;
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
        });
        on('init', () => {
            if (!swiper.params.parallax.enabled) return;
            setTranslate();
        });
        on('setTranslate', () => {
            if (!swiper.params.parallax.enabled) return;
            setTranslate();
        });
        on('setTransition', (_swiper, duration) => {
            if (!swiper.params.parallax.enabled) return;
            setTransition(duration);
        });
    }
    function Zoom(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const window = getWindow();
        extendParams({
            zoom: {
                enabled: false,
                maxRatio: 3,
                minRatio: 1,
                toggle: true,
                containerClass: 'ax-zoom',
                zoomedSlideClass: 'ax-slide-zoomed'
            }
        });
        swiper.zoom = {
            enabled: false
        };
        let currentScale = 1;
        let isScaling = false;
        let gesturesEnabled;
        let fakeGestureTouched;
        let fakeGestureMoved;
        const gesture = {
            $slideEl: undefined,
            slideWidth: undefined,
            slideHeight: undefined,
            $imageEl: undefined,
            $imageWrapEl: undefined,
            maxRatio: 3
        };
        const image = {
            isTouched: undefined,
            isMoved: undefined,
            currentX: undefined,
            currentY: undefined,
            minX: undefined,
            minY: undefined,
            maxX: undefined,
            maxY: undefined,
            width: undefined,
            height: undefined,
            startX: undefined,
            startY: undefined,
            touchesStart: {},
            touchesCurrent: {}
        };
        const velocity = {
            x: undefined,
            y: undefined,
            prevPositionX: undefined,
            prevPositionY: undefined,
            prevTime: undefined
        };
        let scale = 1;
        Object.defineProperty(swiper.zoom, 'scale', {
            get() {
                return scale;
            },
            set(value) {
                if (scale !== value) {
                    const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
                    const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
                    emit('zoomChange', value, imageEl, slideEl);
                }
                scale = value;
            }
        });
        function getDistanceBetweenTouches(e) {
            if (e.targetTouches.length < 2) return 1;
            const x1 = e.targetTouches[0].pageX;
            const y1 = e.targetTouches[0].pageY;
            const x2 = e.targetTouches[1].pageX;
            const y2 = e.targetTouches[1].pageY;
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            return distance;
        } 
        function onGestureStart(e) {
            const support = swiper.support;
            const params = swiper.params.zoom;
            fakeGestureTouched = false;
            fakeGestureMoved = false;
            if (!support.gestures) {
                if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
                    return;
                }
                fakeGestureTouched = true;
                gesture.scaleStart = getDistanceBetweenTouches(e);
            }
            if (!gesture.$slideEl || !gesture.$slideEl.length) {
                gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
                if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
                gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
                if (gesture.$imageWrapEl.length === 0) {
                    gesture.$imageEl = undefined;
                    return;
                }
            }
            if (gesture.$imageEl) {
                gesture.$imageEl.transition(0);
            }
            isScaling = true;
        }
        function onGestureChange(e) {
            const support = swiper.support;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            if (!support.gestures) {
                if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
                    return;
                }
                fakeGestureMoved = true;
                gesture.scaleMove = getDistanceBetweenTouches(e);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                if (e.type === 'gesturechange') onGestureStart(e);
                return;
            }
            if (support.gestures) {
                zoom.scale = e.scale * currentScale;
            } else {
                zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
            }
            if (zoom.scale > gesture.maxRatio) {
                zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
            }
            if (zoom.scale < params.minRatio) {
                zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
            }
            gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        }
        function onGestureEnd(e) {
            const device = swiper.device;
            const support = swiper.support;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            if (!support.gestures) {
                if (!fakeGestureTouched || !fakeGestureMoved) {
                    return;
                }
                if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
                    return;
                }
                fakeGestureTouched = false;
                fakeGestureMoved = false;
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
            gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
            currentScale = zoom.scale;
            isScaling = false;
            if (zoom.scale === 1) gesture.$slideEl = undefined;
        }
        function onTouchStart(e) {
            const device = swiper.device;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            if (image.isTouched) return;
            if (device.android && e.cancelable){
                axPreventDefault(e);
            } 
            image.isTouched = true;
            image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        }
        function onTouchMove(e) {
            const zoom = swiper.zoom;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            swiper.allowClick = false;
            if (!image.isTouched || !gesture.$slideEl) return;
            if (!image.isMoved) {
                image.width = gesture.$imageEl[0].offsetWidth;
                image.height = gesture.$imageEl[0].offsetHeight;
                image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
                image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
                gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
                gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
                gesture.$imageWrapEl.transition(0);
            } 
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
            if (!image.isMoved && !isScaling) {
                if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                    image.isTouched = false;
                    return;
                }
                if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                    image.isTouched = false;
                    return;
                }
            }
            if (e.cancelable) {
                axPreventDefault(e);
            }
            e.stopPropagation();
            image.isMoved = true;
            image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
            image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
            if (image.currentX < image.minX) {
                image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
            }
            if (image.currentX > image.maxX) {
                image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
            }
            if (image.currentY < image.minY) {
                image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
            }
            if (image.currentY > image.maxY) {
                image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
            } 
            if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
            if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
            if (!velocity.prevTime) velocity.prevTime = Date.now();
            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
            velocity.prevPositionX = image.touchesCurrent.x;
            velocity.prevPositionY = image.touchesCurrent.y;
            velocity.prevTime = Date.now();
            gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
        }
        function onTouchEnd() {
            const zoom = swiper.zoom;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            if (!image.isTouched || !image.isMoved) {
                image.isTouched = false;
                image.isMoved = false;
                return;
            }
            image.isTouched = false;
            image.isMoved = false;
            let momentumDurationX = 300;
            let momentumDurationY = 300;
            const momentumDistanceX = velocity.x * momentumDurationX;
            const newPositionX = image.currentX + momentumDistanceX;
            const momentumDistanceY = velocity.y * momentumDurationY;
            const newPositionY = image.currentY + momentumDistanceY; 
            if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
            if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
            image.currentX = newPositionX;
            image.currentY = newPositionY; 
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
            gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
        }
        function onTransitionEnd() {
            const zoom = swiper.zoom;
            if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
                if (gesture.$imageEl) {
                    gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
                }
                if (gesture.$imageWrapEl) {
                    gesture.$imageWrapEl.transform('translate3d(0,0,0)');
                }
                zoom.scale = 1;
                currentScale = 1;
                gesture.$slideEl = undefined;
                gesture.$imageEl = undefined;
                gesture.$imageWrapEl = undefined;
            }
        }
        function zoomIn(e) {
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            if (!gesture.$slideEl) {
                if (e && e.target) {
                    gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
                }
                if (!gesture.$slideEl) {
                    if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
                    } else {
                        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                    }
                }
                gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
            if (swiper.params.cssMode) {
                swiper.wrapperEl.style.overflow = 'hidden';
                swiper.wrapperEl.style.touchAction = 'none';
            }
            gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
            let touchX;
            let touchY;
            let offsetX;
            let offsetY;
            let diffX;
            let diffY;
            let translateX;
            let translateY;
            let imageWidth;
            let imageHeight;
            let scaledWidth;
            let scaledHeight;
            let translateMinX;
            let translateMinY;
            let translateMaxX;
            let translateMaxY;
            let slideWidth;
            let slideHeight;
            if (typeof image.touchesStart.x === 'undefined' && e) {
                touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
                touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
            } else {
                touchX = image.touchesStart.x;
                touchY = image.touchesStart.y;
            }
            zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            if (e) {
                slideWidth = gesture.$slideEl[0].offsetWidth;
                slideHeight = gesture.$slideEl[0].offsetHeight;
                offsetX = gesture.$slideEl.offset().left + window.scrollX;
                offsetY = gesture.$slideEl.offset().top + window.scrollY;
                diffX = offsetX + slideWidth / 2 - touchX;
                diffY = offsetY + slideHeight / 2 - touchY;
                imageWidth = gesture.$imageEl[0].offsetWidth;
                imageHeight = gesture.$imageEl[0].offsetHeight;
                scaledWidth = imageWidth * zoom.scale;
                scaledHeight = imageHeight * zoom.scale;
                translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
                translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
                translateMaxX = -translateMinX;
                translateMaxY = -translateMinY;
                translateX = diffX * zoom.scale;
                translateY = diffY * zoom.scale;
                if (translateX < translateMinX) {
                    translateX = translateMinX;
                }
                if (translateX > translateMaxX) {
                    translateX = translateMaxX;
                }
                if (translateY < translateMinY) {
                    translateY = translateMinY;
                }
                if (translateY > translateMaxY) {
                    translateY = translateMaxY;
                }
            } else {
                translateX = 0;
                translateY = 0;
            }
            gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
            gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        }
        function zoomOut() {
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            if (!gesture.$slideEl) {
                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                    gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
                } else {
                    gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                }
                gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
            if (swiper.params.cssMode) {
                swiper.wrapperEl.style.overflow = '';
                swiper.wrapperEl.style.touchAction = '';
            }
            zoom.scale = 1;
            currentScale = 1;
            gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
            gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
            gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
            gesture.$slideEl = undefined;
        } 
        function zoomToggle(e) {
            const zoom = swiper.zoom;
            if (zoom.scale && zoom.scale !== 1) {
                zoomOut();
            } else {
                zoomIn(e);
            }
        }
        function getListeners() {
            const support = swiper.support;
            const passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            const activeListenerWithCapture = support.passiveListener ? {
                passive: false,
                capture: true
            } : true;
            return {
                passiveListener,
                activeListenerWithCapture
            };
        }
        function getSlideSelector() {
            return `.${swiper.params.slideClass}`;
        }
        function toggleGestures(method) {
            const {
                passiveListener
            } = getListeners();
            const slideSelector = getSlideSelector();
            swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
            swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
            swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
        }
        function enableGestures() {
            if (gesturesEnabled) return;
            gesturesEnabled = true;
            toggleGestures('on');
        }
        function disableGestures() {
            if (!gesturesEnabled) return;
            gesturesEnabled = false;
            toggleGestures('off');
        } 
        function enable() {
            const zoom = swiper.zoom;
            if (zoom.enabled) return;
            zoom.enabled = true;
            const support = swiper.support;
            const {
                passiveListener,
                activeListenerWithCapture
            } = getListeners();
            const slideSelector = getSlideSelector(); 
            if (support.gestures) {
                swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
                swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
                if (swiper.touchEvents.cancel) {
                    swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
                }
            } 
            swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
        }
        function disable() {
            const zoom = swiper.zoom;
            if (!zoom.enabled) return;
            const support = swiper.support;
            zoom.enabled = false;
            const {
                passiveListener,
                activeListenerWithCapture
            } = getListeners();
            const slideSelector = getSlideSelector(); 
            if (support.gestures) {
                swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
                swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
                if (swiper.touchEvents.cancel) {
                    swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
                }
            } 
            swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
        }
        on('init', () => {
            if (swiper.params.zoom.enabled) {
                enable();
            }
        });
        on('destroy', () => {
            disable();
        });
        on('touchStart', (_s, e) => {
            if (!swiper.zoom.enabled) return;
            onTouchStart(e);
        });
        on('touchEnd', (_s, e) => {
            if (!swiper.zoom.enabled) return;
            onTouchEnd();
        });
        on('doubleTap', (_s, e) => {
            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                zoomToggle(e);
            }
        });
        on('transitionEnd', () => {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                onTransitionEnd();
            }
        });
        on('slideChange', () => {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
                onTransitionEnd();
            }
        });
        Object.assign(swiper.zoom, {
            enable,
            disable,
            in: zoomIn,
            out: zoomOut,
            toggle: zoomToggle
        });
    }
    function Lazy(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        extendParams({
            lazy: {
                checkInView: false,
                enabled: false,
                loadPrevNext: false,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: false,
                scrollingElement: '',
                elementClass: 'ax-lazy',
                loadingClass: 'ax-lazy-loading',
                loadedClass: 'ax-lazy-loaded',
                preloaderClass: 'ax-loading'
            }
        });
        swiper.lazy = {};
        let scrollHandlerAttached = false;
        let initialImageLoaded = false;
        function loadInSlide(index, loadInDuplicate) {
            if (loadInDuplicate === void 0) {
                loadInDuplicate = true;
            }
            const params = swiper.params.lazy;
            if (typeof index === 'undefined') return;
            if (swiper.slides.length === 0) return;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`) : swiper.slides.eq(index);
            const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
            if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
                $images.push($slideEl[0]);
            }
            if ($images.length === 0) return;
            $images.each(imageEl => {
                const $imageEl = $(imageEl);
                $imageEl.addClass(params.loadingClass);
                const background = $imageEl.attr('data-background');
                const src = $imageEl.attr('data-src');
                const srcset = $imageEl.attr('data-srcset');
                const sizes = $imageEl.attr('data-sizes');
                const $pictureEl = $imageEl.parent('picture');
                swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
                    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;
                    if (background) {
                        $imageEl.css('background-image', `url("${background}")`);
                        $imageEl.removeAttr('data-background');
                    } else {
                        if (srcset) {
                            $imageEl.attr('srcset', srcset);
                            $imageEl.removeAttr('data-srcset');
                        }
                        if (sizes) {
                            $imageEl.attr('sizes', sizes);
                            $imageEl.removeAttr('data-sizes');
                        }
                        if ($pictureEl.length) {
                            $pictureEl.children('source').each(sourceEl => {
                                const $source = $(sourceEl);
                                if ($source.attr('data-srcset')) {
                                    $source.attr('srcset', $source.attr('data-srcset'));
                                    $source.removeAttr('data-srcset');
                                }
                            });
                        }
                        if (src) {
                            $imageEl.attr('src', src);
                            $imageEl.removeAttr('data-src');
                        }
                    }
                    $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
                    $slideEl.find(`.${params.preloaderClass}`).remove();
                    if (swiper.params.loop && loadInDuplicate) {
                        const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
                        if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
                            loadInSlide(originalSlide.index(), false);
                        } else {
                            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
                            loadInSlide(duplicatedSlide.index(), false);
                        }
                    }
                    emit('lazyImageReady', $slideEl[0], $imageEl[0]);
                    if (swiper.params.autoHeight) {
                        swiper.updateAutoHeight();
                    }
                });
                emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
            });
        }
        function load() {
            const {
                $wrapperEl,
                params: swiperParams,
                slides,
                activeIndex
            } = swiper;
            const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
            const params = swiperParams.lazy;
            let slidesPerView = swiperParams.slidesPerView;
            if (slidesPerView === 'auto') {
                slidesPerView = 0;
            }
            function slideExist(index) {
                if (isVirtual) {
                    if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
                        return true;
                    }
                } else if (slides[index]) return true;
                return false;
            }
            function slideIndex(slideEl) {
                if (isVirtual) {
                    return $(slideEl).attr('data-swiper-slide-index');
                }
                return $(slideEl).index();
            }
            if (!initialImageLoaded) initialImageLoaded = true;
            if (swiper.params.watchSlidesProgress) {
                $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each(slideEl => {
                    const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
                    loadInSlide(index);
                });
            } else if (slidesPerView > 1) {
                for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
                    if (slideExist(i)) loadInSlide(i);
                }
            } else {
                loadInSlide(activeIndex);
            }
            if (params.loadPrevNext) {
                if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
                    const amount = params.loadPrevNextAmount;
                    const spv = slidesPerView;
                    const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
                    const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); 
                    for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
                        if (slideExist(i)) loadInSlide(i);
                    } 
                    for (let i = minIndex; i < activeIndex; i += 1) {
                        if (slideExist(i)) loadInSlide(i);
                    }
                } else {
                    const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
                    if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
                    const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
                    if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
                }
            }
        }
        function checkInViewOnLoad() {
            const window = getWindow();
            if (!swiper || swiper.destroyed) return;
            const $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);
            const isWindow = $scrollElement[0] === window;
            const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
            const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
            const swiperOffset = swiper.$el.offset();
            const {
                rtlTranslate: rtl
            } = swiper;
            let inView = false;
            if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
            const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];
            for (let i = 0; i < swiperCoord.length; i += 1) {
                const point = swiperCoord[i];
                if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
                    if (point[0] === 0 && point[1] === 0) continue; 
                    inView = true;
                }
            }
            const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (inView) {
                load();
                $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
            } else if (!scrollHandlerAttached) {
                scrollHandlerAttached = true;
                $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
            }
        }
        on('beforeInit', () => {
            if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
                swiper.params.preloadImages = false;
            }
        });
        on('init', () => {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.checkInView) {
                    checkInViewOnLoad();
                } else {
                    load();
                }
            }
        });
        on('scroll', () => {
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
                load();
            }
        });
        on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.checkInView) {
                    checkInViewOnLoad();
                } else {
                    load();
                }
            }
        });
        on('transitionStart', () => {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
                    if (swiper.params.lazy.checkInView) {
                        checkInViewOnLoad();
                    } else {
                        load();
                    }
                }
            }
        });
        on('transitionEnd', () => {
            if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
                if (swiper.params.lazy.checkInView) {
                    checkInViewOnLoad();
                } else {
                    load();
                }
            }
        });
        on('slideChange', () => {
            const {
                lazy,
                cssMode,
                watchSlidesProgress,
                touchReleaseOnEdges,
                resistanceRatio
            } = swiper.params;
            if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
                load();
            }
        });
        Object.assign(swiper.lazy, {
            load,
            loadInSlide
        });
    }
    /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
    function Controller(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            controller: {
                control: undefined,
                inverse: false,
                by: 'slide' 
            }
        });
        swiper.controller = {
            control: undefined
        };
        function LinearSpline(x, y) {
            const binarySearch = function search() {
                let maxIndex;
                let minIndex;
                let guess;
                return (array, val) => {
                    minIndex = -1;
                    maxIndex = array.length;
                    while (maxIndex - minIndex > 1) {
                        guess = maxIndex + minIndex >> 1;
                        if (array[guess] <= val) {
                            minIndex = guess;
                        } else {
                            maxIndex = guess;
                        }
                    }
                    return maxIndex;
                };
            }();
            this.x = x;
            this.y = y;
            this.lastIndex = x.length - 1; 
            let i1;
            let i3;
            this.interpolate = function interpolate(x2) {
                if (!x2) return 0; 
                i3 = binarySearch(this.x, x2);
                i1 = i3 - 1; 
                return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
            };
            return this;
        } 
        function getInterpolateFunction(c) {
            if (!swiper.controller.spline) {
                swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
            }
        }
        function setTranslate(_t, byController) {
            const controlled = swiper.controller.control;
            let multiplier;
            let controlledTranslate;
            const Swiper = swiper.constructor;
            function setControlledTranslate(c) {
                const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
                if (swiper.params.controller.by === 'slide') {
                    getInterpolateFunction(c); 
                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);
                }
                if (!controlledTranslate || swiper.params.controller.by === 'container') {
                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                    controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
                }
                if (swiper.params.controller.inverse) {
                    controlledTranslate = c.maxTranslate() - controlledTranslate;
                }
                c.updateProgress(controlledTranslate);
                c.setTranslate(controlledTranslate, swiper);
                c.updateActiveIndex();
                c.updateSlidesClasses();
            }
            if (Array.isArray(controlled)) {
                for (let i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTranslate(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTranslate(controlled);
            }
        }
        function setTransition(duration, byController) {
            const Swiper = swiper.constructor;
            const controlled = swiper.controller.control;
            let i;
            function setControlledTransition(c) {
                c.setTransition(duration, swiper);
                if (duration !== 0) {
                    c.transitionStart();
                    if (c.params.autoHeight) {
                        nextTick(() => {
                            c.updateAutoHeight();
                        });
                    }
                    c.$wrapperEl.transitionEnd(() => {
                        if (!controlled) return;
                        if (c.params.loop && swiper.params.controller.by === 'slide') {
                            c.loopFix();
                        }
                        c.transitionEnd();
                    });
                }
            }
            if (Array.isArray(controlled)) {
                for (i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTransition(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTransition(controlled);
            }
        }
        function removeSpline() {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
                swiper.controller.spline = undefined;
                delete swiper.controller.spline;
            }
        }
        on('beforeInit', () => {
            swiper.controller.control = swiper.params.controller.control;
        });
        on('update', () => {
            removeSpline();
        });
        on('resize', () => {
            removeSpline();
        });
        on('observerUpdate', () => {
            removeSpline();
        });
        on('setTranslate', (_s, translate, byController) => {
            if (!swiper.controller.control) return;
            swiper.controller.setTranslate(translate, byController);
        });
        on('setTransition', (_s, duration, byController) => {
            if (!swiper.controller.control) return;
            swiper.controller.setTransition(duration, byController);
        });
        Object.assign(swiper.controller, {
            setTranslate,
            setTransition
        });
    }
    function A11y(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            a11y: {
                enabled: true,
                notificationClass: 'ax-notification',
                prevSlideMessage: '上一个',
                nextSlideMessage: '下一个',
                firstSlideMessage: '这是第一个',
                lastSlideMessage: '这是最后一个',
                paginationBulletMessage: '跳转到第{{index}}页',
                slideLabelMessage: '第{{index}}/{{slidesLength}}页',
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                itemRoleDescriptionMessage: null,
                slideRole: 'group',
                id: null
            }
        });
        let liveRegion = null;
        function notify(message) {
            const notification = liveRegion;
            if (notification.length === 0) return;
            notification.html('');
            notification.html(message);
        }
        function getRandomNumber(size) {
            if (size === void 0) {
                size = 16;
            }
            const randomChar = () => Math.round(16 * Math.random()).toString(16);
            return 'x'.repeat(size).replace(/x/g, randomChar);
        }
        function makeElFocusable($el) {
            $el.attr('tabIndex', '0');
        }
        function makeElNotFocusable($el) {
            $el.attr('tabIndex', '-1');
        }
        function addElRole($el, role) {
            $el.attr('role', role);
        }
        function addElRoleDescription($el, description) {
            $el.attr('aria-roledescription', description);
        }
        function addElControls($el, controls) {
            $el.attr('aria-controls', controls);
        }
        function addElLabel($el, label) {
            $el.attr('aria-label', label);
        }
        function addElId($el, id) {
            $el.attr('id', id);
        }
        function addElLive($el, live) {
            $el.attr('aria-live', live);
        }
        function disableEl($el) {
            $el.attr('aria-disabled', true);
        }
        function enableEl($el) {
            $el.attr('aria-disabled', false);
        }
        function onEnterOrSpaceKey(e) {
            if (e.keyCode !== 13 && e.keyCode !== 32) return;
            const params = swiper.params.a11y;
            const $targetEl = $(e.target);
            if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
                if (!(swiper.isEnd && !swiper.params.loop)) {
                    swiper.slideNext();
                }
                if (swiper.isEnd) {
                    notify(params.lastSlideMessage);
                } else {
                    notify(params.nextSlideMessage);
                }
            }
            if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
                if (!(swiper.isBeginning && !swiper.params.loop)) {
                    swiper.slidePrev();
                }
                if (swiper.isBeginning) {
                    notify(params.firstSlideMessage);
                } else {
                    notify(params.prevSlideMessage);
                }
            }
            if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
                $targetEl[0].click();
            }
        }
        function updateNavigation() {
            if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            if ($prevEl && $prevEl.length > 0) {
                if (swiper.isBeginning) {
                    disableEl($prevEl);
                    makeElNotFocusable($prevEl);
                } else {
                    enableEl($prevEl);
                    makeElFocusable($prevEl);
                }
            }
            if ($nextEl && $nextEl.length > 0) {
                if (swiper.isEnd) {
                    disableEl($nextEl);
                    makeElNotFocusable($nextEl);
                } else {
                    enableEl($nextEl);
                    makeElFocusable($nextEl);
                }
            }
        }
        function hasPagination() {
            return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
        }
        function hasClickablePagination() {
            return hasPagination() && swiper.params.pagination.clickable;
        }
        function updatePagination() {
            const params = swiper.params.a11y;
            if (!hasPagination()) return;
            swiper.pagination.bullets.each(bulletEl => {
                const $bulletEl = $(bulletEl);
                if (swiper.params.pagination.clickable) {
                    makeElFocusable($bulletEl);
                    if (!swiper.params.pagination.renderBullet) {
                        addElRole($bulletEl, 'button');
                        addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
                    }
                }
                if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {
                    $bulletEl.attr('aria-current', 'true');
                } else {
                    $bulletEl.removeAttr('aria-current');
                }
            });
        }
        const initNavEl = ($el, wrapperId, message) => {
            makeElFocusable($el);
            if ($el[0].tagName !== 'BUTTON') {
                addElRole($el, 'button');
                $el.on('keydown', onEnterOrSpaceKey);
            }
            addElLabel($el, message);
            addElControls($el, wrapperId);
        };
        const handleFocus = e => {
            const slideEl = e.target.closest(`.${swiper.params.slideClass}`);
            if (!slideEl || !swiper.slides.includes(slideEl)) return;
            const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
            const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
            if (isActive || isVisible) return;
            swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
        };
        function init() {
            const params = swiper.params.a11y;
            swiper.$el.append(liveRegion); 
            const $containerEl = swiper.$el;
            if (params.containerRoleDescriptionMessage) {
                addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
            }
            if (params.containerMessage) {
                addElLabel($containerEl, params.containerMessage);
            } 
            const $wrapperEl = swiper.$wrapperEl;
            const wrapperId = params.id || $wrapperEl.attr('id') || `ax-wrapper-${getRandomNumber(16)}`;
            const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
            addElId($wrapperEl, wrapperId);
            addElLive($wrapperEl, live); 
            if (params.itemRoleDescriptionMessage) {
                addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
            }
            addElRole($(swiper.slides), params.slideRole);
            const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
            swiper.slides.each((slideEl, index) => {
                const $slideEl = $(slideEl);
                const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
                const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
                addElLabel($slideEl, ariaLabelMessage);
            }); 
            let $nextEl;
            let $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl && $nextEl.length) {
                initNavEl($nextEl, wrapperId, params.nextSlideMessage);
            }
            if ($prevEl && $prevEl.length) {
                initNavEl($prevEl, wrapperId, params.prevSlideMessage);
            } 
            if (hasClickablePagination()) {
                swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
            } 
            swiper.$el.on('focus', handleFocus, true);
        }
        function destroy() {
            if (liveRegion && liveRegion.length > 0) liveRegion.remove();
            let $nextEl;
            let $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
                $nextEl.off('keydown', onEnterOrSpaceKey);
            }
            if ($prevEl) {
                $prevEl.off('keydown', onEnterOrSpaceKey);
            } 
            if (hasClickablePagination()) {
                swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
            } 
            swiper.$el.off('focus', handleFocus, true);
        }
        on('beforeInit', () => {
            liveRegion = $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
        });
        on('afterInit', () => {
            if (!swiper.params.a11y.enabled) return;
            init();
        });
        on('fromEdge toEdge afterInit lock unlock', () => {
            if (!swiper.params.a11y.enabled) return;
            updateNavigation();
        });
        on('paginationUpdate', () => {
            if (!swiper.params.a11y.enabled) return;
            updatePagination();
        });
        on('destroy', () => {
            if (!swiper.params.a11y.enabled) return;
            destroy();
        });
    }
    function History(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            history: {
                enabled: false,
                root: '',
                replaceState: false,
                key: 'slides'
            }
        });
        let initialized = false;
        let paths = {};
        const slugify = text => {
            return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
        };
        const getPathValues = urlOverride => {
            const window = getWindow();
            let location;
            if (urlOverride) {
                location = new URL(urlOverride);
            } else {
                location = window.location;
            }
            const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
            const total = pathArray.length;
            const key = pathArray[total - 2];
            const value = pathArray[total - 1];
            return {
                key,
                value
            };
        };
        const setHistory = (key, index) => {
            const window = getWindow();
            if (!initialized || !swiper.params.history.enabled) return;
            let location;
            if (swiper.params.url) {
                location = new URL(swiper.params.url);
            } else {
                location = window.location;
            }
            const slide = swiper.slides.eq(index);
            let value = slugify(slide.attr('data-history'));
            if (swiper.params.history.root.length > 0) {
                let root = swiper.params.history.root;
                if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
                value = `${root}/${key}/${value}`;
            } else if (!location.pathname.includes(key)) {
                value = `${key}/${value}`;
            }
            const currentState = window.history.state;
            if (currentState && currentState.value === value) {
                return;
            }
            if (swiper.params.history.replaceState) {
                window.history.replaceState({
                    value
                }, null, value);
            } else {
                window.history.pushState({
                    value
                }, null, value);
            }
        };
        const scrollToSlide = (speed, value, runCallbacks) => {
            if (value) {
                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                    const slide = swiper.slides.eq(i);
                    const slideHistory = slugify(slide.attr('data-history'));
                    if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        const index = slide.index();
                        swiper.slideTo(index, speed, runCallbacks);
                    }
                }
            } else {
                swiper.slideTo(0, speed, runCallbacks);
            }
        };
        const setHistoryPopState = () => {
            paths = getPathValues(swiper.params.url);
            scrollToSlide(swiper.params.speed, swiper.paths.value, false);
        };
        const init = () => {
            const window = getWindow();
            if (!swiper.params.history) return;
            if (!window.history || !window.history.pushState) {
                swiper.params.history.enabled = false;
                swiper.params.hashNavigation.enabled = true;
                return;
            }
            initialized = true;
            paths = getPathValues(swiper.params.url);
            if (!paths.key && !paths.value) return;
            scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
            if (!swiper.params.history.replaceState) {
                window.addEventListener('popstate', setHistoryPopState);
            }
        };
        const destroy = () => {
            const window = getWindow();
            if (!swiper.params.history.replaceState) {
                window.removeEventListener('popstate', setHistoryPopState);
            }
        };
        on('init', () => {
            if (swiper.params.history.enabled) {
                init();
            }
        });
        on('destroy', () => {
            if (swiper.params.history.enabled) {
                destroy();
            }
        });
        on('transitionEnd _freeModeNoMomentumRelease', () => {
            if (initialized) {
                setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        });
        on('slideChange', () => {
            if (initialized && swiper.params.cssMode) {
                setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        });
    }
    function HashNavigation(_ref) {
        let {
            swiper,
            extendParams,
            emit,
            on
        } = _ref;
        let initialized = false;
        const document = getDocument();
        const window = getWindow();
        extendParams({
            hashNavigation: {
                enabled: false,
                replaceState: false,
                watchState: false
            }
        });
        const onHashChange = () => {
            emit('hashChange');
            const newHash = document.location.hash.replace('#', '');
            const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
            if (newHash !== activeSlideHash) {
                const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
                if (typeof newIndex === 'undefined') return;
                swiper.slideTo(newIndex);
            }
        };
        const setHash = () => {
            if (!initialized || !swiper.params.hashNavigation.enabled) return;
            if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
                window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');
                emit('hashSet');
            } else {
                const slide = swiper.slides.eq(swiper.activeIndex);
                const hash = slide.attr('data-hash') || slide.attr('data-history');
                document.location.hash = hash || '';
                emit('hashSet');
            }
        };
        const init = () => {
            if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
            initialized = true;
            const hash = document.location.hash.replace('#', '');
            if (hash) {
                const speed = 0;
                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                    const slide = swiper.slides.eq(i);
                    const slideHash = slide.attr('data-hash') || slide.attr('data-history');
                    if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        const index = slide.index();
                        swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
                    }
                }
            }
            if (swiper.params.hashNavigation.watchState) {
                $(window).on('hashchange', onHashChange);
            }
        };
        const destroy = () => {
            if (swiper.params.hashNavigation.watchState) {
                $(window).off('hashchange', onHashChange);
            }
        };
        on('init', () => {
            if (swiper.params.hashNavigation.enabled) {
                init();
            }
        });
        on('destroy', () => {
            if (swiper.params.hashNavigation.enabled) {
                destroy();
            }
        });
        on('transitionEnd _freeModeNoMomentumRelease', () => {
            if (initialized) {
                setHash();
            }
        });
        on('slideChange', () => {
            if (initialized && swiper.params.cssMode) {
                setHash();
            }
        });
    }
    /* eslint no-underscore-dangle: "off" */
    function Autoplay(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        let timeout;
        swiper.autoplay = {
            running: false,
            paused: false
        };
        extendParams({
            autoplay: {
                enabled: false,
                delay: 3000,
                waitForTransition: true,
                disableOnInteraction: true,
                stopOnLastSlide: false,
                reverseDirection: false,
                pauseOnMouseEnter: false
            }
        });
        function run() {
            const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
            let delay = swiper.params.autoplay.delay;
            if ($activeSlideEl.attr('data-swiper-autoplay')) {
                delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
            }
            clearTimeout(timeout);
            timeout = nextTick(() => {
                let autoplayResult;
                if (swiper.params.autoplay.reverseDirection) {
                    if (swiper.params.loop) {
                        swiper.loopFix();
                        autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                        emit('autoplay');
                    } else if (!swiper.isBeginning) {
                        autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                        emit('autoplay');
                    } else if (!swiper.params.autoplay.stopOnLastSlide) {
                        autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                        emit('autoplay');
                    } else {
                        stop();
                    }
                } else if (swiper.params.loop) {
                    swiper.loopFix();
                    autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                    emit('autoplay');
                } else if (!swiper.isEnd) {
                    autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                    emit('autoplay');
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
                    emit('autoplay');
                } else {
                    stop();
                }
                if (swiper.params.cssMode && swiper.autoplay.running) run(); else if (autoplayResult === false) {
                    run();
                }
            }, delay);
        }
        function start() {
            if (typeof timeout !== 'undefined') return false;
            if (swiper.autoplay.running) return false;
            swiper.autoplay.running = true;
            emit('autoplayStart');
            run();
            return true;
        }
        function stop() {
            if (!swiper.autoplay.running) return false;
            if (typeof timeout === 'undefined') return false;
            if (timeout) {
                clearTimeout(timeout);
                timeout = undefined;
            }
            swiper.autoplay.running = false;
            emit('autoplayStop');
            return true;
        }
        function pause(speed) {
            if (!swiper.autoplay.running) return;
            if (swiper.autoplay.paused) return;
            if (timeout) clearTimeout(timeout);
            swiper.autoplay.paused = true;
            if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
                swiper.autoplay.paused = false;
                run();
            } else {
                ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                    swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
                });
            }
        }
        function onVisibilityChange() {
            const document = getDocument();
            if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
                pause();
            }
            if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
                run();
                swiper.autoplay.paused = false;
            }
        }
        function onTransitionEnd(e) {
            if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
            if (e.target !== swiper.$wrapperEl[0]) return;
            ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
            });
            swiper.autoplay.paused = false;
            if (!swiper.autoplay.running) {
                stop();
            } else {
                run();
            }
        }
        function onMouseEnter() {
            if (swiper.params.autoplay.disableOnInteraction) {
                stop();
            } else {
                emit('autoplayPause');
                pause();
            }
            ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
            });
        }
        function onMouseLeave() {
            if (swiper.params.autoplay.disableOnInteraction) {
                return;
            }
            swiper.autoplay.paused = false;
            emit('autoplayResume');
            run();
        }
        function attachMouseEvents() {
            if (swiper.params.autoplay.pauseOnMouseEnter) {
                swiper.$el.on('mouseenter', onMouseEnter);
                swiper.$el.on('mouseleave', onMouseLeave);
            }
        }
        function detachMouseEvents() {
            swiper.$el.off('mouseenter', onMouseEnter);
            swiper.$el.off('mouseleave', onMouseLeave);
        }
        on('init', () => {
            if (swiper.params.autoplay.enabled) {
                start();
                const document = getDocument();
                document.addEventListener('visibilitychange', onVisibilityChange);
                attachMouseEvents();
            }
        });
        on('beforeTransitionStart', (_s, speed, internal) => {
            if (swiper.autoplay.running) {
                if (internal || !swiper.params.autoplay.disableOnInteraction) {
                    swiper.autoplay.pause(speed);
                } else {
                    stop();
                }
            }
        });
        on('sliderFirstMove', () => {
            if (swiper.autoplay.running) {
                if (swiper.params.autoplay.disableOnInteraction) {
                    stop();
                } else {
                    pause();
                }
            }
        });
        on('touchEnd', () => {
            if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
                run();
            }
        });
        on('destroy', () => {
            detachMouseEvents();
            if (swiper.autoplay.running) {
                stop();
            }
            const document = getDocument();
            document.removeEventListener('visibilitychange', onVisibilityChange);
        });
        Object.assign(swiper.autoplay, {
            pause,
            run,
            start,
            stop
        });
    }
    function Thumb(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            thumbs: {
                swiper: null,
                multipleActiveThumbs: true,
                autoScrollOffset: 0,
                slideThumbActiveClass: 'ax-slide-thumb-active',
                thumbsContainerClass: 'ax-thumbs'
            }
        });
        let initialized = false;
        let swiperCreated = false;
        swiper.thumbs = {
            swiper: null
        };
        function onThumbClick() {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            const clickedIndex = thumbsSwiper.clickedIndex;
            const clickedSlide = thumbsSwiper.clickedSlide;
            if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
            if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
            let slideToIndex;
            if (thumbsSwiper.params.loop) {
                slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            } else {
                slideToIndex = clickedIndex;
            }
            if (swiper.params.loop) {
                let currentIndex = swiper.activeIndex;
                if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
                    swiper.loopFix(); 
                    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
                    currentIndex = swiper.activeIndex;
                }
                const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
                const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
                if (typeof prevIndex === 'undefined') slideToIndex = nextIndex; else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex; else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex; else slideToIndex = prevIndex;
            }
            swiper.slideTo(slideToIndex);
        }
        function init() {
            const {
                thumbs: thumbsParams
            } = swiper.params;
            if (initialized) return false;
            initialized = true;
            const SwiperClass = swiper.constructor;
            if (thumbsParams.swiper instanceof SwiperClass) {
                swiper.thumbs.swiper = thumbsParams.swiper;
                Object.assign(swiper.thumbs.swiper.originalParams, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
                Object.assign(swiper.thumbs.swiper.params, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
            } else if (isObject(thumbsParams.swiper)) {
                const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
                Object.assign(thumbsSwiperParams, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
                swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
                swiperCreated = true;
            }
            swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
            swiper.thumbs.swiper.on('tap', onThumbClick);
            return true;
        }
        function update(initial) {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
            const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
            const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
            if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
                let currentThumbsIndex = thumbsSwiper.activeIndex;
                let newThumbsIndex;
                let direction;
                if (thumbsSwiper.params.loop) {
                    if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
                        thumbsSwiper.loopFix(); 
                        thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
                        currentThumbsIndex = thumbsSwiper.activeIndex;
                    } 
                    const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
                    const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
                    if (typeof prevThumbsIndex === 'undefined') {
                        newThumbsIndex = nextThumbsIndex;
                    } else if (typeof nextThumbsIndex === 'undefined') {
                        newThumbsIndex = prevThumbsIndex;
                    } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
                        newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
                    } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
                        newThumbsIndex = nextThumbsIndex;
                    } else {
                        newThumbsIndex = prevThumbsIndex;
                    }
                    direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
                } else {
                    newThumbsIndex = swiper.realIndex;
                    direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
                }
                if (useOffset) {
                    newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
                }
                if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                    if (thumbsSwiper.params.centeredSlides) {
                        if (newThumbsIndex > currentThumbsIndex) {
                            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                        } else {
                            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                        }
                    } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);
                    thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
                }
            } 
            let thumbsToActivate = 1;
            const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
                thumbsToActivate = swiper.params.slidesPerView;
            }
            if (!swiper.params.thumbs.multipleActiveThumbs) {
                thumbsToActivate = 1;
            }
            thumbsToActivate = Math.floor(thumbsToActivate);
            thumbsSwiper.slides.removeClass(thumbActiveClass);
            if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
                for (let i = 0; i < thumbsToActivate; i += 1) {
                    thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
                }
            } else {
                for (let i = 0; i < thumbsToActivate; i += 1) {
                    thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
                }
            }
        }
        on('beforeInit', () => {
            const {
                thumbs
            } = swiper.params;
            if (!thumbs || !thumbs.swiper) return;
            init();
            update(true);
        });
        on('slideChange update resize observerUpdate', () => {
            update();
        });
        on('setTransition', (_s, duration) => {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            thumbsSwiper.setTransition(duration);
        });
        on('beforeDestroy', () => {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            if (swiperCreated) {
                thumbsSwiper.destroy();
            }
        });
        Object.assign(swiper.thumbs, {
            init,
            update
        });
    }
    function freeMode(_ref) {
        let {
            swiper,
            extendParams,
            emit,
            once
        } = _ref;
        extendParams({
            freeMode: {
                enabled: false,
                momentum: true,
                momentumRatio: 1,
                momentumBounce: true,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: false,
                minimumVelocity: 0.02
            }
        });
        function onTouchStart() {
            const translate = swiper.getTranslate();
            swiper.setTranslate(translate);
            swiper.setTransition(0);
            swiper.touchEventsData.velocities.length = 0;
            swiper.freeMode.onTouchEnd({
                currentPos: swiper.rtl ? swiper.translate : -swiper.translate
            });
        }
        function onTouchMove() {
            const {
                touchEventsData: data,
                touches
            } = swiper; 
            if (data.velocities.length === 0) {
                data.velocities.push({
                    position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
                    time: data.touchStartTime
                });
            }
            data.velocities.push({
                position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
                time: now()
            });
        }
        function onTouchEnd(_ref2) {
            let {
                currentPos
            } = _ref2;
            const {
                params,
                $wrapperEl,
                rtlTranslate: rtl,
                snapGrid,
                touchEventsData: data
            } = swiper; 
            const touchEndTime = now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (currentPos < -swiper.minTranslate()) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (currentPos > -swiper.maxTranslate()) {
                if (swiper.slides.length < snapGrid.length) {
                    swiper.slideTo(snapGrid.length - 1);
                } else {
                    swiper.slideTo(swiper.slides.length - 1);
                }
                return;
            }
            if (params.freeMode.momentum) {
                if (data.velocities.length > 1) {
                    const lastMoveEvent = data.velocities.pop();
                    const velocityEvent = data.velocities.pop();
                    const distance = lastMoveEvent.position - velocityEvent.position;
                    const time = lastMoveEvent.time - velocityEvent.time;
                    swiper.velocity = distance / time;
                    swiper.velocity /= 2;
                    if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
                        swiper.velocity = 0;
                    } 
                    if (time > 150 || now() - lastMoveEvent.time > 300) {
                        swiper.velocity = 0;
                    }
                } else {
                    swiper.velocity = 0;
                }
                swiper.velocity *= params.freeMode.momentumVelocityRatio;
                data.velocities.length = 0;
                let momentumDuration = 1000 * params.freeMode.momentumRatio;
                const momentumDistance = swiper.velocity * momentumDuration;
                let newPosition = swiper.translate + momentumDistance;
                if (rtl) newPosition = -newPosition;
                let doBounce = false;
                let afterBouncePosition;
                const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
                let needsLoopFix;
                if (newPosition < swiper.maxTranslate()) {
                    if (params.freeMode.momentumBounce) {
                        if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                            newPosition = swiper.maxTranslate() - bounceAmount;
                        }
                        afterBouncePosition = swiper.maxTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.maxTranslate();
                    }
                    if (params.loop && params.centeredSlides) needsLoopFix = true;
                } else if (newPosition > swiper.minTranslate()) {
                    if (params.freeMode.momentumBounce) {
                        if (newPosition - swiper.minTranslate() > bounceAmount) {
                            newPosition = swiper.minTranslate() + bounceAmount;
                        }
                        afterBouncePosition = swiper.minTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.minTranslate();
                    }
                    if (params.loop && params.centeredSlides) needsLoopFix = true;
                } else if (params.freeMode.sticky) {
                    let nextSlide;
                    for (let j = 0; j < snapGrid.length; j += 1) {
                        if (snapGrid[j] > -newPosition) {
                            nextSlide = j;
                            break;
                        }
                    }
                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
                        newPosition = snapGrid[nextSlide];
                    } else {
                        newPosition = snapGrid[nextSlide - 1];
                    }
                    newPosition = -newPosition;
                }
                if (needsLoopFix) {
                    once('transitionEnd', () => {
                        swiper.loopFix();
                    });
                } 
                if (swiper.velocity !== 0) {
                    if (rtl) {
                        momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                    } else {
                        momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                    }
                    if (params.freeMode.sticky) {
                        const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                        const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                        if (moveDistance < currentSlideSize) {
                            momentumDuration = params.speed;
                        } else if (moveDistance < 2 * currentSlideSize) {
                            momentumDuration = params.speed * 1.5;
                        } else {
                            momentumDuration = params.speed * 2.5;
                        }
                    }
                } else if (params.freeMode.sticky) {
                    swiper.slideToClosest();
                    return;
                }
                if (params.freeMode.momentumBounce && doBounce) {
                    swiper.updateProgress(afterBouncePosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    swiper.animating = true;
                    $wrapperEl.transitionEnd(() => {
                        if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                        emit('momentumBounce');
                        swiper.setTransition(params.speed);
                        setTimeout(() => {
                            swiper.setTranslate(afterBouncePosition);
                            $wrapperEl.transitionEnd(() => {
                                if (!swiper || swiper.destroyed) return;
                                swiper.transitionEnd();
                            });
                        }, 0);
                    });
                } else if (swiper.velocity) {
                    emit('_freeModeNoMomentumRelease');
                    swiper.updateProgress(newPosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    if (!swiper.animating) {
                        swiper.animating = true;
                        $wrapperEl.transitionEnd(() => {
                            if (!swiper || swiper.destroyed) return;
                            swiper.transitionEnd();
                        });
                    }
                } else {
                    swiper.updateProgress(newPosition);
                }
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            } else if (params.freeMode.sticky) {
                swiper.slideToClosest();
                return;
            } else if (params.freeMode) {
                emit('_freeModeNoMomentumRelease');
            }
            if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
        }
        Object.assign(swiper, {
            freeMode: {
                onTouchStart,
                onTouchMove,
                onTouchEnd
            }
        });
    }
    function Grid(_ref) {
        let {
            swiper,
            extendParams
        } = _ref;
        extendParams({
            grid: {
                rows: 1,
                fill: 'column'
            }
        });
        let slidesNumberEvenToRows;
        let slidesPerRow;
        let numFullColumns;
        const initSlides = slidesLength => {
            const {
                slidesPerView
            } = swiper.params;
            const {
                rows,
                fill
            } = swiper.params.grid;
            slidesPerRow = slidesNumberEvenToRows / rows;
            numFullColumns = Math.floor(slidesLength / rows);
            if (Math.floor(slidesLength / rows) === slidesLength / rows) {
                slidesNumberEvenToRows = slidesLength;
            } else {
                slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
            }
            if (slidesPerView !== 'auto' && fill === 'row') {
                slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
            }
        };
        const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
            const {
                slidesPerGroup,
                spaceBetween
            } = swiper.params;
            const {
                rows,
                fill
            } = swiper.params.grid; 
            let newSlideOrderIndex;
            let column;
            let row;
            if (fill === 'row' && slidesPerGroup > 1) {
                const groupIndex = Math.floor(i / (slidesPerGroup * rows));
                const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
                const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
                row = Math.floor(slideIndexInGroup / columnsInGroup);
                column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
                newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
                slide.css({
                    '-webkit-order': newSlideOrderIndex,
                    order: newSlideOrderIndex
                });
            } else if (fill === 'column') {
                column = Math.floor(i / rows);
                row = i - column * rows;
                if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
                    row += 1;
                    if (row >= rows) {
                        row = 0;
                        column += 1;
                    }
                }
            } else {
                row = Math.floor(i / slidesPerRow);
                column = i - row * slidesPerRow;
            }
            slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');
        };
        const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
            const {
                spaceBetween,
                centeredSlides,
                roundLengths
            } = swiper.params;
            const {
                rows
            } = swiper.params.grid;
            swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
            swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
            swiper.$wrapperEl.css({
                [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`
            });
            if (centeredSlides) {
                snapGrid.splice(0, snapGrid.length);
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid.push(...newSlidesGrid);
            }
        };
        swiper.grid = {
            initSlides,
            updateSlide,
            updateWrapperSize
        };
    }
    function appendSlide(slides) {
        const swiper = this;
        const {
            $wrapperEl,
            params
        } = swiper;
        if (params.loop) {
            swiper.loopDestroy();
        }
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.append(slides[i]);
            }
        } else {
            $wrapperEl.append(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
    }
    function prependSlide(slides) {
        const swiper = this;
        const {
            params,
            $wrapperEl,
            activeIndex
        } = swiper;
        if (params.loop) {
            swiper.loopDestroy();
        }
        let newActiveIndex = activeIndex + 1;
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.prepend(slides[i]);
            }
            newActiveIndex = activeIndex + slides.length;
        } else {
            $wrapperEl.prepend(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
        swiper.slideTo(newActiveIndex, 0, false);
    }
    function addSlide(index, slides) {
        const swiper = this;
        const {
            $wrapperEl,
            params,
            activeIndex
        } = swiper;
        let activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
        }
        const baseLength = swiper.slides.length;
        if (index <= 0) {
            swiper.prependSlide(slides);
            return;
        }
        if (index >= baseLength) {
            swiper.appendSlide(slides);
            return;
        }
        let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
        const slidesBuffer = [];
        for (let i = baseLength - 1; i >= index; i -= 1) {
            const currentSlide = swiper.slides.eq(i);
            currentSlide.remove();
            slidesBuffer.unshift(currentSlide);
        }
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.append(slides[i]);
            }
            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
        } else {
            $wrapperEl.append(slides);
        }
        for (let i = 0; i < slidesBuffer.length; i += 1) {
            $wrapperEl.append(slidesBuffer[i]);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }
    function removeSlide(slidesIndexes) {
        const swiper = this;
        const {
            params,
            $wrapperEl,
            activeIndex
        } = swiper;
        let activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
        }
        let newActiveIndex = activeIndexBuffer;
        let indexToRemove;
        if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
            for (let i = 0; i < slidesIndexes.length; i += 1) {
                indexToRemove = slidesIndexes[i];
                if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
                if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
        } else {
            indexToRemove = slidesIndexes;
            if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            newActiveIndex = Math.max(newActiveIndex, 0);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }
    function removeAllSlides() {
        const swiper = this;
        const slidesIndexes = [];
        for (let i = 0; i < swiper.slides.length; i += 1) {
            slidesIndexes.push(i);
        }
        swiper.removeSlide(slidesIndexes);
    }
    function Manipulation(_ref) {
        let {
            swiper
        } = _ref;
        Object.assign(swiper, {
            appendSlide: appendSlide.bind(swiper),
            prependSlide: prependSlide.bind(swiper),
            addSlide: addSlide.bind(swiper),
            removeSlide: removeSlide.bind(swiper),
            removeAllSlides: removeAllSlides.bind(swiper)
        });
    }
    function effectInit(params) {
        const {
            effect,
            swiper,
            on,
            setTranslate,
            setTransition,
            overwriteParams,
            perspective,
            recreateShadows,
            getEffectParams
        } = params;
        on('beforeInit', () => {
            if (swiper.params.effect !== effect) return;
            swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
            if (perspective && perspective()) {
                swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
            }
            const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
            Object.assign(swiper.params, overwriteParamsResult);
            Object.assign(swiper.originalParams, overwriteParamsResult);
        });
        on('setTranslate', () => {
            if (swiper.params.effect !== effect) return;
            setTranslate();
        });
        on('setTransition', (_s, duration) => {
            if (swiper.params.effect !== effect) return;
            setTransition(duration);
        });
        on('transitionEnd', () => {
            if (swiper.params.effect !== effect) return;
            if (recreateShadows) {
                if (!getEffectParams || !getEffectParams().slideShadows) return; 
                swiper.slides.each(slideEl => {
                    const $slideEl = swiper.$(slideEl);
                    $slideEl.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').remove();
                }); 
                recreateShadows();
            }
        });
        let requireUpdateOnVirtual;
        on('virtualUpdate', () => {
            if (swiper.params.effect !== effect) return;
            if (!swiper.slides.length) {
                requireUpdateOnVirtual = true;
            }
            requestAnimationFrame(() => {
                if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                    setTranslate();
                    requireUpdateOnVirtual = false;
                }
            });
        });
    }
    function effectTarget(effectParams, $slideEl) {
        if (effectParams.transformEl) {
            return $slideEl.find(effectParams.transformEl).css({
                'backface-visibility': 'hidden',
                '-webkit-backface-visibility': 'hidden'
            });
        }
        return $slideEl;
    }
    function effectVirtualTransitionEnd(_ref) {
        let {
            swiper,
            duration,
            transformEl,
            allSlides
        } = _ref;
        const {
            slides,
            activeIndex,
            $wrapperEl
        } = swiper;
        if (swiper.params.virtualTranslate && duration !== 0) {
            let eventTriggered = false;
            let $transitionEndTarget;
            if (allSlides) {
                $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
            } else {
                $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
            }
            $transitionEndTarget.transitionEnd(() => {
                if (eventTriggered) return;
                if (!swiper || swiper.destroyed) return;
                eventTriggered = true;
                swiper.animating = false;
                const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
                for (let i = 0; i < triggerEvents.length; i += 1) {
                    $wrapperEl.trigger(triggerEvents[i]);
                }
            });
        }
    }
    function EffectFade(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            fadeEffect: {
                crossFade: false,
                transformEl: null
            }
        });
        const setTranslate = () => {
            const {
                slides
            } = swiper;
            const params = swiper.params.fadeEffect;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = swiper.slides.eq(i);
                const offset = $slideEl[0].swiperSlideOffset;
                let tx = -offset;
                if (!swiper.params.virtualTranslate) tx -= swiper.translate;
                let ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                }
                const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.css({
                    opacity: slideOpacity
                }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.fadeEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl,
                allSlides: true
            });
        };
        effectInit({
            effect: 'fade',
            swiper,
            on,
            setTranslate,
            setTransition,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    function EffectCube(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            cubeEffect: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94
            }
        });
        const createSlideShadows = ($slideEl, progress, isHorizontal) => {
            let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
                shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
                $slideEl.append(shadowBefore);
            }
            if (shadowAfter.length === 0) {
                shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
                $slideEl.append(shadowAfter);
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        };
        const recreateShadows = () => {
            const isHorizontal = swiper.isHorizontal();
            swiper.slides.each(slideEl => {
                const progress = Math.max(Math.min(slideEl.progress, 1), -1);
                createSlideShadows($(slideEl), progress, isHorizontal);
            });
        };
        const setTranslate = () => {
            const {
                $el,
                $wrapperEl,
                slides,
                width: swiperWidth,
                height: swiperHeight,
                rtlTranslate: rtl,
                size: swiperSize,
                browser
            } = swiper;
            const params = swiper.params.cubeEffect;
            const isHorizontal = swiper.isHorizontal();
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let wrapperRotate = 0;
            let $cubeShadowEl;
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $wrapperEl.append($cubeShadowEl);
                    }
                    $cubeShadowEl.css({
                        height: `${swiperWidth}px`
                    });
                } else {
                    $cubeShadowEl = $el.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $el.append($cubeShadowEl);
                    }
                }
            }
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                let slideIndex = i;
                if (isVirtual) {
                    slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
                }
                let slideAngle = slideIndex * 90;
                let round = Math.floor(slideAngle / 360);
                if (rtl) {
                    slideAngle = -slideAngle;
                    round = Math.floor(-slideAngle / 360);
                }
                const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                let tx = 0;
                let ty = 0;
                let tz = 0;
                if (slideIndex % 4 === 0) {
                    tx = -round * 4 * swiperSize;
                    tz = 0;
                } else if ((slideIndex - 1) % 4 === 0) {
                    tx = 0;
                    tz = -round * 4 * swiperSize;
                } else if ((slideIndex - 2) % 4 === 0) {
                    tx = swiperSize + round * 4 * swiperSize;
                    tz = swiperSize;
                } else if ((slideIndex - 3) % 4 === 0) {
                    tx = -swiperSize;
                    tz = 3 * swiperSize + swiperSize * 4 * round;
                }
                if (rtl) {
                    tx = -tx;
                }
                if (!isHorizontal) {
                    ty = tx;
                    tx = 0;
                }
                const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
                if (progress <= 1 && progress > -1) {
                    wrapperRotate = slideIndex * 90 + progress * 90;
                    if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
                }
                $slideEl.transform(transform);
                if (params.slideShadows) {
                    createSlideShadows($slideEl, progress, isHorizontal);
                }
            }
            $wrapperEl.css({
                '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
                'transform-origin': `50% 50% -${swiperSize / 2}px`
            });
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
                } else {
                    const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                    const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                    const scale1 = params.shadowScale;
                    const scale2 = params.shadowScale / multiplier;
                    const offset = params.shadowOffset;
                    $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
                }
            }
            const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
            $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
            $wrapperEl[0].style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
        };
        const setTransition = duration => {
            const {
                $el,
                slides
            } = swiper;
            slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
                $el.find('.swiper-cube-shadow').transition(duration);
            }
        };
        effectInit({
            effect: 'cube',
            swiper,
            on,
            setTranslate,
            setTransition,
            recreateShadows,
            getEffectParams: () => swiper.params.cubeEffect,
            perspective: () => true,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: false,
                virtualTranslate: true
            })
        });
    }
    function createShadow(params, $slideEl, side) {
        const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
        const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
        let $shadowEl = $shadowContainer.children(`.${shadowClass}`);
        if (!$shadowEl.length) {
            $shadowEl = $(`<div class="swiper-slide-shadow${side ? `-${side}` : ''}"></div>`);
            $shadowContainer.append($shadowEl);
        }
        return $shadowEl;
    }
    function EffectFlip(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            flipEffect: {
                slideShadows: true,
                limitRotation: true,
                transformEl: null
            }
        });
        const createSlideShadows = ($slideEl, progress, params) => {
            let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
                shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
            }
            if (shadowAfter.length === 0) {
                shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        };
        const recreateShadows = () => {
            const params = swiper.params.flipEffect;
            swiper.slides.each(slideEl => {
                const $slideEl = $(slideEl);
                let progress = $slideEl[0].progress;
                if (swiper.params.flipEffect.limitRotation) {
                    progress = Math.max(Math.min(slideEl.progress, 1), -1);
                }
                createSlideShadows($slideEl, progress, params);
            });
        };
        const setTranslate = () => {
            const {
                slides,
                rtlTranslate: rtl
            } = swiper;
            const params = swiper.params.flipEffect;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                let progress = $slideEl[0].progress;
                if (swiper.params.flipEffect.limitRotation) {
                    progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                }
                const offset = $slideEl[0].swiperSlideOffset;
                const rotate = -180 * progress;
                let rotateY = rotate;
                let rotateX = 0;
                let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
                let ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                    rotateX = -rotateY;
                    rotateY = 0;
                } else if (rtl) {
                    rotateY = -rotateY;
                }
                $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
                if (params.slideShadows) {
                    createSlideShadows($slideEl, progress, params);
                }
                const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(transform);
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.flipEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl
            });
        };
        effectInit({
            effect: 'flip',
            swiper,
            on,
            setTranslate,
            setTransition,
            recreateShadows,
            getEffectParams: () => swiper.params.flipEffect,
            perspective: () => true,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    function EffectCoverflow(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                scale: 1,
                modifier: 1,
                slideShadows: true,
                transformEl: null
            }
        });
        const setTranslate = () => {
            const {
                width: swiperWidth,
                height: swiperHeight,
                slides,
                slidesSizesGrid
            } = swiper;
            const params = swiper.params.coverflowEffect;
            const isHorizontal = swiper.isHorizontal();
            const transform = swiper.translate;
            const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
            const rotate = isHorizontal ? params.rotate : -params.rotate;
            const translate = params.depth; 
            for (let i = 0, length = slides.length; i < length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideSize = slidesSizesGrid[i];
                const slideOffset = $slideEl[0].swiperSlideOffset;
                const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
                const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
                let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
                let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; 
                let translateZ = -translate * Math.abs(offsetMultiplier);
                let stretch = params.stretch; 
                if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
                    stretch = parseFloat(params.stretch) / 100 * slideSize;
                }
                let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
                let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
                let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); 
                if (Math.abs(translateX) < 0.001) translateX = 0;
                if (Math.abs(translateY) < 0.001) translateY = 0;
                if (Math.abs(translateZ) < 0.001) translateZ = 0;
                if (Math.abs(rotateY) < 0.001) rotateY = 0;
                if (Math.abs(rotateX) < 0.001) rotateX = 0;
                if (Math.abs(scale) < 0.001) scale = 0;
                const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(slideTransform);
                $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                if (params.slideShadows) {
                    let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                    let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                    if ($shadowBeforeEl.length === 0) {
                        $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');
                    }
                    if ($shadowAfterEl.length === 0) {
                        $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');
                    }
                    if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                    if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
                }
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.coverflowEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
        };
        effectInit({
            effect: 'coverflow',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => true,
            overwriteParams: () => ({
                watchSlidesProgress: true
            })
        });
    }
    function EffectCreative(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            creativeEffect: {
                transformEl: null,
                limitProgress: 1,
                shadowPerProgress: false,
                progressMultiplier: 1,
                perspective: true,
                prev: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                },
                next: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                }
            }
        });
        const getTranslateValue = value => {
            if (typeof value === 'string') return value;
            return `${value}px`;
        };
        const setTranslate = () => {
            const {
                slides,
                $wrapperEl,
                slidesSizesGrid
            } = swiper;
            const params = swiper.params.creativeEffect;
            const {
                progressMultiplier: multiplier
            } = params;
            const isCenteredSlides = swiper.params.centeredSlides;
            if (isCenteredSlides) {
                const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
                $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
            }
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideProgress = $slideEl[0].progress;
                const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
                let originalProgress = progress;
                if (!isCenteredSlides) {
                    originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
                }
                const offset = $slideEl[0].swiperSlideOffset;
                const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
                const r = [0, 0, 0];
                let custom = false;
                if (!swiper.isHorizontal()) {
                    t[1] = t[0];
                    t[0] = 0;
                }
                let data = {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    scale: 1,
                    opacity: 1
                };
                if (progress < 0) {
                    data = params.next;
                    custom = true;
                } else if (progress > 0) {
                    data = params.prev;
                    custom = true;
                } 
                t.forEach((value, index) => {
                    t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
                }); 
                r.forEach((value, index) => {
                    r[index] = data.rotate[index] * Math.abs(progress * multiplier);
                });
                $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                const translateString = t.join(', ');
                const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
                const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
                const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
                const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; 
                if (custom && data.shadow || !custom) {
                    let $shadowEl = $slideEl.children('.swiper-slide-shadow');
                    if ($shadowEl.length === 0 && data.shadow) {
                        $shadowEl = createShadow(params, $slideEl);
                    }
                    if ($shadowEl.length) {
                        const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
                        $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
                    }
                }
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(transform).css({
                    opacity: opacityString
                });
                if (data.origin) {
                    $targetEl.css('transform-origin', data.origin);
                }
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.creativeEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl,
                allSlides: true
            });
        };
        effectInit({
            effect: 'creative',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => swiper.params.creativeEffect.perspective,
            overwriteParams: () => ({
                watchSlidesProgress: true,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    function EffectCards(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            cardsEffect: {
                slideShadows: true,
                transformEl: null,
                rotate: true
            }
        });
        const setTranslate = () => {
            const {
                slides,
                activeIndex
            } = swiper;
            const params = swiper.params.cardsEffect;
            const {
                startTranslate,
                isTouched
            } = swiper.touchEventsData;
            const currentTranslate = swiper.translate;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideProgress = $slideEl[0].progress;
                const progress = Math.min(Math.max(slideProgress, -4), 4);
                let offset = $slideEl[0].swiperSlideOffset;
                if (swiper.params.centeredSlides && !swiper.params.cssMode) {
                    swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
                }
                if (swiper.params.centeredSlides && swiper.params.cssMode) {
                    offset -= slides[0].swiperSlideOffset;
                }
                let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
                let tY = 0;
                const tZ = -100 * Math.abs(progress);
                let scale = 1;
                let rotate = -2 * progress;
                let tXAdd = 8 - Math.abs(progress) * 0.75;
                const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
                const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
                const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
                if (isSwipeToNext || isSwipeToPrev) {
                    const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
                    rotate += -28 * progress * subProgress;
                    scale += -0.5 * subProgress;
                    tXAdd += 96 * subProgress;
                    tY = `${-25 * subProgress * Math.abs(progress)}%`;
                }
                if (progress < 0) {
                    tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
                } else if (progress > 0) {
                    tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
                } else {
                    tX = `${tX}px`;
                }
                if (!swiper.isHorizontal()) {
                    const prevY = tY;
                    tY = tX;
                    tX = prevY;
                }
                const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
                const transform = `
          translate3d(${tX}, ${tY}, ${tZ}px)
          rotateZ(${params.rotate ? rotate : 0}deg)
          scale(${scaleString})
        `;
                if (params.slideShadows) {
                    let $shadowEl = $slideEl.find('.swiper-slide-shadow');
                    if ($shadowEl.length === 0) {
                        $shadowEl = createShadow(params, $slideEl);
                    }
                    if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
                }
                $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(transform);
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.cardsEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl
            });
        };
        effectInit({
            effect: 'cards',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => true,
            overwriteParams: () => ({
                watchSlidesProgress: true,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
    Swiper.use(modules);
    return Swiper;
}));
/*!a
 * 插件：灯箱画廊；使用方法：axLightbox('#id',{参数})
 */
const axLightboxs = [];
class axLightbox {
    constructor(options, elem) {
        this.options = axExtend({
            src: '',
            gallery: true,
            download: false,
            autoplay: false,
            thumb: {
                show: false,
                placement: 'bottom',
                row: 1,
            },
            zoom: true,
            share: false,
            btnClass: 'ax-lightbox-open',
            index: 0,
        }, options, elem);
        let _this = this;
        this.handlers = {};
        this.data = [];
        this.closeArea = [];
        this.zoomIn = false;
        this.button = elem ? axIdToDom(elem) : null;
        this.referName = '';
    }
    init() {
        let _this = this;
        this.data = axCreateData(this.options.src, ['src', 'cover', 'caption', 'type'], 'figure', ['media', 'cover', 'caption', 'type'], ['', '', '', 'image'], function (data) {
            data.forEach(item => {
                if (!item.cover && item.type == 'image') {
                    item.cover = item.media
                }
                item.cover = item.cover ? item.cover : axImage.imgNone;
            });
        })
        this.setAttribute();
        this.createBox();
        this.createSlide();
        if (this.data.length > 1) {
            this.prev = axStrToDom(`<span class="ax-prev ax-light"></span>`);
            this.next = axStrToDom(`<span class="ax-next ax-light"></span>`);
            this.swiper.appendChild(this.prev);
            this.swiper.appendChild(this.next);
        }
        let swiperOpt = {
            zoom: this.options.zoom,
            lazy: true,
            keyboard: true,
            mousewheel: true,
            initialSlide: this.options.index || 0,
            pagination: {
                el: this.options.gallery ? this.targetDom.querySelector('.ax-pages') : null,
                type: "fraction",
            },
            thumbs: {
                swiper: '',
            },
            on: {
                touchStart: function (swiper, event) {
                    swiper.el.classList.add('ax-grabbing');
                },
                touchEnd: function (swiper, event) {
                    swiper.el.classList.remove('ax-grabbing');
                },
                zoomChange: function (swiper, scale) {
                    if (scale > 1) {
                        _this.zoomIn = true;
                    } else {
                        setTimeout(function(){
                            _this.zoomIn = false;
                        }, 100)
                    }
                },
            },
        }
        let thumbOpt = {
            lazy: true,
            spaceBetween: 4,
            slidesPerView: "auto",
            mousewheel: true,
            grid: {
                rows: this.options.thumb.row,
            },
            watchSlidesProgress: true,
        }
        if (this.options.gallery && this.options.thumb) {
            this.stage.insertAdjacentElement('afterend', this.createThumb());
            this.insThumb = new axSwiper(this.thumb.querySelector('.ax-swiper'), thumbOpt);
            swiperOpt.thumbs.swiper = this.insThumb;
            this.btnList.onclick = function () {
                _this.targetDom.classList.toggle('ax-thumb-hide');
            }
        }
        if (!this.options.thumb.show) {
            this.targetDom.classList.add('ax-thumb-hide');
        }
        if (this.options.autoplay) {
            swiperOpt.autoplay = {
                delay: 5000,
                stopOnLastSlide: false,
                disableOnInteraction: true,
            }
        }
        this.insSwiper = new axSwiper(this.swiper, swiperOpt);
        document.body.appendChild(this.targetDom);
        if (this.data.length > 1 && this.options.thumb.row && this.options.thumb.row > 1) {
            this.thumb.querySelector('.ax-swiper').style.height = axHeight(this.thumb.querySelector('.ax-slide'), 'outer') * this.options.thumb.row + thumbOpt.spaceBetween * (this.options.thumb.row - 1) + 'px';
        }
        if (!this.options.gallery) {
            this.insSwiper.disable();
        }
        axPreventScroll(this.targetDom);
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', function () {
                _this.hide();
            }, false);
        });
        if (this.options.zoom) {
            this.btnZoom.onclick = function () {
                if (this.classList.contains('ax-icon-zoomin')) {
                    _this.insSwiper.zoom.in();
                } else {
                    _this.insSwiper.zoom.out();
                }
            }
        }
        /*     if (this.options.list && this.thumb) {
                this.btnList.onclick = function () {
                    _this.targetDom.classList.toggle('ax-thumb-hide');
                }
            } */
        if (this.options.download) {
            if (this.data[this.insSwiper.activeIndex].type != 'image') {
                this.btnDownload.href = '###';
                this.btnDownload.classList.add('ax-disabled');
                this.btnDownload.removeAttribute('download');
                this.btnDownload.removeAttribute('target');
            } else {
                this.btnDownload.href = this.data[this.insSwiper.activeIndex].media;
                this.btnDownload.classList.remove('ax-disabled');
                this.btnDownload.setAttribute('download', '');
                this.btnDownload.setAttribute('target', '_blank');
            }
        }
        if (this.options.zoom) {
            if (this.data[this.insSwiper.activeIndex].type != 'image') {
                this.btnZoom.classList.add('ax-disabled');
                this.insSwiper.zoom.disable();
            } else {
                this.btnZoom.classList.remove('ax-disabled');
                this.insSwiper.zoom.enable();
            }
        }
        if (this.options.share) {
            if (this.data[this.insSwiper.activeIndex].type != 'image') {
                this.btnShare.classList.add('ax-disabled');
            } else {
                this.btnShare.classList.remove('ax-disabled');
            }
        }
        this.insSwiper.on('slideChangeTransitionEnd', function () {
            if (_this.options.download) {
                if (_this.data[this.activeIndex].type != 'image') {
                    _this.btnDownload.href = '###';
                    _this.btnDownload.classList.add('ax-disabled');
                    _this.btnDownload.removeAttribute('download');
                    _this.btnDownload.removeAttribute('target');
                } else {
                    _this.btnDownload.href = _this.data[this.activeIndex].media;
                    _this.btnDownload.classList.remove('ax-disabled');
                    _this.btnDownload.setAttribute('download', '');
                    _this.btnDownload.setAttribute('target', '_blank');
                }
            }
            if (_this.options.zoom) {
                if (_this.data[this.activeIndex].type != 'image') {
                    _this.btnZoom.classList.add('ax-disabled');
                    _this.insSwiper.zoom.disable();
                } else {
                    _this.btnZoom.classList.remove('ax-disabled');
                    _this.btnZoom.classList.remove('ax-icon-zoomout');
                    _this.btnZoom.classList.add('ax-icon-zoomin');
                    _this.insSwiper.zoom.enable();
                }
            }
            if (_this.options.share) {
                if (_this.data[this.activeIndex].type != 'image') {
                    _this.btnShare.classList.add('ax-disabled');
                } else {
                    _this.btnShare.classList.remove('ax-disabled');
                }
            }
            _this.targetDom.querySelectorAll('video,audio').forEach(elem => {
                elem.pause();
            });
            _this.zoomIn = false;
        })
        this.insSwiper.on('zoomChange', function (ins, scale) {
            if (scale > 1) {
                _this.btnZoom.classList.remove('ax-icon-zoomin');
                _this.btnZoom.classList.add('ax-icon-zoomout');
            } else {
                _this.btnZoom.classList.remove('ax-icon-zoomout');
                _this.btnZoom.classList.add('ax-icon-zoomin');
            }
        })
        'init' in this.handlers ? this.emit('init', '') : null;
        return this;
    }
    overlayClose(ev) {
        this.closeArea = [];
        let _this = this;
        let booPrev = true,
            booNext = true,
            booThumb = true;
        if (_this.prev) {
            booPrev = axIsOutside(ev, _this.prev);
        }
        _this.closeArea.push(booPrev);
        if (_this.next) {
            booNext = axIsOutside(ev, _this.next)
        }
        _this.closeArea.push(booNext);
        if (_this.options.thumb) {
            booThumb = axIsOutside(ev, _this.thumb);
        } else {
            booThumb = true;
        }
        _this.closeArea.push(booThumb);
        _this.swiperWrapper.querySelectorAll('.ax-media').forEach(item => {
            let dom = item.firstElementChild;
            _this.closeArea.push(axIsOutside(ev, dom));
        })
        if (_this.swiperWrapper.querySelectorAll('.ax-caption')) {
            _this.swiperWrapper.querySelectorAll('.ax-caption').forEach(item => {
                _this.closeArea.push(axIsOutside(ev, item));
            })
        }
        _this.closeArea.push(axIsOutside(ev, _this.operate));
        _this.closeArea.push(axIsOutside(ev, _this.pages));
        return this.closeArea;
    }
    createSlide() {
        let slideTpl = (src, type) => {
            if (type && type == 'video') {
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <video controls><source src="${src}" type="video/mp4"></video>
                    </div>
                </div>
                `
            } else if (type && type == 'iframe') {
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <iframe src="${src}" frameborder="0" width="100%" height="100%"></iframe>
                    </div>
                </div>
                `
            } else if (type && type == 'text') {
                if (src.substr(0, 1) == "#") {
                    src = document.querySelector(src).innerHTML;
                }
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <div class="ax-text">${src}</div>
                    </div>
                </div>
                `
            } else {
                return `
                <div class="ax-slide">
                    <div class="ax-media ax-zoom">
                        <img data-src="${src}" class="ax-lazy" />
                        <span class="ax-loading ax-white"><i></i></span>
                    </div>
                </div>
                `
            }
        }
        this.data.forEach(item => {
            let slide = null,
                caption = null;
            slide = axStrToDom(slideTpl(item.media, item.type));
            caption = item.caption ? axStrToDom(`<div class="ax-caption">${item.caption}</div>`) : null;
            caption ? slide.appendChild(caption) : null;
            this.swiperWrapper.appendChild(slide);
        })
    }
    createThumb() {
        this.thumb = axStrToDom('<div class="ax-thumb"><div class="ax-swiper"><div class="ax-wrapper"></div></div></div>');
        this.thumbWrapper = this.thumb.querySelector('.ax-wrapper');
        this.data.forEach(item => {
            let slide = axStrToDom(`
            <div class="ax-slide">
                <img data-src="${item.cover}" class="ax-lazy" />
                <span class="ax-loading ax-white"><i></i></span>
            </div>
            `);
            this.thumbWrapper.appendChild(slide);
        })
        return this.thumb;
    }
    createBox() {
        let boxTpl = `
        <div class="ax-lightbox" id="${axCreateId('lightbox')}">
        <div class="ax-overlay"></div>
        <div class="ax-tools">
            <div class="ax-pages"></div>
            <div class="ax-operate"><i class="ax-iconfont ax-icon-close" close></i></div>
        </div>
        <div class="ax-stage">
            <div class="ax-swiper">
                <div class="ax-wrapper">
                </div>
            </div>
        </div>
    </div>
      `;
        this.targetDom = axStrToDom(boxTpl);
        this.tools = this.targetDom.querySelector('.ax-tools');
        this.pages = this.targetDom.querySelector('.ax-pages');
        this.operate = this.targetDom.querySelector('.ax-operate');
        this.stage = this.targetDom.querySelector('.ax-stage');
        this.swiper = this.stage.querySelector('.ax-swiper');
        this.swiperWrapper = this.swiper.querySelector('.ax-wrapper');
        this.createBtn();
    }
    createBtn() {
        this.btnShare = axStrToDom('<i class="ax-iconfont ax-icon-share-f" share></i>');
        this.btnDownload = axStrToDom('<a href="###" class="ax-iconfont ax-icon-download" target="_blank" download></a>');
        this.btnZoom = axStrToDom('<i class="ax-iconfont ax-icon-zoomin" zoom></i>');
        this.btnList = axStrToDom('<i class="ax-iconfont ax-icon-list" list></i>');
        this.options.thumb ? this.operate.insertAdjacentElement('afterbegin', this.btnList) : null;
        this.options.download ? this.operate.insertAdjacentElement('afterbegin', this.btnDownload) : null;
        this.options.zoom ? this.operate.insertAdjacentElement('afterbegin', this.btnZoom) : null;
        this.options.share ? this.operate.insertAdjacentElement('afterbegin', this.btnShare) : null;
    }
    setAttribute() {
        for (let i = 0, len = this.data.length; i < len; i++) {
            if (this.data[i].hasOwnProperty('type') && (['iframe','video','text'].includes(this.data[i].type))) {
                this.options.thumb = false;
            }
            break;
        }
        if (this.data.length < 2) {
            this.options.thumb == false;
        }
    }
    update(setting, callback) {
        let _this = this;
        this.options = axExtend(this.options, setting);
        this.init();
        'update' in this.handlers ? this.emit('update', '') : null;
        callback && callback.call(this);
        return this;
    }
    show(callback) {
        let _this = this;
        'show' in this.handlers ? this.emit('show', '') : null;
        this.targetDom.style.visibility = 'visible';
        this.targetDom.classList.add('ax-show');
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        callback && callback.call(this);
        'shown' in this.handlers ? this.emit('shown', '') : null;
            _this.targetDom.onclick = function (ev) {
                _this.overlayClose(ev);
                let closeArea = _this.closeArea.includes(false);
                if (!closeArea && !_this.zoomIn) {
                    _this.hide();
                }
            }
        return this;
    }
    hide(callback) {
        let _this = this;
        'hide' in this.handlers ? this.emit('hide', '') : null;
        this.button ? this.button.classList.remove(this.options.btnClass) : null;
        this.targetDom.classList.remove('ax-show');
        /*         setTimeout(function () {
                    _this.targetDom.remove();
                }, parseFloat(axStyle(_this.targetDom).transitionDuration) * 1000 * 2)
                 */
        _this.targetDom.addEventListener('transitionend', function () {
            _this.targetDom.remove();
        }, false)
        this.targetDom.querySelectorAll('video,audio').forEach(elem => {
            elem.pause();
        });
        callback && callback.call(this);
        'hidden' in this.handlers ? this.emit('hidden', '') : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    let getHref = (element) => {
        let elem = axIdToDom(element),
            obj = [{}],
            node = elem.nodeName;
        if (node == 'A') {
            if (elem.hasAttribute('href') && elem.getAttribute('href').indexOf('##') == -1) {
                obj[0].media = elem.getAttribute('href');
                obj[0].cover = elem.getAttribute('href');
            }
        } else if (node == 'IMG') {
            if (elem.hasAttribute('src')) {
                obj[0].media = elem.getAttribute('src');
                obj[0].cover = elem.getAttribute('src');
            }
        }
        if (elem.hasAttribute('type')) {
            obj[0].type = elem.getAttribute('type');
        } else {
            obj[0].type = 'image';
        }
        if (elem.hasAttribute('title')) {
            obj[0].caption = elem.getAttribute('title');
        } else if (elem.hasAttribute('alt')) {
            obj[0].caption = elem.getAttribute('alt');
        } else {
            obj[0].caption = '';
        }
        return obj;
    }
    let datas = [];
    document.querySelectorAll('[axLightbox]').forEach(element => {
        let referName = element.getAttribute('axLightbox');
        if (referName) {
            let data = [];
            if (element.getAttribute('data-src')) {
                data = axCreateData(element.getAttribute('data-src'), ['src', 'cover', 'caption', 'type'], 'figure', ['media', 'cover', 'caption', 'type'], ['', '', '', 'image'], function (data) {
                    data.forEach(item => {
                        if (!item.cover && item.type == 'image') {
                            item.cover = item.media
                        }
                        item.cover = item.cover ? item.cover : axImage.imgNone;
                    });
                });
            } else {
                data = getHref(element);
            }
            if (axIsEmpty(datas)) {
                datas.push({ name: referName, data: data });
            } else {
                datas.forEach(item => {
                    if (item.name == referName) {
                        item.data.push(...data);
                    }
                })
                if (!datas.some(item => (item.name == referName))) {
                    datas.push({ name: referName, data: data });
                }
            }
        }
    });
    datas.forEach(item => {
        let obj = {};
        let newIns = new axLightbox({
            src: item.data,
        })
        obj.name = item.name;
        obj.instance = newIns;
        newIns.referName = obj.name;
        axLightboxs.push(obj);
    })
    document.querySelectorAll('[axLightbox]').forEach(element => {
        let referName = element.getAttribute('axLightbox');
        if (referName) {
            element.onclick = (ev) => {
                axPreventDefault(ev);
                axLightboxs.forEach(item => {
                    if (item.name == referName) {
                        axInstance(axLightboxs, referName).init().show();
                    }
                })
            }
        } else {
            if (element.getAttribute('data-src')) {
                element.onclick = (ev) => {
                    axPreventDefault(ev);
                    new axLightbox('', element).init().show();
                }
            } else {
                element.onclick = (ev) => {
                    axPreventDefault(ev);
                    new axLightbox({
                        src: getHref(element),
                    }).init().show();
                }
            }
        }
    });
})();
/*!
* 插件：网页媒体懒加载；使用方法：new axLazyload('#id',{参数})
*/
class axLazyload {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            type: 'single', 
            offset: '0px', 
            visible: [0, 0.5, 1], 
            parent: null,
            animation: 'ax-fadeIn',
            dataName: 'src',
        }, options, this.targetDom);
        this.handlers = {};
        this.items = [];
        this.init();
    }
    init() {
        if (this.options.type != 'single' && !this.targetDom.classList.contains('ax-lazyload')) {
            this.targetDom.classList.add('ax-lazyload');
        }
        this.interactOpt();
        this.active();
    }
    active() {
        if (this.options.type == 'single') {
            this.mediaInteract();
            this.items.push(this.targetDom);
            this.mediaInteract().observe(this.targetDom);
        } else if (this.options.type == 'multiple') {
            this.mediaInteract();
            this.items = [...this.targetDom.querySelectorAll('[data-' + this.options.dataName + ']')];
            this.items.forEach(i => {
                this.mediaInteract().observe(i);
            });
        }
    }
    interactOpt() {
        this.offset = this.options.offset.replace(/\s*/g, "").split(",");
        if (this.offset.length == 1) {
            this.offset.push(...this.offset)
        } else if (offset.length > 2) {
            this.offset.splice(0, 2);
        }
        return {
            root: this.options.parent,
            rootMargin: this.offset[0] + ' 0px ' + this.offset[1] + ' 0px',
            threshold: this.options.visible,
        }
    }
    mediaInteract() {
        let interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                if (i.isIntersecting) {
                    if (i.target.hasAttribute('data-' + this.options.dataName)) {
                        i.target.classList.add(this.options.animation);
                        if (i.target.nodeName == 'VIDEO' || i.target.nodeName == 'AUDIO') {
                            i.target.src = i.target.dataset[this.options.dataName];
                            i.target.querySelector('source').setAttribute('src', i.target.dataset[this.options.dataName]);
                        } else {
                            i.target.setAttribute('src', i.target.dataset[this.options.dataName]);
                        }
                        i.target.removeAttribute('data-' + this.options.dataName);
                        interact.unobserve(i.target);
                        'shown' in this.handlers ? this.emit('shown', i.target) : null;
                    }
                }
            });
        }, this.interactOpt());
        return interact;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axLazyload]').forEach(element => {
        new axLazyload(element, { type: 'multiple' });
    });
    document.querySelectorAll('[lazyload]').forEach(element => {
        new axLazyload(element);
    });
})();
/*!
* 插件：列表异步无限滚动；使用方法：new axInfinite('#id',{参数})
*/
class axInfinite {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            type: 'list', 
            offset: '0px', 
            visible: [0, 0.5, 1], 
            url: '', 
            urlMax: 20,
            data: [], 
            template: null, 
            selector: '',
            trigger: 'scroll',
            parent: null,
            animation: 'ax-fadeIn',
            start: 0,
            count: 10, 
            finishText: '没有更多内容了',
            nextBtn: '<button class="ax-btn ax-btn-primary ax-longer">查看更多</button>',
            active:'',
        }, options, this.targetDom);
        this.handlers = {};
        this.start = this.options.start;
        this.data = this.options.data;
        this.loadStatus = this.targetDom.querySelector('.ax-infinite-status') ? this.targetDom.querySelector('.ax-infinite-status') : axAddElem('div', { class: 'ax-infinite-status' });
        this.loadingDiv = axAddElem('div', { class: 'ax-infinite-loading' }, '<span class="ax-loading"><i></i></span>');
        this.resultDiv = axAddElem('div', { class: 'ax-infinite-tips' });
        this.nextDiv = axAddElem('div', { class: 'ax-infinite-next' }, this.options.nextBtn);
        this.nextButton = this.nextDiv.firstElementChild;
        this.loadStatus.insertAdjacentElement('afterbegin', this.loadingDiv);
        this.loadStatus.appendChild(this.resultDiv);
        this.url = [];
        if (typeof this.options.url == 'string') {
            if (this.options.url.indexOf('{') > 0 && this.options.url.indexOf('}') > 0) {
                let pageStart = ~~this.options.url.match(/\{(\S*)\}/)[1],
                    str = `{${pageStart}}`;
                for (let i = pageStart; i <= pageStart + this.options.urlMax; i++) {
                    this.url.push(this.options.url.replace(str, i));
                }
            } else if (this.options.url == 'pagination') {
                let pages = this.loadStatus.querySelectorAll('[data-page]');
                [...pages].forEach(i => {
                    this.url.push(i.href);
                });
            } else {
                this.options.url ? this.url = [this.options.url] : null;
            }
        } else if (axType(this.options.url) == 'Array') {
            this.url = this.options.url;
        }
        if (!this.options.template) {
            this.template = '';
        } else {
            if (this.options.template.trim().substr(0, 1) == '#') {
                this.template = document.querySelector(this.options.template).innerHTML
            } else {
                this.template = this.options.template;
            }
        }
        this.items = [];
        this.init();
    }
    init() {
        let _this = this;
        if (this.options.type != 'image' && !this.targetDom.classList.contains('ax-infinite')) {
            this.targetDom.classList.add('ax-infinite');
        }
        this.interactOpt();
        if (this.options.trigger == 'scroll') {
            this.active();
        } else if (this.options.trigger == 'clicks') {
            this.loadStatus.appendChild(this.nextDiv);
            this.loadStatus.setAttribute('preloading', '');
            this.targetDom.appendChild(this.loadStatus);
            this.nextButton.onclick = function () {
                _this.loadStatus.removeAttribute('preloading', '');
                _this.loadStatus.removeAttribute('loaded', '');
                _this.loadStatus.setAttribute('loading', '');
                if (_this.options.type == 'pages') {
                    _this.pageAjax(_this.start);
                } else if (_this.options.url && _this.options.template) {
                    if (_this.options.type == 'json') {
                        _this.jsonAjax(_this.start);
                    } else if (_this.options.type == 'sql') {
                        _this.sqlAjax(_this.start, _this.options.count);
                    }
                }
            }
        }
    }
    active(url, callback) {
        let _this = this;
        if (!axIsEmpty(url)) {
            if (axType(url) == 'Array') {
                this.url.push(...url)
            } else {
                this.url.push(url);
            }
        }
        if (this.options.type == 'pages') {
            this.asyncInteract(function () {
                _this.pageAjax(_this.start);
            });
        } else if (!axIsEmpty(this.url) && this.options.template) {
            if (this.options.type == 'json') {
                this.asyncInteract(function () {
                    _this.jsonAjax(_this.start);
                });
            } else if (this.options.type == 'sql') {
                this.asyncInteract(function () {
                    _this.sqlAjax(_this.start, _this.options.count);
                });
            }
        } else if (this.options.type == 'list') {
            if (!axIsEmpty(this.data)) {
                this.renderList(this.data);
            }
            let children = [...this.targetDom.childNodes].filter(i => i.nodeType == 1);
            children.forEach(i => {
                if (axOffset(i).top > window.innerHeight) {
                    i.setAttribute('infinite', '');
                    this.items.push(i);
                }
            });
            this.listInteract();
            this.items.forEach(i => {
                this.listInteract().observe(i);
            });
        }
        callback && callback.call(this);
        this.options.active && this.options.active.call(this);
        'activated' in this.handlers ? this.emit('activated','') : null;
    }
    interactOpt() {
        this.offset = this.options.offset.replace(/\s*/g, "").split(",");
        if (this.offset.length == 1) {
            this.offset.push(...this.offset)
        } else if (offset.length > 2) {
            this.offset.splice(0, 2);
        }
        return {
            root: this.options.parent,
            rootMargin: this.offset[0] + ' 0px ' + this.offset[1] + ' 0px',
            threshold: this.options.visible,
        }
    }
    listInteract() {
        let interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                if (i.isIntersecting) {
                    if (i.target.hasAttribute('infinite')) {
                        i.target.classList.add(this.options.animation);
                        i.target.removeAttribute('infinite');
                        interact.unobserve(i.target);
                    }
                    'shown' in this.handlers ? this.emit('shown', i.target) : null;
                }
            });
        }, this.interactOpt());
        return interact;
    }
    asyncInteract(callback) {
        this.targetDom.appendChild(this.loadStatus);
        this.asyncObserver = new IntersectionObserver(entries => {
            if (entries[0].isIntersecting) {
                callback();
            }
        }, this.interactOpt());
        this.asyncObserver.observe(this.loadStatus);
    }
    itemInteract() {
        let interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                if (i.isIntersecting) {
                    if (i.target.hasAttribute('infinite')) {
                        i.target.classList.add(this.options.animation);
                        i.target.removeAttribute('infinite');
                        interact.unobserve(i.target);
                    'shown' in this.handlers ? this.emit('shown', i.target) : null;
                    }
                }
            });
        }, this.interactOpt());
        return interact;
    }
    renderList(data) {
        let fragment = document.createDocumentFragment();
        data.forEach(i => {
            let item = axStrToDom(axTplEngine(this.template, i));
            item.setAttribute('infinite', '');
            this.items.push(item);
            fragment.appendChild(item);
        });
        this.targetDom.appendChild(fragment);
        !this.options.type == 'list' ? this.targetDom.appendChild(this.loadStatus) : null;
    }
    loadFinish() {
        this.options.trigger != 'clicks' ? this.asyncObserver.disconnect() : null;
        this.loadStatus.removeAttribute('loading');
        this.loadStatus.removeAttribute('loaded');
        this.loadStatus.setAttribute('finish', '');
        this.loadingDiv ? this.loadingDiv.remove() : null;
        this.nextDiv ? this.nextDiv.remove() : null;
        this.resultDiv.innerHTML = this.options.finishText;
        'finished' in this.handlers ? this.emit('finished', '') : null;
    }
    pageAjax(urlStart) {
        let _this = this;
        axAjax({
            url: _this.url[urlStart],
            selector: _this.options.selector,
            error: function (data, state) {
                console.error(`发生错误：${state}，可能是地址错误！`);
                _this.loadFinish();
            },
            success: function (content) {
                _this.targetDom.insertAdjacentHTML('beforeEnd', content);
                _this.targetDom.appendChild(_this.loadStatus);
                if (_this.options.trigger == 'clicks') {
                    _this.loadStatus.removeAttribute('loading', '');
                    _this.loadStatus.setAttribute('loaded', '');
                }
                'loaded' in _this.handlers ? _this.emit('loaded', content) : null;
                _this.start++;
                if (_this.start >= _this.url.length) {
                    _this.loadFinish();
                }
            }
        });
    }
    jsonAjax(urlStart) {
        let _this = this;
        axAjax({
            url: _this.url[urlStart],
            error: function (data, state) {
                console.error(`发生错误：${state}，可能是地址错误！`);
                _this.loadFinish();
            },
            success: function (content) {
                _this.itemInteract();
                _this.renderList(content);
                _this.targetDom.appendChild(_this.loadStatus);
                if (_this.options.trigger == 'clicks') {
                    _this.loadStatus.removeAttribute('loading', '');
                    _this.loadStatus.setAttribute('loaded', '');
                }
                _this.items.forEach(i => {
                    _this.itemInteract().observe(i);
                });
                'loaded' in _this.handlers ? _this.emit('loaded', content) : null;
                _this.start++;
                if (_this.start >= _this.url.length) {
                    _this.loadFinish();
                }
            }
        });
    }
    sqlAjax(sqlStart, sqlCount) {
        let _this = this;
        axAjax({
            url: _this.options.url,
            data: { start: sqlStart, count: sqlCount },
            error: function (data, state) {
                console.error(`发生错误：${state}，可能是地址错误！`);
                _this.loadFinish();
            },
            success: function (content) {
                _this.itemInteract();
                _this.renderList(content.data);
                _this.targetDom.appendChild(_this.loadStatus);
                if (_this.options.trigger == 'clicks') {
                    _this.loadStatus.removeAttribute('loading', '');
                    _this.loadStatus.setAttribute('loaded', '');
                }
                _this.items.forEach(i => {
                    _this.itemInteract().observe(i);
                });
                'loaded' in _this.handlers ? _this.emit('loaded', content.data) : null;
                _this.start += sqlCount;
                if (_this.start >= content.total) {
                    _this.loadFinish();
                }
            }
        });
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axInfinite]').forEach(element => {
        new axInfinite(element);
    });
})();
/*!
*项目所需的立即执行的代码片段，避免污染全局变量
*/
(() => {
    'use strict';
    const ALERTS = document.querySelectorAll('.ax-alert');
    for (let i = 0; i < ALERTS.length; i++) {
        if (ALERTS[i].querySelector('.ax-close')) {
            ALERTS[i].querySelector('.ax-close').addEventListener('click', () => {
                ALERTS[i].style.display = 'none';
            }, false);
        }
    }
    const TAGS = document.querySelectorAll('.ax-tag');
    for (let i = 0; i < TAGS.length; i++) {
        if (TAGS[i].querySelector('i,s')) {
            TAGS[i].querySelector('i,s').addEventListener('click', () => {
                TAGS[i].style.display = 'none';
            }, false);
        }
    }
    const POS_LEFT = document.querySelectorAll('.ax-pos-left');
    for (let i = 0; i < POS_LEFT.length; i++) {
        let _this = POS_LEFT[i];
        if (_this.nextElementSibling.nodeName == 'INPUT' || _this.nextElementSibling.nodeName == 'TEXTAREA') {
            _this.nextElementSibling.style.paddingLeft = `${axWidth(_this, 'outer')}px`;
        }
    }
    window.addEventListener('resize', () => {
        for (let i = 0; i < POS_LEFT.length; i++) {
            let _this = POS_LEFT[i];
            if (_this.nextElementSibling.nodeName == 'INPUT' || _this.nextElementSibling.nodeName == 'TEXTAREA') {
                _this.nextElementSibling.style.paddingLeft = `${axWidth(_this, 'outer')}px`;
            }
        }
    }, false);
    const POS_RIGHT_CLEAR = document.querySelectorAll('.ax-pos-right .ax-val-none');
    for (let i = 0; i < POS_RIGHT_CLEAR.length; i++) {
        let _this = POS_RIGHT_CLEAR[i];
        if (_this) {
            _this.addEventListener('click', function () {
                let elem = this.parentElement.previousElementSibling;
                if (elem.nodeName == 'INPUT' || elem.nodeName == 'TEXTAREA') {
                    elem.value = '';
                }
            }, false);
        }
    }
    const PANEL = document.querySelectorAll('.ax-panel');
    for (let i = 0; i < PANEL.length; i++) {
        let _this = PANEL[i],
            header = axChildren(_this, '.ax-panel-header')[0],
            body = axChildren(_this, '.ax-panel-body')[0],
            close = header ? header.querySelector('.ax-panel-close') : null;
        if (close) {
            close.addEventListener('click', function () {
                if (getComputedStyle(body).display == 'none' || getComputedStyle(body).height == '0px') {
                    this.classList.remove('ax-deg180');
                    axSlideDown(body);
                } else {
                    this.classList.add('ax-deg180');
                    axSlideUp(body);
                }
            }, false);
        }
    }
    const BOX = document.querySelectorAll('.ax-box');
    for (let i = 0; i < BOX.length; i++) {
        let _this = BOX[i],
            header = axChildren(_this, '.ax-box-header')[0],
            body = axChildren(_this, '.ax-box-body')[0],
            close = header ? header.querySelector('.ax-box-close') : null;
        if (!axChildren(header, '.ax-des')) {
            header.classList.add('ax-simple');
        }
        if (close) {
            close.addEventListener('click', function () {
                if (getComputedStyle(body).display == 'none' || getComputedStyle(body).height == '0px') {
                    this.classList.remove('ax-deg180');
                    axSlideDown(body);
                } else {
                    this.classList.add('ax-deg180');
                    axSlideUp(body);
                }
            }, false);
        }
    }
    const LIST_SELECT = document.querySelectorAll('.ax-list-select');
    for (let i = 0; i < LIST_SELECT.length; i++) {
        let _this = LIST_SELECT[i],
            block = _this.querySelectorAll('.ax-info-block');
        for (let k = 0; k < block.length; k++) {
            let __this = block[k],
                input = __this.querySelector('input'),
                div = document.createElement('div');
            div.classList.add('ax-mask');
            __this.appendChild(div);
            let mask = __this.querySelector('.ax-mask');
            if (input.disabled) {
                __this.classList.add('ax-disabled');
            } else if (input.checked) {
                __this.classList.add('ax-active');
            } else {
                __this.classList.remove('ax-active');
            }
            let numAll = _this.querySelectorAll("input:not(:disabled)").length,
                numLoad = _this.querySelectorAll("input:checked:not(:disabled)").length,
                numName = "group-select-" + _this.querySelector("input").getAttribute("name"),
                radio_1 = document.querySelector("input[type='radio'][value='1'][name=" + numName + "]"),
                radio_0 = document.querySelector("input[type='radio'][value='0'][name=" + numName + "]"),
                radio = document.querySelector("input[type='radio'][name=" + numName + "]"),
                checkbox = document.querySelector("input[type='checkbox'][name=" + numName + "]"),
                _input = document.querySelectorAll('input[name=' + numName + ']');
            if (numLoad == "0") {
                radio_1 ? radio_1.checked = false : null;
                radio_0 ? radio_0.checked = true : null;
            } else if (numLoad = numAll) {
                radio_0 ? radio_1.checked = false : null;
                radio_1 ? radio_0.checked = true : null;
            } else {
                radio ? radio.checked = false : null;
            }
            if (input.getAttribute('type') == 'checkbox' && !input.disabled) {
                let watch = () => {
                    let numFact = _this.querySelectorAll("input:checked:not(:disabled)").length;
                    if (numFact == "0") {
                        radio_1 ? radio_1.checked = false : null;
                        radio_0 ? radio_0.checked = true : null;
                    } else if (numAll != numFact) {
                        if (_input) {
                            _input.forEach(item => {
                                item.checked = false
                            });
                        }
                    } else {
                        checkbox ? checkbox.checked = true : null;
                        radio_1 ? radio_1.checked = true : null;
                    };
                }
                mask.addEventListener('click', () => {
                    if (input.checked) {
                        input.checked = false;
                        __this.classList.remove('ax-active');
                    } else {
                        input.checked = true;
                        __this.classList.add('ax-active');
                    }
                    watch();
                }, false);
            } else if (input.getAttribute("type") == "radio" && !input.disabled) {
                mask.addEventListener('click', function () {
                    let blocks = axSiblings(__this, '', '.ax-info-block');
                    for (let x = 0; x < blocks.length; x++) {
                        blocks[x].querySelector("input").checked = false;
                        blocks[x].classList.remove('ax-active');
                    }
                    input.checked = true;
                    __this.classList.add("ax-active");
                }, false);
            } else {
                __this.classList.remove("ax-active");
            }
        }
    }
    const SELECT_ALL = document.querySelectorAll('input[name^="group-select-"]');
    for (let i = 0; i < SELECT_ALL.length; i++) {
        let _this = SELECT_ALL[i],
            groupName = _this.getAttribute('name').replace('group-select-', ''),
            input = document.querySelectorAll('input[name=' + groupName + ']:not(:disabled)');
        if (_this.getAttribute("type") == "checkbox" && _this.checked) {
            for (let k = 0; k < input.length; k++) {
                input[k].checked = true;
                input[k].closest('.ax-info-block').classList.add("ax-active");
            }
        } else if (_this.getAttribute("type") == "radio" && _this.checked && _this.getAttribute("value") == "1") {
            for (let k = 0; k < input.length; k++) {
                input[k].checked = true;
                input[k].closest('.ax-info-block').classList.add("ax-active");
            }
        } else { };
        _this.addEventListener('click', function () {
            if (this.getAttribute("value") == "1" && this.checked) {
                for (let k = 0; k < input.length; k++) {
                    input[k].checked = true;
                    input[k].closest('.ax-info-block').classList.add("ax-active");
                }
            } else {
                for (let k = 0; k < input.length; k++) {
                    input[k].checked = false;
                    input[k].closest('.ax-info-block').classList.remove("ax-active");
                }
            }
        }, false);
    }
    const OVERFLOW = document.querySelectorAll('.ax-overflow');
    for (let i = 0; i < OVERFLOW.length; i++) {
        let _this = OVERFLOW[i],
            children = axChildren(_this.querySelector('.ax-inner')),
            max = 0;
        for (let k = 0; k < children.length; k++) {
            if (parseInt(getComputedStyle(children[k]).width) > max) {
                max = parseInt(getComputedStyle(children[k]).width);
            }
        }
        if (parseInt(getComputedStyle(_this).width) < max) {
            _this.classList.add('ax-done');
        }
        else {
            _this.classList.remove('ax-done');
        }
        _this.querySelector('.ax-inner').onscroll = () => {
            let minus = max - parseInt(getComputedStyle(_this).width) - this.scrollLeft;
            if (minus < 44) {
                _this.classList.remove('ax-done');
            } else {
                _this.classList.add('ax-done');
            }
        };
    }
    const BACKTOP = document.querySelectorAll('.ax-backtop');
    for (let i = 0; i < BACKTOP.length; i++) {
        let _this = BACKTOP[i],
            children = axChildren(_this, '.ax-item');
        for (let k = 0; k < children.length; k++) {
            if (children[k]) {
                children[k].onmouseenter = function () {
                    this.classList.add('ax-active');
                    if (this.querySelector(".ax-text")) { axFadeIn(this.querySelector(".ax-text")); }
                }
                children[k].onmouseleave = function () {
                    this.classList.remove('ax-active');
                    if (this.querySelector(".ax-text")) { axFadeOut(this.querySelector(".ax-text")); }
                }
            }
        }
    }
    const TOTOP = document.querySelectorAll('.ax-totop');
    for (let i = 0; i < TOTOP.length; i++) {
        TOTOP[i].addEventListener('click', function () {
            axScrollTo();
        }, false);
    }
    const RIPPLE = document.querySelectorAll('.ax-ripple');
    for (let i = 0; i < RIPPLE.length; i++) {
        let _this = RIPPLE[i],
            width = axWidth(_this, 'inner'),
            height = axHeight(_this, 'inner'),
            size = Math.max(width, height);
        _this.addEventListener('click', function (e) {
            let x = e.clientX - (axOffset(this).left - document.documentElement.scrollLeft),
                y = e.clientY - (axOffset(this).top - document.documentElement.scrollTop),
                ripple = axAddElem('u', {
                    style: `left: ${x}px;top: ${y}px; width: ${size}px;height: ${size}px`,
                });
            _this.appendChild(ripple);
            setTimeout(() => {
                ripple.parentNode.removeChild(ripple);
            }, 800);
        }, false);
    }
    const axDodge = (targetDom, text) => {
        targetDom = axIdToDom(targetDom);
        let input = targetDom.querySelector("input,textarea");
        if (text) {
            targetDom.classList.add("ax-active");
            input.value = text;
        } else {
            targetDom.classList.remove("ax-active");
            input.value = text;
        }
        return targetDom;
    }
    window.axDodge = axDodge;
    const DODGE = document.querySelectorAll('.ax-dodge');
    for (let i = 0; i < DODGE.length; i++) {
        let _this = DODGE[i],
            input = _this.querySelector("input,textarea"),
            placeholder = input.getAttribute("placeholder"),
            label = document.createElement("label");
        if (!placeholder) {
            label.innerHTML = "请输入...";
        } else {
            label.innerHTML = placeholder;
            input.setAttribute('placeholder', '');
        }
        _this.appendChild(label);
        input.onfocus = function () {
            _this.classList.add("ax-active");
        };
        input.onblur = function () {
            if (!this.value) {
                _this.classList.remove("ax-active");
            } else {
                _this.classList.add("ax-active");
            }
        };
        if (input.classList.contains("ax-lg")) {
            _this.classList.add("ax-lg");
        }
        label.onclick = function () {
            input.focus();
        };
    }
    const INPUT_FILE = document.querySelectorAll('.ax-file');
    for (let i = 0; i < INPUT_FILE.length; i++) {
        let _this = INPUT_FILE[i],
            text = _this.getAttribute('data-text'),
            placeholder = _this.getAttribute('data-placeholder'),
            file = _this.querySelector('input[type=file]');
        if (!text) {
            _this.classList.add('ax-simple');
        }
        if (file.classList.contains("ax-xs")) {
            _this.classList.add('ax-xs');
        } else if (file.classList.contains('ax-sm')) {
            _this.classList.add('ax-sm');
        } else if (file.classList.contains('ax-lg')) {
            _this.classList.add('ax-lg');
        }
        file.addEventListener('change', function () {
            _this.classList.add('ax-active');
            _this.setAttribute('data-placeholder', this.value.replace(/.*(\/|\\)/, ''));
            if (!this.value) {
                _this.setAttribute('data-placeholder', placeholder);
                _this.classList.remove('ax-active');
            }
        }, false);
        file.onfocus = () => {
            _this.classList.add("ax-focus");
        };
        file.onblur = () => {
            _this.classList.remove("ax-focus");
        };
    }
    window.addEventListener("scroll", () => {
        if (document.documentElement.scrollTop >= 400) {
            for (let i = 0; i < TOTOP.length; i++) {
                if (TOTOP[i].querySelector('a')) {
                    TOTOP[i].querySelector('a').classList.add('ax-show');
                }
            }
        } else {
            for (let i = 0; i < TOTOP.length; i++) {
                if (TOTOP[i].querySelector('a')) {
                    TOTOP[i].querySelector('a').classList.remove('ax-show');
                }
            }
        }
    }, false);
})();
